diff --git a/dist/constants.d.ts b/dist/constants.d.ts
index ffdc094a980103717af99ebf4560d1ebe26bf19a..1d79cc1186a3d6f8a66c3e6057fdbe0cdb64dafa 100644
--- a/dist/constants.d.ts
+++ b/dist/constants.d.ts
@@ -3,6 +3,7 @@ export declare const EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
 export declare const EXT_TEXTURE_WEBP = "EXT_texture_webp";
 export declare const KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
 export declare const KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
+export declare const KHR_MATERIALS_ANISOTROPY = "KHR_materials_anisotropy";
 export declare const KHR_MATERIALS_CLEARCOAT = "KHR_materials_clearcoat";
 export declare const KHR_MATERIALS_EMISSIVE_STRENGTH = "KHR_materials_emissive_strength";
 export declare const KHR_MATERIALS_IOR = "KHR_materials_ior";
@@ -10,6 +11,7 @@ export declare const KHR_MATERIALS_IRIDESCENCE = "KHR_materials_iridescence";
 export declare const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = "KHR_materials_pbrSpecularGlossiness";
 export declare const KHR_MATERIALS_SHEEN = "KHR_materials_sheen";
 export declare const KHR_MATERIALS_SPECULAR = "KHR_materials_specular";
+export declare const KHR_MATERIALS_TRANSLUCENCY = "KHR_materials_translucency";
 export declare const KHR_MATERIALS_TRANSMISSION = "KHR_materials_transmission";
 export declare const KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
 export declare const KHR_MATERIALS_VOLUME = "KHR_materials_volume";
diff --git a/dist/extensions.d.ts b/dist/extensions.d.ts
index 4f2b65a9430e25f015cf8923fcd83cb386e37fc5..a1620a0162a40a5a47cbb9443179203a554256ef 100644
--- a/dist/extensions.d.ts
+++ b/dist/extensions.d.ts
@@ -4,6 +4,7 @@ import { MeshoptCompression } from './ext-meshopt-compression';
 import { TextureWebP } from './ext-texture-webp';
 import { DracoMeshCompression } from './khr-draco-mesh-compression';
 import { LightsPunctual } from './khr-lights-punctual';
+import { MaterialsAnisotropy } from './khr-materials-anisotropy';
 import { MaterialsClearcoat } from './khr-materials-clearcoat';
 import { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';
 import { MaterialsIOR } from './khr-materials-ior';
@@ -11,6 +12,7 @@ import { MaterialsIridescence } from './khr-materials-iridescence';
 import { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';
 import { MaterialsSheen } from './khr-materials-sheen';
 import { MaterialsSpecular } from './khr-materials-specular';
+import { MaterialsTranslucency } from './khr-materials-translucency';
 import { MaterialsTransmission } from './khr-materials-transmission';
 import { MaterialsUnlit } from './khr-materials-unlit';
 import { MaterialsVariants } from './khr-materials-variants';
@@ -19,13 +21,14 @@ import { MeshQuantization } from './khr-mesh-quantization';
 import { TextureBasisu } from './khr-texture-basisu';
 import { TextureTransform } from './khr-texture-transform';
 import { XMP } from './khr-xmp-json-ld';
-export declare const KHRONOS_EXTENSIONS: (typeof DracoMeshCompression | typeof LightsPunctual | typeof MaterialsClearcoat | typeof MaterialsEmissiveStrength | typeof MaterialsIOR | typeof MaterialsIridescence | typeof MaterialsPBRSpecularGlossiness | typeof MaterialsSpecular | typeof MaterialsSheen | typeof MaterialsTransmission | typeof MaterialsUnlit | typeof MaterialsVariants | typeof MaterialsVolume | typeof MeshQuantization | typeof TextureBasisu | typeof TextureTransform | typeof XMP)[];
-export declare const ALL_EXTENSIONS: (typeof DracoMeshCompression | typeof LightsPunctual | typeof MaterialsClearcoat | typeof MaterialsEmissiveStrength | typeof MaterialsIOR | typeof MaterialsIridescence | typeof MaterialsPBRSpecularGlossiness | typeof MaterialsSpecular | typeof MaterialsSheen | typeof MaterialsTransmission | typeof MaterialsUnlit | typeof MaterialsVariants | typeof MaterialsVolume | typeof MeshQuantization | typeof TextureBasisu | typeof TextureTransform | typeof XMP | typeof MeshGPUInstancing | typeof MeshoptCompression | typeof TextureWebP)[];
+export declare const KHRONOS_EXTENSIONS: (typeof DracoMeshCompression | typeof LightsPunctual | typeof MaterialsAnisotropy | typeof MaterialsClearcoat | typeof MaterialsEmissiveStrength | typeof MaterialsIOR | typeof MaterialsIridescence | typeof MaterialsPBRSpecularGlossiness | typeof MaterialsSpecular | typeof MaterialsSheen | typeof MaterialsTranslucency | typeof MaterialsTransmission | typeof MaterialsUnlit | typeof MaterialsVariants | typeof MaterialsVolume | typeof MeshQuantization | typeof TextureBasisu | typeof TextureTransform | typeof XMP)[];
+export declare const ALL_EXTENSIONS: (typeof DracoMeshCompression | typeof LightsPunctual | typeof MaterialsAnisotropy | typeof MaterialsClearcoat | typeof MaterialsEmissiveStrength | typeof MaterialsIOR | typeof MaterialsIridescence | typeof MaterialsPBRSpecularGlossiness | typeof MaterialsSpecular | typeof MaterialsSheen | typeof MaterialsTranslucency | typeof MaterialsTransmission | typeof MaterialsUnlit | typeof MaterialsVariants | typeof MaterialsVolume | typeof MeshQuantization | typeof TextureBasisu | typeof TextureTransform | typeof XMP | typeof MeshGPUInstancing | typeof MeshoptCompression | typeof TextureWebP)[];
 export * from './ext-mesh-gpu-instancing';
 export * from './ext-meshopt-compression';
 export * from './ext-texture-webp';
 export * from './khr-draco-mesh-compression';
 export * from './khr-lights-punctual';
+export * from './khr-materials-anisotropy';
 export * from './khr-materials-clearcoat';
 export * from './khr-materials-emissive-strength';
 export * from './khr-materials-ior';
@@ -33,6 +36,7 @@ export * from './khr-materials-iridescence';
 export * from './khr-materials-sheen';
 export * from './khr-materials-specular';
 export * from './khr-materials-pbr-specular-glossiness';
+export * from './khr-materials-translucency';
 export * from './khr-materials-transmission';
 export * from './khr-materials-unlit';
 export * from './khr-materials-variants';
diff --git a/dist/extensions.js b/dist/extensions.js
index b95005b3a043aa593c859bc2c6260fd5ea80e8d2..192eb77dcbb6c304da6bcb7dea1c48d0a065ec6f 100644
--- a/dist/extensions.js
+++ b/dist/extensions.js
@@ -1,2 +1,2 @@
-var e=require("@gltf-transform/core"),t=require("ktx-parse");class s extends e.ExtensionProperty{init(){this.extensionName="EXT_mesh_gpu_instancing",this.propertyType="InstancedMesh",this.parentTypes=[e.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:"INSTANCE_ATTRIBUTE"})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}s.EXTENSION_NAME="EXT_mesh_gpu_instancing";const r="EXT_mesh_gpu_instancing";class n extends e.Extension{constructor(...t){super(...t),this.extensionName=r,this.provideTypes=[e.PropertyType.NODE],this.prewriteTypes=[e.PropertyType.ACCESSOR]}createInstancedMesh(){return new s(this.document.getGraph())}read(e){return(e.jsonDoc.json.nodes||[]).forEach((t,s)=>{if(!t.extensions||!t.extensions[r])return;const n=t.extensions[r],o=this.createInstancedMesh();for(const t in n.attributes)o.setAttribute(t,e.accessors[n.attributes[t]]);e.nodes[s].setExtension(r,o)}),this}prewrite(e){e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");for(const t of this.properties)for(const s of t.listAttributes())e.addAccessorToUsageGroup(s,"INSTANCE_ATTRIBUTE");return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listNodes().forEach(s=>{const n=s.getExtension(r);if(n){const o=e.nodeIndexMap.get(s),i=t.json.nodes[o],a={attributes:{}};n.listSemantics().forEach(t=>{const s=n.getAttribute(t);a.attributes[t]=e.accessorIndexMap.get(s)}),i.extensions=i.extensions||{},i.extensions[r]=a}}),this}}var o,i,a;n.EXTENSION_NAME=r,function(e){e.QUANTIZE="quantize",e.FILTER="filter"}(o||(o={})),function(e){e.ATTRIBUTES="ATTRIBUTES",e.TRIANGLES="TRIANGLES",e.INDICES="INDICES"}(i||(i={})),function(e){e.NONE="NONE",e.OCTAHEDRAL="OCTAHEDRAL",e.QUATERNION="QUATERNION",e.EXPONENTIAL="EXPONENTIAL"}(a||(a={}));const{BYTE:c,SHORT:u,FLOAT:l}=e.Accessor.ComponentType,{normalize:h,denormalize:f}=e.MathUtils;function p(t,s,r,n){const{filter:o,bits:p}=n,x={array:t.getArray(),byteStride:t.getElementSize()*t.getComponentSize(),componentType:t.getComponentType(),normalized:t.getNormalized()};if(r!==i.ATTRIBUTES)return x;if(o!==a.NONE){let e=t.getNormalized()?function(e){const t=e.getComponentType(),s=e.getArray(),r=new Float32Array(s.length);for(let e=0;e<s.length;e++)r[e]=f(s[e],t);return r}(t):new Float32Array(x.array);switch(o){case a.EXPONENTIAL:x.byteStride=4*t.getElementSize(),x.componentType=l,x.normalized=!1,x.array=s.encodeFilterExp(e,t.getCount(),x.byteStride,p);break;case a.OCTAHEDRAL:x.byteStride=p>8?8:4,x.componentType=p>8?u:c,x.normalized=!0,e=3===t.getElementSize()?function(e){const t=new Float32Array(4*e.length/3);for(let s=0,r=e.length/3;s<r;s++)t[4*s]=e[3*s],t[4*s+1]=e[3*s+1],t[4*s+2]=e[3*s+2];return t}(e):e,x.array=s.encodeFilterOct(e,t.getCount(),x.byteStride,p);break;case a.QUATERNION:x.byteStride=8,x.componentType=u,x.normalized=!0,x.array=s.encodeFilterQuat(e,t.getCount(),x.byteStride,p);break;default:throw new Error("Invalid filter.")}x.min=t.getMin([]),x.max=t.getMax([]),t.getNormalized()&&(x.min=x.min.map(e=>f(e,t.getComponentType())),x.max=x.max.map(e=>f(e,t.getComponentType()))),x.normalized&&(x.min=x.min.map(e=>h(e,x.componentType)),x.max=x.max.map(e=>h(e,x.componentType)))}else x.byteStride%4&&(x.array=function(t,s){const r=e.BufferUtils.padNumber(t.BYTES_PER_ELEMENT*s)/t.BYTES_PER_ELEMENT,n=new t.constructor(t.length/s*r);for(let e=0;e*s<t.length;e++)for(let o=0;o<s;o++)n[e*r+o]=t[e*s+o];return n}(x.array,t.getElementSize()),x.byteStride=x.array.byteLength/t.getCount());return x}function x(t,s){return s===e.WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER?t.listParents().some(t=>t instanceof e.Primitive&&t.getMode()===e.Primitive.Mode.TRIANGLES)?i.TRIANGLES:i.INDICES:i.ATTRIBUTES}function g(t,s){const r=s.getGraph().listParentEdges(t).filter(t=>!(t.getParent()instanceof e.Root));for(const e of r){const s=e.getName(),r=e.getAttributes().key||"";if("indices"===s)return{filter:a.NONE};if("attributes"===s){if("POSITION"===r)return{filter:a.NONE};if("TEXCOORD_0"===r)return{filter:a.NONE};if("NORMAL"===r)return{filter:a.OCTAHEDRAL,bits:8};if("TANGENT"===r)return{filter:a.OCTAHEDRAL,bits:8};if(r.startsWith("JOINTS_"))return{filter:a.NONE};if(r.startsWith("WEIGHTS_"))return{filter:a.NONE}}if("output"===s){const e=T(t);return"rotation"===e?{filter:a.QUATERNION,bits:16}:"translation"===e||"scale"===e?{filter:a.EXPONENTIAL,bits:12}:{filter:a.NONE}}if("input"===s)return{filter:a.NONE};if("inverseBindMatrices"===s)return{filter:a.NONE}}return{filter:a.NONE}}function T(t){for(const s of t.listParents())if(s instanceof e.AnimationSampler)for(const t of s.listParents())if(t instanceof e.AnimationChannel)return t.getTargetPath();return null}const d="EXT_meshopt_compression",m={method:o.QUANTIZE};class E extends e.Extension{constructor(...t){super(...t),this.extensionName=d,this.prereadTypes=[e.PropertyType.BUFFER,e.PropertyType.PRIMITIVE],this.prewriteTypes=[e.PropertyType.BUFFER,e.PropertyType.ACCESSOR],this.readDependencies=["meshopt.decoder"],this.writeDependencies=["meshopt.encoder"],this._decoder=null,this._decoderFallbackBufferMap=new Map,this._encoder=null,this._encoderOptions=m,this._encoderFallbackBuffer=null,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={}}install(e,t){return"meshopt.decoder"===e&&(this._decoder=t),"meshopt.encoder"===e&&(this._encoder=t),this}setEncoderOptions(e){return this._encoderOptions={...m,...e},this}preread(t,s){if(!this._decoder){if(!this.isRequired())return this;throw new Error(`[${d}] Please install extension dependency, "meshopt.decoder".`)}if(!this._decoder.supported){if(!this.isRequired())return this;throw new Error(`[${d}]: Missing WASM support.`)}return s===e.PropertyType.BUFFER?this._prereadBuffers(t):s===e.PropertyType.PRIMITIVE&&this._prereadPrimitives(t),this}_prereadBuffers(t){const s=t.jsonDoc;(s.json.bufferViews||[]).forEach((r,n)=>{if(!r.extensions||!r.extensions[d])return;const o=r.extensions[d],i=o.byteOffset||0,a=o.byteLength||0,c=o.count,u=o.byteStride,l=new Uint8Array(c*u),h=s.json.buffers[r.buffer],f=e.BufferUtils.toView(h.uri?s.resources[h.uri]:s.resources[e.GLB_BUFFER],i,a);this._decoder.decodeGltfBuffer(l,c,u,f,o.mode,o.filter),t.bufferViews[n]=l})}_prereadPrimitives(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach(s=>{var r;s.extensions&&s.extensions[d]&&(r=t.json.buffers[s.buffer]).extensions&&r.extensions.EXT_meshopt_compression&&r.extensions.EXT_meshopt_compression.fallback&&this._decoderFallbackBufferMap.set(e.buffers[s.buffer],e.buffers[s.extensions[d].buffer])})}read(t){if(!this.isRequired())return this;for(const[t,s]of this._decoderFallbackBufferMap){for(const r of t.listParents())r instanceof e.Accessor&&r.swap(t,s);t.dispose()}return this}prewrite(t,s){return s===e.PropertyType.ACCESSOR?this._prewriteAccessors(t):s===e.PropertyType.BUFFER&&this._prewriteBuffers(t),this}_prewriteAccessors(t){const s=t.jsonDoc.json,r=this._encoder,n=this._encoderOptions,i=this.document.createBuffer(),c=this.document.getRoot().listBuffers().indexOf(i);this._encoderFallbackBuffer=i,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={};for(const i of this.document.getRoot().listAccessors()){if("weights"===T(i))continue;const u=t.getAccessorUsage(i),l=x(i,u),h=n.method===o.FILTER?g(i,this.document):{filter:a.NONE},f=p(i,r,l,h),{array:m,byteStride:E}=f,I=i.getBuffer();if(!I)throw new Error(`${d}: Missing buffer for accessor.`);const y=this.document.getRoot().listBuffers().indexOf(I),R=[u,l,h.filter,E,y].join(":");let N=this._encoderBufferViews[R],A=this._encoderBufferViewData[R],_=this._encoderBufferViewAccessors[R];N&&A||(_=this._encoderBufferViewAccessors[R]=[],A=this._encoderBufferViewData[R]=[],N=this._encoderBufferViews[R]={buffer:c,target:e.WriterContext.USAGE_TO_TARGET[u],byteOffset:0,byteLength:0,byteStride:u===e.WriterContext.BufferViewUsage.ARRAY_BUFFER?E:void 0,extensions:{[d]:{buffer:y,byteOffset:0,byteLength:0,mode:l,filter:h.filter!==a.NONE?h.filter:void 0,byteStride:E,count:0}}});const S=t.createAccessorDef(i);S.componentType=f.componentType,S.normalized=f.normalized,S.byteOffset=N.byteLength,S.min&&f.min&&(S.min=f.min),S.max&&f.max&&(S.max=f.max),t.accessorIndexMap.set(i,s.accessors.length),s.accessors.push(S),_.push(S),A.push(new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),N.byteLength+=m.byteLength,N.extensions.EXT_meshopt_compression.count+=i.getCount()}}_prewriteBuffers(t){const s=this._encoder;for(const r in this._encoderBufferViews){const n=this._encoderBufferViews[r],o=this._encoderBufferViewData[r],i=this.document.getRoot().listBuffers()[n.extensions[d].buffer],a=t.otherBufferViews.get(i)||[],{count:c,byteStride:u,mode:l}=n.extensions[d],h=e.BufferUtils.concat(o),f=s.encodeGltfBuffer(h,c,u,l),p=e.BufferUtils.pad(f);n.extensions[d].byteLength=f.byteLength,o.length=0,o.push(p),a.push(p),t.otherBufferViews.set(i,a)}}write(t){let s=0;for(const r in this._encoderBufferViews){const n=this._encoderBufferViews[r],o=t.otherBufferViewsIndexMap.get(this._encoderBufferViewData[r][0]),i=this._encoderBufferViewAccessors[r];for(const e of i)e.bufferView=o;const a=t.jsonDoc.json.bufferViews[o],c=a.byteOffset||0;Object.assign(a,n),a.byteOffset=s,a.extensions[d].byteOffset=c,s+=e.BufferUtils.padNumber(n.byteLength)}const r=this._encoderFallbackBuffer,n=t.bufferIndexMap.get(r),o=t.jsonDoc.json.buffers[n];return o.byteLength=s,o.extensions={[d]:{fallback:!0}},r.dispose(),this}}E.EXTENSION_NAME=d,E.EncoderMethod=o;const I="EXT_texture_webp";class y{match(e){return e.length>=12&&87===e[8]&&69===e[9]&&66===e[10]&&80===e[11]}getSize(t){const s=e.BufferUtils.decodeText(t.slice(0,4)),r=e.BufferUtils.decodeText(t.slice(8,12));if("RIFF"!==s||"WEBP"!==r)return null;const n=new DataView(t.buffer,t.byteOffset);let o=12;for(;o<n.byteLength;){const t=e.BufferUtils.decodeText(new Uint8Array([n.getUint8(o),n.getUint8(o+1),n.getUint8(o+2),n.getUint8(o+3)])),s=n.getUint32(o+4,!0);if("VP8 "===t)return[16383&n.getInt16(o+14,!0),16383&n.getInt16(o+16,!0)];if("VP8L"===t){const e=n.getUint8(o+9),t=n.getUint8(o+10),s=n.getUint8(o+11);return[1+((63&t)<<8|e),1+((15&n.getUint8(o+12))<<10|s<<2|(192&t)>>6)]}o+=8+s+s%2}return null}getChannels(e){return 4}}class R extends e.Extension{constructor(...t){super(...t),this.extensionName=I,this.prereadTypes=[e.PropertyType.TEXTURE]}static register(){e.ImageUtils.registerFormat("image/webp",new y)}preread(e){return(e.jsonDoc.json.textures||[]).forEach(e=>{e.extensions&&e.extensions[I]&&(e.source=e.extensions[I].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/webp"===s.getMimeType()){const r=e.imageIndexMap.get(s);(t.json.textures||[]).forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[I]={source:e.source},delete e.source)})}}),this}}R.EXTENSION_NAME=I;const N="KHR_draco_mesh_compression";let A,_,S,C;function M(e,t){const s=new A.DecoderBuffer;try{if(s.Init(t,t.length),e.GetEncodedGeometryType(s)!==A.TRIANGULAR_MESH)throw new Error(`[${N}] Unknown geometry type.`);const r=new A.Mesh;if(!e.DecodeBufferToMesh(s,r).ok()||0===r.ptr)throw new Error(`[${N}] Decoding failure.`);return r}finally{A.destroy(s)}}function O(e,t){const s=3*t.num_faces();let r,n;if(t.num_points()<=65534){const o=s*Uint16Array.BYTES_PER_ELEMENT;r=A._malloc(o),e.GetTrianglesUInt16Array(t,o,r),n=new Uint16Array(A.HEAPU16.buffer,r,s).slice()}else{const o=s*Uint32Array.BYTES_PER_ELEMENT;r=A._malloc(o),e.GetTrianglesUInt32Array(t,o,r),n=new Uint32Array(A.HEAPU32.buffer,r,s).slice()}return A._free(r),n}function D(e,t,s,r){const n=S[r.componentType],o=_[r.componentType],i=s.num_components(),a=t.num_points()*i,c=a*o.BYTES_PER_ELEMENT,u=A._malloc(c);e.GetAttributeDataArrayForAllPoints(t,s,n,c,u);const l=new o(A.HEAPF32.buffer,u,a).slice();return A._free(u),l}var w,F;!function(e){e[e.EDGEBREAKER=1]="EDGEBREAKER",e[e.SEQUENTIAL=0]="SEQUENTIAL"}(w||(w={})),function(e){e.POSITION="POSITION",e.NORMAL="NORMAL",e.COLOR="COLOR",e.TEX_COORD="TEX_COORD",e.GENERIC="GENERIC"}(F||(F={}));const b={[F.POSITION]:14,[F.NORMAL]:10,[F.COLOR]:8,[F.TEX_COORD]:12,[F.GENERIC]:12},P={decodeSpeed:5,encodeSpeed:5,method:w.EDGEBREAKER,quantizationBits:b,quantizationVolume:"mesh"};function j(e,t=P){const s={...P,...t};s.quantizationBits={...b,...t.quantizationBits};const r=new C.Encoder,n=new C.MeshBuilder,o=new C.Mesh,i={},a=new C.DracoInt8Array;for(const t of e.listSemantics()){const a=e.getAttribute(t),c=v(t),u=U(n,a.getComponentType(),o,C[c],a.getCount(),a.getElementSize(),a.getArray());if(-1===u)throw new Error(`Error compressing "${t}" attribute.`);if(i[t]=u,"mesh"===s.quantizationVolume||"POSITION"!==t)r.SetAttributeQuantization(C[c],s.quantizationBits[c]);else{if("object"!=typeof s.quantizationVolume)throw new Error("Invalid quantization volume state.");{const{quantizationVolume:e}=s,t=Math.max(e.max[0]-e.min[0],e.max[1]-e.min[1],e.max[2]-e.min[2]);r.SetAttributeExplicitQuantization(C[c],s.quantizationBits[c],a.getElementSize(),e.min,t)}}}const c=e.getIndices();if(!c)throw new Error("Primitive must have indices.");n.AddFacesToMesh(o,c.getCount()/3,c.getArray()),r.SetSpeedOptions(s.encodeSpeed,s.decodeSpeed),r.SetTrackEncodedProperties(!0),s.method===w.SEQUENTIAL||e.listTargets().length>0?r.SetEncodingMethod(C.MESH_SEQUENTIAL_ENCODING):r.SetEncodingMethod(C.MESH_EDGEBREAKER_ENCODING);const u=r.EncodeMeshToDracoBuffer(o,a);if(u<=0)throw new Error("Error applying Draco compression.");const l=new Uint8Array(u);for(let e=0;e<u;++e)l[e]=a.GetValue(e);const h=e.getAttribute("POSITION").getCount(),f=r.GetNumberOfEncodedPoints(),p=3*r.GetNumberOfEncodedFaces();if(e.listTargets().length>0&&f!==h)throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');return C.destroy(a),C.destroy(o),C.destroy(n),C.destroy(r),{numVertices:f,numIndices:p,data:l,attributeIDs:i}}function v(e){return"POSITION"===e?F.POSITION:"NORMAL"===e?F.NORMAL:e.startsWith("COLOR_")?F.COLOR:e.startsWith("TEXCOORD_")?F.TEX_COORD:F.GENERIC}function U(t,s,r,n,o,i,a){switch(s){case e.Accessor.ComponentType.UNSIGNED_BYTE:return t.AddUInt8Attribute(r,n,o,i,a);case e.Accessor.ComponentType.BYTE:return t.AddInt8Attribute(r,n,o,i,a);case e.Accessor.ComponentType.UNSIGNED_SHORT:return t.AddUInt16Attribute(r,n,o,i,a);case e.Accessor.ComponentType.SHORT:return t.AddInt16Attribute(r,n,o,i,a);case e.Accessor.ComponentType.UNSIGNED_INT:return t.AddUInt32Attribute(r,n,o,i,a);case e.Accessor.ComponentType.FLOAT:return t.AddFloatAttribute(r,n,o,i,a);default:throw new Error(`Unexpected component type, "${s}".`)}}const B="KHR_draco_mesh_compression";class k extends e.Extension{constructor(...t){super(...t),this.extensionName=B,this.prereadTypes=[e.PropertyType.PRIMITIVE],this.prewriteTypes=[e.PropertyType.ACCESSOR],this.readDependencies=["draco3d.decoder"],this.writeDependencies=["draco3d.encoder"],this._decoderModule=null,this._encoderModule=null,this._encoderOptions={}}install(t,s){return"draco3d.decoder"===t&&(this._decoderModule=s,A=this._decoderModule,_={[e.Accessor.ComponentType.FLOAT]:Float32Array,[e.Accessor.ComponentType.UNSIGNED_INT]:Uint32Array,[e.Accessor.ComponentType.UNSIGNED_SHORT]:Uint16Array,[e.Accessor.ComponentType.UNSIGNED_BYTE]:Uint8Array,[e.Accessor.ComponentType.SHORT]:Int16Array,[e.Accessor.ComponentType.BYTE]:Int8Array},S={[e.Accessor.ComponentType.FLOAT]:A.DT_FLOAT32,[e.Accessor.ComponentType.UNSIGNED_INT]:A.DT_UINT32,[e.Accessor.ComponentType.UNSIGNED_SHORT]:A.DT_UINT16,[e.Accessor.ComponentType.UNSIGNED_BYTE]:A.DT_UINT8,[e.Accessor.ComponentType.SHORT]:A.DT_INT16,[e.Accessor.ComponentType.BYTE]:A.DT_INT8}),"draco3d.encoder"===t&&(this._encoderModule=s,C=this._encoderModule),this}setEncoderOptions(e){return this._encoderOptions=e,this}preread(t){if(!this._decoderModule)throw new Error(`[${B}] Please install extension dependency, "draco3d.decoder".`);const s=this.document.getLogger(),r=t.jsonDoc,n=new Map;try{const o=r.json.meshes||[];for(const i of o)for(const o of i.primitives){if(!o.extensions||!o.extensions[B])continue;const i=o.extensions[B];let[a,c]=n.get(i.bufferView)||[];if(!c||!a){const t=r.json.bufferViews[i.bufferView],o=r.json.buffers[t.buffer],u=e.BufferUtils.toView(o.uri?r.resources[o.uri]:r.resources[e.GLB_BUFFER],t.byteOffset||0,t.byteLength);a=new this._decoderModule.Decoder,c=M(a,u),n.set(i.bufferView,[a,c]),s.debug(`[${B}] Decompressed ${u.byteLength} bytes.`)}for(const e in o.attributes){const s=t.jsonDoc.json.accessors[o.attributes[e]],r=a.GetAttributeByUniqueId(c,i.attributes[e]),n=D(a,c,r,s);t.accessors[o.attributes[e]].setArray(n)}void 0!==o.indices&&t.accessors[o.indices].setArray(O(a,c))}}finally{for(const[e,t]of Array.from(n.values()))this._decoderModule.destroy(e),this._decoderModule.destroy(t)}return this}read(e){return this}prewrite(t,s){if(!this._encoderModule)throw new Error(`[${B}] Please install extension dependency, "draco3d.encoder".`);const r=this.document.getLogger();r.debug(`[${B}] Compression options: ${JSON.stringify(this._encoderOptions)}`);const n=function(t){const s=t.getLogger(),r=new Set,n=new Set;for(const o of t.getRoot().listMeshes())for(const t of o.listPrimitives())t.getIndices()?t.getMode()!==e.Primitive.Mode.TRIANGLES?(n.add(t),s.warn(`[${B}] Skipping Draco compression on non-TRIANGLES primitive.`)):r.add(t):(n.add(t),s.warn(`[${B}] Skipping Draco compression on non-indexed primitive.`));const o=t.getRoot().listAccessors(),i=new Map;for(let e=0;e<o.length;e++)i.set(o[e],e);const a=new Map,c=new Set,u=new Map;for(const e of Array.from(r)){let s=G(e,i);if(c.has(s))u.set(e,s);else{if(a.has(e.getIndices())){const s=e.getIndices(),r=s.clone();i.set(r,t.getRoot().listAccessors().length-1),e.swap(s,r)}for(const s of e.listAttributes())if(a.has(s)){const r=s.clone();i.set(r,t.getRoot().listAccessors().length-1),e.swap(s,r)}s=G(e,i),c.add(s),u.set(e,s),a.set(e.getIndices(),s);for(const t of e.listAttributes())a.set(t,s)}}for(const t of Array.from(a.keys())){const s=new Set(t.listParents().map(e=>e.propertyType));if(2!==s.size||!s.has(e.PropertyType.PRIMITIVE)||!s.has(e.PropertyType.ROOT))throw new Error(`[${B}] Compressed accessors must only be used as indices or vertex attributes.`)}for(const e of Array.from(r)){const t=u.get(e),s=e.getIndices();if(a.get(s)!==t||e.listAttributes().some(e=>a.get(e)!==t))throw new Error(`[${B}] Draco primitives must share all, or no, accessors.`)}for(const e of Array.from(n)){const t=e.getIndices();if(a.has(t)||e.listAttributes().some(e=>a.has(e)))throw new Error(`[${B}] Accessor cannot be shared by compressed and uncompressed primitives.`)}return u}(this.document),o=new Map;let i="mesh";"scene"===this._encoderOptions.quantizationVolume&&(1!==this.document.getRoot().listScenes().length?r.warn(`[${B}]: quantizationVolume=scene requires exactly 1 scene.`):i=e.bounds(this.document.getRoot().listScenes().pop()));for(const e of Array.from(n.keys())){const s=n.get(e);if(!s)throw new Error("Unexpected primitive.");if(o.has(s)){o.set(s,o.get(s));continue}const r=e.getIndices(),a=t.jsonDoc.json.accessors,c=j(e,{...this._encoderOptions,quantizationVolume:i});o.set(s,c);const u=t.createAccessorDef(r);u.count=c.numIndices,t.accessorIndexMap.set(r,a.length),a.push(u);for(const s of e.listSemantics()){const r=e.getAttribute(s),n=t.createAccessorDef(r);n.count=c.numVertices,t.accessorIndexMap.set(r,a.length),a.push(n)}const l=e.getAttribute("POSITION").getBuffer()||this.document.getRoot().listBuffers()[0];t.otherBufferViews.has(l)||t.otherBufferViews.set(l,[]),t.otherBufferViews.get(l).push(c.data)}return r.debug(`[${B}] Compressed ${n.size} primitives.`),t.extensionData[B]={primitiveHashMap:n,primitiveEncodingMap:o},this}write(e){const t=e.extensionData[B];for(const s of this.document.getRoot().listMeshes()){const r=e.jsonDoc.json.meshes[e.meshIndexMap.get(s)];for(let n=0;n<s.listPrimitives().length;n++){const o=s.listPrimitives()[n],i=r.primitives[n],a=t.primitiveHashMap.get(o);if(!a)continue;const c=t.primitiveEncodingMap.get(a);i.extensions=i.extensions||{},i.extensions[B]={bufferView:e.otherBufferViewsIndexMap.get(c.data),attributes:c.attributeIDs}}}if(!t.primitiveHashMap.size){const t=e.jsonDoc.json;t.extensionsUsed=(t.extensionsUsed||[]).filter(e=>e!==B),t.extensionsRequired=(t.extensionsRequired||[]).filter(e=>e!==B)}return this}}function G(e,t){const s=[],r=e.getIndices();s.push(t.get(r));for(const r of e.listAttributes())s.push(t.get(r));return s.sort().join("|")}k.EXTENSION_NAME=B,k.EncoderMethod=w;class L extends e.ExtensionProperty{init(){this.extensionName="KHR_lights_punctual",this.propertyType="Light",this.parentTypes=[e.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{color:[1,1,1],intensity:1,type:L.Type.POINT,range:null,innerConeAngle:0,outerConeAngle:Math.PI/4})}getColor(){return this.get("color")}setColor(e){return this.set("color",e)}getColorHex(){return e.ColorUtils.factorToHex(this.getColor())}setColorHex(t){const s=this.getColor().slice();return e.ColorUtils.hexToFactor(t,s),this.setColor(s)}getIntensity(){return this.get("intensity")}setIntensity(e){return this.set("intensity",e)}getType(){return this.get("type")}setType(e){return this.set("type",e)}getRange(){return this.get("range")}setRange(e){return this.set("range",e)}getInnerConeAngle(){return this.get("innerConeAngle")}setInnerConeAngle(e){return this.set("innerConeAngle",e)}getOuterConeAngle(){return this.get("outerConeAngle")}setOuterConeAngle(e){return this.set("outerConeAngle",e)}}L.EXTENSION_NAME="KHR_lights_punctual",L.Type={POINT:"point",SPOT:"spot",DIRECTIONAL:"directional"};const H="KHR_lights_punctual";class V extends e.Extension{constructor(...e){super(...e),this.extensionName=H}createLight(e=""){return new L(this.document.getGraph(),e)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[H])return this;const s=(t.json.extensions[H].lights||[]).map(e=>{const t=this.createLight().setName(e.name||"").setType(e.type);return void 0!==e.color&&t.setColor(e.color),void 0!==e.intensity&&t.setIntensity(e.intensity),void 0!==e.range&&t.setRange(e.range),void 0!==e.spot?.innerConeAngle&&t.setInnerConeAngle(e.spot.innerConeAngle),void 0!==e.spot?.outerConeAngle&&t.setOuterConeAngle(e.spot.outerConeAngle),t});return t.json.nodes.forEach((t,r)=>{t.extensions&&t.extensions[H]&&e.nodes[r].setExtension(H,s[t.extensions[H].light])}),this}write(t){const s=t.jsonDoc;if(0===this.properties.size)return this;const r=[],n=new Map;for(const t of this.properties){const s=t,o={type:s.getType()};e.MathUtils.eq(s.getColor(),[1,1,1])||(o.color=s.getColor()),1!==s.getIntensity()&&(o.intensity=s.getIntensity()),null!=s.getRange()&&(o.range=s.getRange()),s.getName()&&(o.name=s.getName()),s.getType()===L.Type.SPOT&&(o.spot={innerConeAngle:s.getInnerConeAngle(),outerConeAngle:s.getOuterConeAngle()}),r.push(o),n.set(s,r.length-1)}return this.document.getRoot().listNodes().forEach(e=>{const r=e.getExtension(H);if(r){const o=t.nodeIndexMap.get(e),i=s.json.nodes[o];i.extensions=i.extensions||{},i.extensions[H]={light:n.get(r)}}}),s.json.extensions=s.json.extensions||{},s.json.extensions[H]={lights:r},this}}V.EXTENSION_NAME=H;const{R:X,G:K,B:z}=e.TextureChannel;class q extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_clearcoat",this.propertyType="Clearcoat",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{clearcoatFactor:0,clearcoatTexture:null,clearcoatTextureInfo:new e.TextureInfo(this.graph,"clearcoatTextureInfo"),clearcoatRoughnessFactor:0,clearcoatRoughnessTexture:null,clearcoatRoughnessTextureInfo:new e.TextureInfo(this.graph,"clearcoatRoughnessTextureInfo"),clearcoatNormalScale:1,clearcoatNormalTexture:null,clearcoatNormalTextureInfo:new e.TextureInfo(this.graph,"clearcoatNormalTextureInfo")})}getClearcoatFactor(){return this.get("clearcoatFactor")}setClearcoatFactor(e){return this.set("clearcoatFactor",e)}getClearcoatTexture(){return this.getRef("clearcoatTexture")}getClearcoatTextureInfo(){return this.getRef("clearcoatTexture")?this.getRef("clearcoatTextureInfo"):null}setClearcoatTexture(e){return this.setRef("clearcoatTexture",e,{channels:X})}getClearcoatRoughnessFactor(){return this.get("clearcoatRoughnessFactor")}setClearcoatRoughnessFactor(e){return this.set("clearcoatRoughnessFactor",e)}getClearcoatRoughnessTexture(){return this.getRef("clearcoatRoughnessTexture")}getClearcoatRoughnessTextureInfo(){return this.getRef("clearcoatRoughnessTexture")?this.getRef("clearcoatRoughnessTextureInfo"):null}setClearcoatRoughnessTexture(e){return this.setRef("clearcoatRoughnessTexture",e,{channels:K})}getClearcoatNormalScale(){return this.get("clearcoatNormalScale")}setClearcoatNormalScale(e){return this.set("clearcoatNormalScale",e)}getClearcoatNormalTexture(){return this.getRef("clearcoatNormalTexture")}getClearcoatNormalTextureInfo(){return this.getRef("clearcoatNormalTexture")?this.getRef("clearcoatNormalTextureInfo"):null}setClearcoatNormalTexture(e){return this.setRef("clearcoatNormalTexture",e,{channels:X|K|z})}}q.EXTENSION_NAME="KHR_materials_clearcoat";const $="KHR_materials_clearcoat";class Q extends e.Extension{constructor(...e){super(...e),this.extensionName=$}createClearcoat(){return new q(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[$]){const n=this.createClearcoat();e.materials[r].setExtension($,n);const o=t.extensions[$];if(void 0!==o.clearcoatFactor&&n.setClearcoatFactor(o.clearcoatFactor),void 0!==o.clearcoatRoughnessFactor&&n.setClearcoatRoughnessFactor(o.clearcoatRoughnessFactor),void 0!==o.clearcoatTexture){const t=o.clearcoatTexture;n.setClearcoatTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatTextureInfo(),t)}if(void 0!==o.clearcoatRoughnessTexture){const t=o.clearcoatRoughnessTexture;n.setClearcoatRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatRoughnessTextureInfo(),t)}if(void 0!==o.clearcoatNormalTexture){const t=o.clearcoatNormalTexture;n.setClearcoatNormalTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatNormalTextureInfo(),t),void 0!==t.scale&&n.setClearcoatNormalScale(t.scale)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension($);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[$]={clearcoatFactor:r.getClearcoatFactor(),clearcoatRoughnessFactor:r.getClearcoatRoughnessFactor()};if(r.getClearcoatTexture()){const t=r.getClearcoatTexture(),s=r.getClearcoatTextureInfo();i.clearcoatTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatRoughnessTexture()){const t=r.getClearcoatRoughnessTexture(),s=r.getClearcoatRoughnessTextureInfo();i.clearcoatRoughnessTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatNormalTexture()){const t=r.getClearcoatNormalTexture(),s=r.getClearcoatNormalTextureInfo();i.clearcoatNormalTexture=e.createTextureInfoDef(t,s),1!==r.getClearcoatNormalScale()&&(i.clearcoatNormalTexture.scale=r.getClearcoatNormalScale())}}}),this}}Q.EXTENSION_NAME=$;class Y extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_emissive_strength",this.propertyType="EmissiveStrength",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{emissiveStrength:1})}getEmissiveStrength(){return this.get("emissiveStrength")}setEmissiveStrength(e){return this.set("emissiveStrength",e)}}Y.EXTENSION_NAME="KHR_materials_emissive_strength";const W="KHR_materials_emissive_strength";class J extends e.Extension{constructor(...e){super(...e),this.extensionName=W}createEmissiveStrength(){return new Y(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[W]){const r=this.createEmissiveStrength();e.materials[s].setExtension(W,r);const n=t.extensions[W];void 0!==n.emissiveStrength&&r.setEmissiveStrength(n.emissiveStrength)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(W);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[W]={emissiveStrength:r.getEmissiveStrength()}}}),this}}J.EXTENSION_NAME=W;class Z extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_ior",this.propertyType="IOR",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{ior:0})}getIOR(){return this.get("ior")}setIOR(e){return this.set("ior",e)}}Z.EXTENSION_NAME="KHR_materials_ior";const ee="KHR_materials_ior";class te extends e.Extension{constructor(...e){super(...e),this.extensionName=ee}createIOR(){return new Z(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[ee]){const r=this.createIOR();e.materials[s].setExtension(ee,r);const n=t.extensions[ee];void 0!==n.ior&&r.setIOR(n.ior)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ee);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[ee]={ior:r.getIOR()}}}),this}}te.EXTENSION_NAME=ee;const{R:se,G:re}=e.TextureChannel;class ne extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_iridescence",this.propertyType="Iridescence",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{iridescenceFactor:0,iridescenceTexture:null,iridescenceTextureInfo:new e.TextureInfo(this.graph,"iridescenceTextureInfo"),iridescenceIOR:1.3,iridescenceThicknessMinimum:100,iridescenceThicknessMaximum:400,iridescenceThicknessTexture:null,iridescenceThicknessTextureInfo:new e.TextureInfo(this.graph,"iridescenceThicknessTextureInfo")})}getIridescenceFactor(){return this.get("iridescenceFactor")}setIridescenceFactor(e){return this.set("iridescenceFactor",e)}getIridescenceTexture(){return this.getRef("iridescenceTexture")}getIridescenceTextureInfo(){return this.getRef("iridescenceTexture")?this.getRef("iridescenceTextureInfo"):null}setIridescenceTexture(e){return this.setRef("iridescenceTexture",e,{channels:se})}getIridescenceIOR(){return this.get("iridescenceIOR")}setIridescenceIOR(e){return this.set("iridescenceIOR",e)}getIridescenceThicknessMinimum(){return this.get("iridescenceThicknessMinimum")}setIridescenceThicknessMinimum(e){return this.set("iridescenceThicknessMinimum",e)}getIridescenceThicknessMaximum(){return this.get("iridescenceThicknessMaximum")}setIridescenceThicknessMaximum(e){return this.set("iridescenceThicknessMaximum",e)}getIridescenceThicknessTexture(){return this.getRef("iridescenceThicknessTexture")}getIridescenceThicknessTextureInfo(){return this.getRef("iridescenceThicknessTexture")?this.getRef("iridescenceThicknessTextureInfo"):null}setIridescenceThicknessTexture(e){return this.setRef("iridescenceThicknessTexture",e,{channels:re})}}ne.EXTENSION_NAME="KHR_materials_iridescence";const oe="KHR_materials_iridescence";class ie extends e.Extension{constructor(...e){super(...e),this.extensionName=oe}createIridescence(){return new ne(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[oe]){const n=this.createIridescence();e.materials[r].setExtension(oe,n);const o=t.extensions[oe];if(void 0!==o.iridescenceFactor&&n.setIridescenceFactor(o.iridescenceFactor),void 0!==o.iridescenceIOR&&n.setIridescenceIOR(o.iridescenceIOR),void 0!==o.iridescenceThicknessMinimum&&n.setIridescenceThicknessMinimum(o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&n.setIridescenceThicknessMaximum(o.iridescenceThicknessMaximum),void 0!==o.iridescenceTexture){const t=o.iridescenceTexture;n.setIridescenceTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceTextureInfo(),t)}if(void 0!==o.iridescenceThicknessTexture){const t=o.iridescenceThicknessTexture;n.setIridescenceThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(oe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[oe]={};if(r.getIridescenceFactor()>0&&(i.iridescenceFactor=r.getIridescenceFactor()),1.3!==r.getIridescenceIOR()&&(i.iridescenceIOR=r.getIridescenceIOR()),100!==r.getIridescenceThicknessMinimum()&&(i.iridescenceThicknessMinimum=r.getIridescenceThicknessMinimum()),400!==r.getIridescenceThicknessMaximum()&&(i.iridescenceThicknessMaximum=r.getIridescenceThicknessMaximum()),r.getIridescenceTexture()){const t=r.getIridescenceTexture(),s=r.getIridescenceTextureInfo();i.iridescenceTexture=e.createTextureInfoDef(t,s)}if(r.getIridescenceThicknessTexture()){const t=r.getIridescenceThicknessTexture(),s=r.getIridescenceThicknessTextureInfo();i.iridescenceThicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}ie.EXTENSION_NAME=oe;const{R:ae,G:ce,B:ue,A:le}=e.TextureChannel;class he extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_pbrSpecularGlossiness",this.propertyType="PBRSpecularGlossiness",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{diffuseFactor:[1,1,1,1],diffuseTexture:null,diffuseTextureInfo:new e.TextureInfo(this.graph,"diffuseTextureInfo"),specularFactor:[1,1,1],glossinessFactor:1,specularGlossinessTexture:null,specularGlossinessTextureInfo:new e.TextureInfo(this.graph,"specularGlossinessTextureInfo")})}getDiffuseFactor(){return this.get("diffuseFactor")}setDiffuseFactor(e){return this.set("diffuseFactor",e)}getDiffuseHex(){return e.ColorUtils.factorToHex(this.getDiffuseFactor())}setDiffuseHex(t){const s=this.getDiffuseFactor().slice();return this.setDiffuseFactor(e.ColorUtils.hexToFactor(t,s))}getDiffuseTexture(){return this.getRef("diffuseTexture")}getDiffuseTextureInfo(){return this.getRef("diffuseTexture")?this.getRef("diffuseTextureInfo"):null}setDiffuseTexture(e){return this.setRef("diffuseTexture",e,{channels:ae|ce|ue|le})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getGlossinessFactor(){return this.get("glossinessFactor")}setGlossinessFactor(e){return this.set("glossinessFactor",e)}getSpecularGlossinessTexture(){return this.getRef("specularGlossinessTexture")}getSpecularGlossinessTextureInfo(){return this.getRef("specularGlossinessTexture")?this.getRef("specularGlossinessTextureInfo"):null}setSpecularGlossinessTexture(e){return this.setRef("specularGlossinessTexture",e,{channels:ae|ce|ue|le})}}he.EXTENSION_NAME="KHR_materials_pbrSpecularGlossiness";const fe="KHR_materials_pbrSpecularGlossiness";class pe extends e.Extension{constructor(...e){super(...e),this.extensionName=fe}createPBRSpecularGlossiness(){return new he(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[fe]){const n=this.createPBRSpecularGlossiness();e.materials[r].setExtension(fe,n);const o=t.extensions[fe];if(void 0!==o.diffuseFactor&&n.setDiffuseFactor(o.diffuseFactor),void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.glossinessFactor&&n.setGlossinessFactor(o.glossinessFactor),void 0!==o.diffuseTexture){const t=o.diffuseTexture;n.setDiffuseTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getDiffuseTextureInfo(),t)}if(void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;n.setSpecularGlossinessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularGlossinessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(fe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[fe]={diffuseFactor:r.getDiffuseFactor(),specularFactor:r.getSpecularFactor(),glossinessFactor:r.getGlossinessFactor()};if(r.getDiffuseTexture()){const t=r.getDiffuseTexture(),s=r.getDiffuseTextureInfo();i.diffuseTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularGlossinessTexture()){const t=r.getSpecularGlossinessTexture(),s=r.getSpecularGlossinessTextureInfo();i.specularGlossinessTexture=e.createTextureInfoDef(t,s)}}}),this}}pe.EXTENSION_NAME=fe;const{R:xe,G:ge,B:Te,A:de}=e.TextureChannel;class me extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_sheen",this.propertyType="Sheen",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{sheenColorFactor:[0,0,0],sheenColorTexture:null,sheenColorTextureInfo:new e.TextureInfo(this.graph,"sheenColorTextureInfo"),sheenRoughnessFactor:0,sheenRoughnessTexture:null,sheenRoughnessTextureInfo:new e.TextureInfo(this.graph,"sheenRoughnessTextureInfo")})}getSheenColorFactor(){return this.get("sheenColorFactor")}getSheenColorHex(){return e.ColorUtils.factorToHex(this.getSheenColorFactor())}setSheenColorFactor(e){return this.set("sheenColorFactor",e)}setSheenColorHex(t){const s=this.getSheenColorFactor().slice();return this.set("sheenColorFactor",e.ColorUtils.hexToFactor(t,s))}getSheenColorTexture(){return this.getRef("sheenColorTexture")}getSheenColorTextureInfo(){return this.getRef("sheenColorTexture")?this.getRef("sheenColorTextureInfo"):null}setSheenColorTexture(e){return this.setRef("sheenColorTexture",e,{channels:xe|ge|Te})}getSheenRoughnessFactor(){return this.get("sheenRoughnessFactor")}setSheenRoughnessFactor(e){return this.set("sheenRoughnessFactor",e)}getSheenRoughnessTexture(){return this.getRef("sheenRoughnessTexture")}getSheenRoughnessTextureInfo(){return this.getRef("sheenRoughnessTexture")?this.getRef("sheenRoughnessTextureInfo"):null}setSheenRoughnessTexture(e){return this.setRef("sheenRoughnessTexture",e,{channels:de})}}me.EXTENSION_NAME="KHR_materials_sheen";const Ee="KHR_materials_sheen";class Ie extends e.Extension{constructor(...e){super(...e),this.extensionName=Ee}createSheen(){return new me(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ee]){const n=this.createSheen();e.materials[r].setExtension(Ee,n);const o=t.extensions[Ee];if(void 0!==o.sheenColorFactor&&n.setSheenColorFactor(o.sheenColorFactor),void 0!==o.sheenRoughnessFactor&&n.setSheenRoughnessFactor(o.sheenRoughnessFactor),void 0!==o.sheenColorTexture){const t=o.sheenColorTexture;n.setSheenColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenColorTextureInfo(),t)}if(void 0!==o.sheenRoughnessTexture){const t=o.sheenRoughnessTexture;n.setSheenRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenRoughnessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ee);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ee]={sheenColorFactor:r.getSheenColorFactor(),sheenRoughnessFactor:r.getSheenRoughnessFactor()};if(r.getSheenColorTexture()){const t=r.getSheenColorTexture(),s=r.getSheenColorTextureInfo();i.sheenColorTexture=e.createTextureInfoDef(t,s)}if(r.getSheenRoughnessTexture()){const t=r.getSheenRoughnessTexture(),s=r.getSheenRoughnessTextureInfo();i.sheenRoughnessTexture=e.createTextureInfoDef(t,s)}}}),this}}Ie.EXTENSION_NAME=Ee;const{R:ye,G:Re,B:Ne,A:Ae}=e.TextureChannel;class _e extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_specular",this.propertyType="Specular",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{specularFactor:1,specularTexture:null,specularTextureInfo:new e.TextureInfo(this.graph,"specularTextureInfo"),specularColorFactor:[1,1,1],specularColorTexture:null,specularColorTextureInfo:new e.TextureInfo(this.graph,"specularColorTextureInfo")})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getSpecularColorFactor(){return this.get("specularColorFactor")}setSpecularColorFactor(e){return this.set("specularColorFactor",e)}getSpecularColorHex(){return e.ColorUtils.factorToHex(this.getSpecularColorFactor())}setSpecularColorHex(t){const s=this.getSpecularColorFactor().slice();return this.set("specularColorFactor",e.ColorUtils.hexToFactor(t,s))}getSpecularTexture(){return this.getRef("specularTexture")}getSpecularTextureInfo(){return this.getRef("specularTexture")?this.getRef("specularTextureInfo"):null}setSpecularTexture(e){return this.setRef("specularTexture",e,{channels:Ae})}getSpecularColorTexture(){return this.getRef("specularColorTexture")}getSpecularColorTextureInfo(){return this.getRef("specularColorTexture")?this.getRef("specularColorTextureInfo"):null}setSpecularColorTexture(e){return this.setRef("specularColorTexture",e,{channels:ye|Re|Ne})}}_e.EXTENSION_NAME="KHR_materials_specular";const Se="KHR_materials_specular";class Ce extends e.Extension{constructor(...e){super(...e),this.extensionName=Se}createSpecular(){return new _e(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Se]){const n=this.createSpecular();e.materials[r].setExtension(Se,n);const o=t.extensions[Se];if(void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.specularColorFactor&&n.setSpecularColorFactor(o.specularColorFactor),void 0!==o.specularTexture){const t=o.specularTexture;n.setSpecularTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularTextureInfo(),t)}if(void 0!==o.specularColorTexture){const t=o.specularColorTexture;n.setSpecularColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularColorTextureInfo(),t)}}}),this}write(t){const s=t.jsonDoc;return this.document.getRoot().listMaterials().forEach(r=>{const n=r.getExtension(Se);if(n){const o=t.materialIndexMap.get(r),i=s.json.materials[o];i.extensions=i.extensions||{};const a=i.extensions[Se]={};if(1!==n.getSpecularFactor()&&(a.specularFactor=n.getSpecularFactor()),e.MathUtils.eq(n.getSpecularColorFactor(),[1,1,1])||(a.specularColorFactor=n.getSpecularColorFactor()),n.getSpecularTexture()){const e=n.getSpecularTexture(),s=n.getSpecularTextureInfo();a.specularTexture=t.createTextureInfoDef(e,s)}if(n.getSpecularColorTexture()){const e=n.getSpecularColorTexture(),s=n.getSpecularColorTextureInfo();a.specularColorTexture=t.createTextureInfoDef(e,s)}}}),this}}Ce.EXTENSION_NAME=Se;const{R:Me}=e.TextureChannel;class Oe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_transmission",this.propertyType="Transmission",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{transmissionFactor:0,transmissionTexture:null,transmissionTextureInfo:new e.TextureInfo(this.graph,"transmissionTextureInfo")})}getTransmissionFactor(){return this.get("transmissionFactor")}setTransmissionFactor(e){return this.set("transmissionFactor",e)}getTransmissionTexture(){return this.getRef("transmissionTexture")}getTransmissionTextureInfo(){return this.getRef("transmissionTexture")?this.getRef("transmissionTextureInfo"):null}setTransmissionTexture(e){return this.setRef("transmissionTexture",e,{channels:Me})}}Oe.EXTENSION_NAME="KHR_materials_transmission";const De="KHR_materials_transmission";class we extends e.Extension{constructor(...e){super(...e),this.extensionName=De}createTransmission(){return new Oe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[De]){const n=this.createTransmission();e.materials[r].setExtension(De,n);const o=t.extensions[De];if(void 0!==o.transmissionFactor&&n.setTransmissionFactor(o.transmissionFactor),void 0!==o.transmissionTexture){const t=o.transmissionTexture;n.setTransmissionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTransmissionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(De);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[De]={transmissionFactor:r.getTransmissionFactor()};if(r.getTransmissionTexture()){const t=r.getTransmissionTexture(),s=r.getTransmissionTextureInfo();i.transmissionTexture=e.createTextureInfoDef(t,s)}}}),this}}we.EXTENSION_NAME=De;class Fe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_unlit",this.propertyType="Unlit",this.parentTypes=[e.PropertyType.MATERIAL]}}Fe.EXTENSION_NAME="KHR_materials_unlit";const be="KHR_materials_unlit";class Pe extends e.Extension{constructor(...e){super(...e),this.extensionName=be}createUnlit(){return new Fe(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{t.extensions&&t.extensions[be]&&e.materials[s].setExtension(be,this.createUnlit())}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{if(s.getExtension(be)){const r=e.materialIndexMap.get(s),n=t.json.materials[r];n.extensions=n.extensions||{},n.extensions[be]={}}}),this}}Pe.EXTENSION_NAME=be;class je extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Mapping",this.parentTypes=["MappingList"]}getDefaults(){return Object.assign(super.getDefaults(),{material:null,variants:[]})}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}addVariant(e){return this.addRef("variants",e)}removeVariant(e){return this.removeRef("variants",e)}listVariants(){return this.listRefs("variants")}}je.EXTENSION_NAME="KHR_materials_variants";class ve extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="MappingList",this.parentTypes=[e.PropertyType.PRIMITIVE]}getDefaults(){return Object.assign(super.getDefaults(),{mappings:[]})}addMapping(e){return this.addRef("mappings",e)}removeMapping(e){return this.removeRef("mappings",e)}listMappings(){return this.listRefs("mappings")}}ve.EXTENSION_NAME="KHR_materials_variants";class Ue extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Variant",this.parentTypes=["MappingList"]}}Ue.EXTENSION_NAME="KHR_materials_variants";const Be="KHR_materials_variants";class ke extends e.Extension{constructor(...e){super(...e),this.extensionName=Be}createMappingList(){return new ve(this.document.getGraph())}createVariant(e=""){return new Ue(this.document.getGraph(),e)}createMapping(){return new je(this.document.getGraph())}listVariants(){return Array.from(this.properties).filter(e=>e instanceof Ue)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[Be])return this;const s=(t.json.extensions[Be].variants||[]).map(e=>this.createVariant().setName(e.name||""));return(t.json.meshes||[]).forEach((t,r)=>{const n=e.meshes[r];(t.primitives||[]).forEach((t,r)=>{if(!t.extensions||!t.extensions[Be])return;const o=this.createMappingList(),i=t.extensions[Be];for(const t of i.mappings){const r=this.createMapping();void 0!==t.material&&r.setMaterial(e.materials[t.material]);for(const e of t.variants||[])r.addVariant(s[e]);o.addMapping(r)}n.listPrimitives()[r].setExtension(Be,o)})}),this}write(e){const t=e.jsonDoc,s=this.listVariants();if(!s.length)return this;const r=[],n=new Map;for(const t of s)n.set(t,r.length),r.push(e.createPropertyDef(t));for(const t of this.document.getRoot().listMeshes()){const s=e.meshIndexMap.get(t);t.listPrimitives().forEach((t,r)=>{const o=t.getExtension(Be);if(!o)return;const i=e.jsonDoc.json.meshes[s].primitives[r],a=o.listMappings().map(t=>{const s=e.createPropertyDef(t),r=t.getMaterial();return r&&(s.material=e.materialIndexMap.get(r)),s.variants=t.listVariants().map(e=>n.get(e)),s});i.extensions=i.extensions||{},i.extensions[Be]={mappings:a}})}return t.json.extensions=t.json.extensions||{},t.json.extensions[Be]={variants:r},this}}ke.EXTENSION_NAME=Be;const{G:Ge}=e.TextureChannel;class Le extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_volume",this.propertyType="Volume",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{thicknessFactor:0,thicknessTexture:null,thicknessTextureInfo:new e.TextureInfo(this.graph,"thicknessTexture"),attenuationDistance:Infinity,attenuationColor:[1,1,1]})}getThicknessFactor(){return this.get("thicknessFactor")}setThicknessFactor(e){return this.set("thicknessFactor",e)}getThicknessTexture(){return this.getRef("thicknessTexture")}getThicknessTextureInfo(){return this.getRef("thicknessTexture")?this.getRef("thicknessTextureInfo"):null}setThicknessTexture(e){return this.setRef("thicknessTexture",e,{channels:Ge})}getAttenuationDistance(){return this.get("attenuationDistance")}setAttenuationDistance(e){return this.set("attenuationDistance",e)}getAttenuationColor(){return this.get("attenuationColor")}setAttenuationColor(e){return this.set("attenuationColor",e)}getAttenuationColorHex(){return e.ColorUtils.factorToHex(this.getAttenuationColor())}setAttenuationColorHex(t){const s=this.getAttenuationColor().slice();return this.set("attenuationColor",e.ColorUtils.hexToFactor(t,s))}}Le.EXTENSION_NAME="KHR_materials_volume";const He="KHR_materials_volume";class Ve extends e.Extension{constructor(...e){super(...e),this.extensionName=He}createVolume(){return new Le(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[He]){const n=this.createVolume();e.materials[r].setExtension(He,n);const o=t.extensions[He];if(void 0!==o.thicknessFactor&&n.setThicknessFactor(o.thicknessFactor),void 0!==o.attenuationDistance&&n.setAttenuationDistance(o.attenuationDistance),void 0!==o.attenuationColor&&n.setAttenuationColor(o.attenuationColor),void 0!==o.thicknessTexture){const t=o.thicknessTexture;n.setThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getThicknessTextureInfo(),t)}}}),this}write(t){const s=t.jsonDoc;return this.document.getRoot().listMaterials().forEach(r=>{const n=r.getExtension(He);if(n){const o=t.materialIndexMap.get(r),i=s.json.materials[o];i.extensions=i.extensions||{};const a=i.extensions[He]={};if(n.getThicknessFactor()>0&&(a.thicknessFactor=n.getThicknessFactor()),Number.isFinite(n.getAttenuationDistance())&&(a.attenuationDistance=n.getAttenuationDistance()),e.MathUtils.eq(n.getAttenuationColor(),[1,1,1])||(a.attenuationColor=n.getAttenuationColor()),n.getThicknessTexture()){const e=n.getThicknessTexture(),s=n.getThicknessTextureInfo();a.thicknessTexture=t.createTextureInfoDef(e,s)}}}),this}}Ve.EXTENSION_NAME=He;const Xe="KHR_mesh_quantization";class Ke extends e.Extension{constructor(...e){super(...e),this.extensionName=Xe}read(e){return this}write(e){return this}}Ke.EXTENSION_NAME=Xe;const ze="KHR_texture_basisu";class qe{match(e){return 171===e[0]&&75===e[1]&&84===e[2]&&88===e[3]&&32===e[4]&&50===e[5]&&48===e[6]&&187===e[7]&&13===e[8]&&10===e[9]&&26===e[10]&&10===e[11]}getSize(e){const s=t.read(e);return[s.pixelWidth,s.pixelHeight]}getChannels(e){const s=t.read(e).dataFormatDescriptor[0];if(s.colorModel===t.KTX2Model.ETC1S)return 2===s.samples.length&&15==(15&s.samples[1].channelID)?4:3;if(s.colorModel===t.KTX2Model.UASTC)return 3==(15&s.samples[0].channelID)?4:3;throw new Error(`Unexpected KTX2 colorModel, "${s.colorModel}".`)}getGPUByteLength(e){const s=t.read(e),r=this.getChannels(e)>3;let n=0;for(let e=0;e<s.levels.length;e++){const t=s.levels[e];n+=t.uncompressedByteLength?t.uncompressedByteLength:Math.max(1,Math.floor(s.pixelWidth/Math.pow(2,e)))/4*(Math.max(1,Math.floor(s.pixelHeight/Math.pow(2,e)))/4)*(r?16:8)}return n}}class $e extends e.Extension{constructor(...t){super(...t),this.extensionName=ze,this.prereadTypes=[e.PropertyType.TEXTURE]}static register(){e.ImageUtils.registerFormat("image/ktx2",new qe)}preread(e){return e.jsonDoc.json.textures.forEach(e=>{e.extensions&&e.extensions[ze]&&(e.source=e.extensions[ze].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/ktx2"===s.getMimeType()){const r=e.imageIndexMap.get(s);t.json.textures.forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[ze]={source:e.source},delete e.source)})}}),this}}$e.EXTENSION_NAME=ze;class Qe extends e.ExtensionProperty{init(){this.extensionName="KHR_texture_transform",this.propertyType="Transform",this.parentTypes=[e.PropertyType.TEXTURE_INFO]}getDefaults(){return Object.assign(super.getDefaults(),{offset:[0,0],rotation:0,scale:[1,1],texCoord:null})}getOffset(){return this.get("offset")}setOffset(e){return this.set("offset",e)}getRotation(){return this.get("rotation")}setRotation(e){return this.set("rotation",e)}getScale(){return this.get("scale")}setScale(e){return this.set("scale",e)}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}}Qe.EXTENSION_NAME="KHR_texture_transform";const Ye="KHR_texture_transform";class We extends e.Extension{constructor(...e){super(...e),this.extensionName=Ye}createTransform(){return new Qe(this.document.getGraph())}read(e){for(const[t,s]of Array.from(e.textureInfos.entries())){if(!s.extensions||!s.extensions[Ye])continue;const e=this.createTransform(),r=s.extensions[Ye];void 0!==r.offset&&e.setOffset(r.offset),void 0!==r.rotation&&e.setRotation(r.rotation),void 0!==r.scale&&e.setScale(r.scale),void 0!==r.texCoord&&e.setTexCoord(r.texCoord),t.setExtension(Ye,e)}return this}write(t){const s=Array.from(t.textureInfoDefMap.entries());for(const[t,r]of s){const s=t.getExtension(Ye);if(!s)continue;r.extensions=r.extensions||{};const n={},o=e.MathUtils.eq;o(s.getOffset(),[0,0])||(n.offset=s.getOffset()),0!==s.getRotation()&&(n.rotation=s.getRotation()),o(s.getScale(),[1,1])||(n.scale=s.getScale()),null!=s.getTexCoord()&&(n.texCoord=s.getTexCoord()),r.extensions[Ye]=n}return this}}We.EXTENSION_NAME=Ye;const Je=[e.PropertyType.ROOT,e.PropertyType.SCENE,e.PropertyType.NODE,e.PropertyType.MESH,e.PropertyType.MATERIAL,e.PropertyType.TEXTURE,e.PropertyType.ANIMATION];class Ze extends e.ExtensionProperty{init(){this.extensionName="KHR_xmp_json_ld",this.propertyType="Packet",this.parentTypes=Je}getDefaults(){return Object.assign(super.getDefaults(),{context:{},properties:{}})}getContext(){return this.get("context")}setContext(e){return this.set("context",{...e})}listProperties(){return Object.keys(this.get("properties"))}getProperty(e){const t=this.get("properties");return e in t?t[e]:null}setProperty(e,t){this._assertContext(e);const s={...this.get("properties")};return t?s[e]=t:delete s[e],this.set("properties",s)}toJSONLD(){return{"@context":et(this.get("context")),...et(this.get("properties"))}}fromJSONLD(e){const t=(e=et(e))["@context"];return t&&this.set("context",t),delete e["@context"],this.set("properties",e)}_assertContext(e){if(!(e.split(":")[0]in this.get("context")))throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)}}function et(e){return JSON.parse(JSON.stringify(e))}Ze.EXTENSION_NAME="KHR_xmp_json_ld";const tt="KHR_xmp_json_ld";class st extends e.Extension{constructor(...e){super(...e),this.extensionName=tt}createPacket(){return new Ze(this.document.getGraph())}listPackets(){return Array.from(this.properties)}read(e){const t=e.jsonDoc.json.extensions?.[tt];if(!t||!t.packets)return this;const s=e.jsonDoc.json,r=this.document.getRoot(),n=t.packets.map(e=>this.createPacket().fromJSONLD(e)),o=[[s.asset],s.scenes,s.nodes,s.meshes,s.materials,s.images,s.animations],i=[[r],r.listScenes(),r.listNodes(),r.listMeshes(),r.listMaterials(),r.listTextures(),r.listAnimations()];for(let e=0;e<o.length;e++){const t=o[e]||[];for(let s=0;s<t.length;s++){const r=t[s];r.extensions&&r.extensions[tt]&&i[e][s].setExtension(tt,n[r.extensions[tt].packet])}}return this}write(t){const{json:s}=t.jsonDoc,r=[];for(const n of this.properties){r.push(n.toJSONLD());for(const o of n.listParents()){let n;switch(o.propertyType){case e.PropertyType.ROOT:n=s.asset;break;case e.PropertyType.SCENE:n=s.scenes[t.sceneIndexMap.get(o)];break;case e.PropertyType.NODE:n=s.nodes[t.nodeIndexMap.get(o)];break;case e.PropertyType.MESH:n=s.meshes[t.meshIndexMap.get(o)];break;case e.PropertyType.MATERIAL:n=s.materials[t.materialIndexMap.get(o)];break;case e.PropertyType.TEXTURE:n=s.images[t.imageIndexMap.get(o)];break;case e.PropertyType.ANIMATION:n=s.animations[t.animationIndexMap.get(o)];break;default:n=null,this.document.getLogger().warn(`[${tt}]: Unsupported parent property, "${o.propertyType}"`)}n&&(n.extensions=n.extensions||{},n.extensions[tt]={packet:r.length-1})}}return r.length>0&&(s.extensions=s.extensions||{},s.extensions[tt]={packets:r}),this}}st.EXTENSION_NAME=tt;const rt=[k,V,Q,J,te,ie,pe,Ce,Ie,we,Pe,ke,Ve,Ke,$e,We,st],nt=[n,E,R,...rt];exports.ALL_EXTENSIONS=nt,exports.Clearcoat=q,exports.DracoMeshCompression=k,exports.EmissiveStrength=Y,exports.INSTANCE_ATTRIBUTE="INSTANCE_ATTRIBUTE",exports.IOR=Z,exports.InstancedMesh=s,exports.Iridescence=ne,exports.KHRONOS_EXTENSIONS=rt,exports.Light=L,exports.LightsPunctual=V,exports.Mapping=je,exports.MappingList=ve,exports.MaterialsClearcoat=Q,exports.MaterialsEmissiveStrength=J,exports.MaterialsIOR=te,exports.MaterialsIridescence=ie,exports.MaterialsPBRSpecularGlossiness=pe,exports.MaterialsSheen=Ie,exports.MaterialsSpecular=Ce,exports.MaterialsTransmission=we,exports.MaterialsUnlit=Pe,exports.MaterialsVariants=ke,exports.MaterialsVolume=Ve,exports.MeshGPUInstancing=n,exports.MeshQuantization=Ke,exports.MeshoptCompression=E,exports.PBRSpecularGlossiness=he,exports.Packet=Ze,exports.Sheen=me,exports.Specular=_e,exports.TextureBasisu=$e,exports.TextureTransform=We,exports.TextureWebP=R,exports.Transform=Qe,exports.Transmission=Oe,exports.Unlit=Fe,exports.Variant=Ue,exports.Volume=Le,exports.XMP=st;
+var e=require("@gltf-transform/core"),t=require("ktx-parse");class s extends e.ExtensionProperty{init(){this.extensionName="EXT_mesh_gpu_instancing",this.propertyType="InstancedMesh",this.parentTypes=[e.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:"INSTANCE_ATTRIBUTE"})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}s.EXTENSION_NAME="EXT_mesh_gpu_instancing";const r="EXT_mesh_gpu_instancing";class n extends e.Extension{constructor(...t){super(...t),this.extensionName=r,this.provideTypes=[e.PropertyType.NODE],this.prewriteTypes=[e.PropertyType.ACCESSOR]}createInstancedMesh(){return new s(this.document.getGraph())}read(e){return(e.jsonDoc.json.nodes||[]).forEach((t,s)=>{if(!t.extensions||!t.extensions[r])return;const n=t.extensions[r],o=this.createInstancedMesh();for(const t in n.attributes)o.setAttribute(t,e.accessors[n.attributes[t]]);e.nodes[s].setExtension(r,o)}),this}prewrite(e){e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");for(const t of this.properties)for(const s of t.listAttributes())e.addAccessorToUsageGroup(s,"INSTANCE_ATTRIBUTE");return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listNodes().forEach(s=>{const n=s.getExtension(r);if(n){const o=e.nodeIndexMap.get(s),i=t.json.nodes[o],a={attributes:{}};n.listSemantics().forEach(t=>{const s=n.getAttribute(t);a.attributes[t]=e.accessorIndexMap.get(s)}),i.extensions=i.extensions||{},i.extensions[r]=a}}),this}}var o,i,a;n.EXTENSION_NAME=r,function(e){e.QUANTIZE="quantize",e.FILTER="filter"}(o||(o={})),function(e){e.ATTRIBUTES="ATTRIBUTES",e.TRIANGLES="TRIANGLES",e.INDICES="INDICES"}(i||(i={})),function(e){e.NONE="NONE",e.OCTAHEDRAL="OCTAHEDRAL",e.QUATERNION="QUATERNION",e.EXPONENTIAL="EXPONENTIAL"}(a||(a={}));const{BYTE:c,SHORT:u,FLOAT:l}=e.Accessor.ComponentType,{normalize:h,denormalize:f}=e.MathUtils;function p(t,s,r,n){const{filter:o,bits:p}=n,x={array:t.getArray(),byteStride:t.getElementSize()*t.getComponentSize(),componentType:t.getComponentType(),normalized:t.getNormalized()};if(r!==i.ATTRIBUTES)return x;if(o!==a.NONE){let e=t.getNormalized()?function(e){const t=e.getComponentType(),s=e.getArray(),r=new Float32Array(s.length);for(let e=0;e<s.length;e++)r[e]=f(s[e],t);return r}(t):new Float32Array(x.array);switch(o){case a.EXPONENTIAL:x.byteStride=4*t.getElementSize(),x.componentType=l,x.normalized=!1,x.array=s.encodeFilterExp(e,t.getCount(),x.byteStride,p);break;case a.OCTAHEDRAL:x.byteStride=p>8?8:4,x.componentType=p>8?u:c,x.normalized=!0,e=3===t.getElementSize()?function(e){const t=new Float32Array(4*e.length/3);for(let s=0,r=e.length/3;s<r;s++)t[4*s]=e[3*s],t[4*s+1]=e[3*s+1],t[4*s+2]=e[3*s+2];return t}(e):e,x.array=s.encodeFilterOct(e,t.getCount(),x.byteStride,p);break;case a.QUATERNION:x.byteStride=8,x.componentType=u,x.normalized=!0,x.array=s.encodeFilterQuat(e,t.getCount(),x.byteStride,p);break;default:throw new Error("Invalid filter.")}x.min=t.getMin([]),x.max=t.getMax([]),t.getNormalized()&&(x.min=x.min.map(e=>f(e,t.getComponentType())),x.max=x.max.map(e=>f(e,t.getComponentType()))),x.normalized&&(x.min=x.min.map(e=>h(e,x.componentType)),x.max=x.max.map(e=>h(e,x.componentType)))}else x.byteStride%4&&(x.array=function(t,s){const r=e.BufferUtils.padNumber(t.BYTES_PER_ELEMENT*s)/t.BYTES_PER_ELEMENT,n=new t.constructor(t.length/s*r);for(let e=0;e*s<t.length;e++)for(let o=0;o<s;o++)n[e*r+o]=t[e*s+o];return n}(x.array,t.getElementSize()),x.byteStride=x.array.byteLength/t.getCount());return x}function x(t,s){return s===e.WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER?t.listParents().some(t=>t instanceof e.Primitive&&t.getMode()===e.Primitive.Mode.TRIANGLES)?i.TRIANGLES:i.INDICES:i.ATTRIBUTES}function T(t,s){const r=s.getGraph().listParentEdges(t).filter(t=>!(t.getParent()instanceof e.Root));for(const e of r){const s=e.getName(),r=e.getAttributes().key||"";if("indices"===s)return{filter:a.NONE};if("attributes"===s){if("POSITION"===r)return{filter:a.NONE};if("TEXCOORD_0"===r)return{filter:a.NONE};if("NORMAL"===r)return{filter:a.OCTAHEDRAL,bits:8};if("TANGENT"===r)return{filter:a.OCTAHEDRAL,bits:8};if(r.startsWith("JOINTS_"))return{filter:a.NONE};if(r.startsWith("WEIGHTS_"))return{filter:a.NONE}}if("output"===s){const e=g(t);return"rotation"===e?{filter:a.QUATERNION,bits:16}:"translation"===e||"scale"===e?{filter:a.EXPONENTIAL,bits:12}:{filter:a.NONE}}if("input"===s)return{filter:a.NONE};if("inverseBindMatrices"===s)return{filter:a.NONE}}return{filter:a.NONE}}function g(t){for(const s of t.listParents())if(s instanceof e.AnimationSampler)for(const t of s.listParents())if(t instanceof e.AnimationChannel)return t.getTargetPath();return null}const d="EXT_meshopt_compression",m={method:o.QUANTIZE};class E extends e.Extension{constructor(...t){super(...t),this.extensionName=d,this.prereadTypes=[e.PropertyType.BUFFER,e.PropertyType.PRIMITIVE],this.prewriteTypes=[e.PropertyType.BUFFER,e.PropertyType.ACCESSOR],this.readDependencies=["meshopt.decoder"],this.writeDependencies=["meshopt.encoder"],this._decoder=null,this._decoderFallbackBufferMap=new Map,this._encoder=null,this._encoderOptions=m,this._encoderFallbackBuffer=null,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={}}install(e,t){return"meshopt.decoder"===e&&(this._decoder=t),"meshopt.encoder"===e&&(this._encoder=t),this}setEncoderOptions(e){return this._encoderOptions={...m,...e},this}preread(t,s){if(!this._decoder){if(!this.isRequired())return this;throw new Error(`[${d}] Please install extension dependency, "meshopt.decoder".`)}if(!this._decoder.supported){if(!this.isRequired())return this;throw new Error(`[${d}]: Missing WASM support.`)}return s===e.PropertyType.BUFFER?this._prereadBuffers(t):s===e.PropertyType.PRIMITIVE&&this._prereadPrimitives(t),this}_prereadBuffers(t){const s=t.jsonDoc;(s.json.bufferViews||[]).forEach((r,n)=>{if(!r.extensions||!r.extensions[d])return;const o=r.extensions[d],i=o.byteOffset||0,a=o.byteLength||0,c=o.count,u=o.byteStride,l=new Uint8Array(c*u),h=s.json.buffers[r.buffer],f=e.BufferUtils.toView(h.uri?s.resources[h.uri]:s.resources[e.GLB_BUFFER],i,a);this._decoder.decodeGltfBuffer(l,c,u,f,o.mode,o.filter),t.bufferViews[n]=l})}_prereadPrimitives(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach(s=>{var r;s.extensions&&s.extensions[d]&&(r=t.json.buffers[s.buffer]).extensions&&r.extensions.EXT_meshopt_compression&&r.extensions.EXT_meshopt_compression.fallback&&this._decoderFallbackBufferMap.set(e.buffers[s.buffer],e.buffers[s.extensions[d].buffer])})}read(t){if(!this.isRequired())return this;for(const[t,s]of this._decoderFallbackBufferMap){for(const r of t.listParents())r instanceof e.Accessor&&r.swap(t,s);t.dispose()}return this}prewrite(t,s){return s===e.PropertyType.ACCESSOR?this._prewriteAccessors(t):s===e.PropertyType.BUFFER&&this._prewriteBuffers(t),this}_prewriteAccessors(t){const s=t.jsonDoc.json,r=this._encoder,n=this._encoderOptions,i=this.document.createBuffer(),c=this.document.getRoot().listBuffers().indexOf(i);this._encoderFallbackBuffer=i,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={};for(const i of this.document.getRoot().listAccessors()){if("weights"===g(i))continue;const u=t.getAccessorUsage(i),l=x(i,u),h=n.method===o.FILTER?T(i,this.document):{filter:a.NONE},f=p(i,r,l,h),{array:m,byteStride:E}=f,y=i.getBuffer();if(!y)throw new Error(`${d}: Missing buffer for accessor.`);const I=this.document.getRoot().listBuffers().indexOf(y),R=[u,l,h.filter,E,I].join(":");let N=this._encoderBufferViews[R],A=this._encoderBufferViewData[R],C=this._encoderBufferViewAccessors[R];N&&A||(C=this._encoderBufferViewAccessors[R]=[],A=this._encoderBufferViewData[R]=[],N=this._encoderBufferViews[R]={buffer:c,target:e.WriterContext.USAGE_TO_TARGET[u],byteOffset:0,byteLength:0,byteStride:u===e.WriterContext.BufferViewUsage.ARRAY_BUFFER?E:void 0,extensions:{[d]:{buffer:I,byteOffset:0,byteLength:0,mode:l,filter:h.filter!==a.NONE?h.filter:void 0,byteStride:E,count:0}}});const _=t.createAccessorDef(i);_.componentType=f.componentType,_.normalized=f.normalized,_.byteOffset=N.byteLength,_.min&&f.min&&(_.min=f.min),_.max&&f.max&&(_.max=f.max),t.accessorIndexMap.set(i,s.accessors.length),s.accessors.push(_),C.push(_),A.push(new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),N.byteLength+=m.byteLength,N.extensions.EXT_meshopt_compression.count+=i.getCount()}}_prewriteBuffers(t){const s=this._encoder;for(const r in this._encoderBufferViews){const n=this._encoderBufferViews[r],o=this._encoderBufferViewData[r],i=this.document.getRoot().listBuffers()[n.extensions[d].buffer],a=t.otherBufferViews.get(i)||[],{count:c,byteStride:u,mode:l}=n.extensions[d],h=e.BufferUtils.concat(o),f=s.encodeGltfBuffer(h,c,u,l),p=e.BufferUtils.pad(f);n.extensions[d].byteLength=f.byteLength,o.length=0,o.push(p),a.push(p),t.otherBufferViews.set(i,a)}}write(t){let s=0;for(const r in this._encoderBufferViews){const n=this._encoderBufferViews[r],o=t.otherBufferViewsIndexMap.get(this._encoderBufferViewData[r][0]),i=this._encoderBufferViewAccessors[r];for(const e of i)e.bufferView=o;const a=t.jsonDoc.json.bufferViews[o],c=a.byteOffset||0;Object.assign(a,n),a.byteOffset=s,a.extensions[d].byteOffset=c,s+=e.BufferUtils.padNumber(n.byteLength)}const r=this._encoderFallbackBuffer,n=t.bufferIndexMap.get(r),o=t.jsonDoc.json.buffers[n];return o.byteLength=s,o.extensions={[d]:{fallback:!0}},r.dispose(),this}}E.EXTENSION_NAME=d,E.EncoderMethod=o;const y="EXT_texture_webp";class I{match(e){return e.length>=12&&87===e[8]&&69===e[9]&&66===e[10]&&80===e[11]}getSize(t){const s=e.BufferUtils.decodeText(t.slice(0,4)),r=e.BufferUtils.decodeText(t.slice(8,12));if("RIFF"!==s||"WEBP"!==r)return null;const n=new DataView(t.buffer,t.byteOffset);let o=12;for(;o<n.byteLength;){const t=e.BufferUtils.decodeText(new Uint8Array([n.getUint8(o),n.getUint8(o+1),n.getUint8(o+2),n.getUint8(o+3)])),s=n.getUint32(o+4,!0);if("VP8 "===t)return[16383&n.getInt16(o+14,!0),16383&n.getInt16(o+16,!0)];if("VP8L"===t){const e=n.getUint8(o+9),t=n.getUint8(o+10),s=n.getUint8(o+11);return[1+((63&t)<<8|e),1+((15&n.getUint8(o+12))<<10|s<<2|(192&t)>>6)]}o+=8+s+s%2}return null}getChannels(e){return 4}}class R extends e.Extension{constructor(...t){super(...t),this.extensionName=y,this.prereadTypes=[e.PropertyType.TEXTURE]}static register(){e.ImageUtils.registerFormat("image/webp",new I)}preread(e){return(e.jsonDoc.json.textures||[]).forEach(e=>{e.extensions&&e.extensions[y]&&(e.source=e.extensions[y].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/webp"===s.getMimeType()){const r=e.imageIndexMap.get(s);(t.json.textures||[]).forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[y]={source:e.source},delete e.source)})}}),this}}R.EXTENSION_NAME=y;const N="KHR_draco_mesh_compression";let A,C,_,S;function M(e,t){const s=new A.DecoderBuffer;try{if(s.Init(t,t.length),e.GetEncodedGeometryType(s)!==A.TRIANGULAR_MESH)throw new Error(`[${N}] Unknown geometry type.`);const r=new A.Mesh;if(!e.DecodeBufferToMesh(s,r).ok()||0===r.ptr)throw new Error(`[${N}] Decoding failure.`);return r}finally{A.destroy(s)}}function D(e,t){const s=3*t.num_faces();let r,n;if(t.num_points()<=65534){const o=s*Uint16Array.BYTES_PER_ELEMENT;r=A._malloc(o),e.GetTrianglesUInt16Array(t,o,r),n=new Uint16Array(A.HEAPU16.buffer,r,s).slice()}else{const o=s*Uint32Array.BYTES_PER_ELEMENT;r=A._malloc(o),e.GetTrianglesUInt32Array(t,o,r),n=new Uint32Array(A.HEAPU32.buffer,r,s).slice()}return A._free(r),n}function O(e,t,s,r){const n=_[r.componentType],o=C[r.componentType],i=s.num_components(),a=t.num_points()*i,c=a*o.BYTES_PER_ELEMENT,u=A._malloc(c);e.GetAttributeDataArrayForAllPoints(t,s,n,c,u);const l=new o(A.HEAPF32.buffer,u,a).slice();return A._free(u),l}var F,w;!function(e){e[e.EDGEBREAKER=1]="EDGEBREAKER",e[e.SEQUENTIAL=0]="SEQUENTIAL"}(F||(F={})),function(e){e.POSITION="POSITION",e.NORMAL="NORMAL",e.COLOR="COLOR",e.TEX_COORD="TEX_COORD",e.GENERIC="GENERIC"}(w||(w={}));const b={[w.POSITION]:14,[w.NORMAL]:10,[w.COLOR]:8,[w.TEX_COORD]:12,[w.GENERIC]:12},j={decodeSpeed:5,encodeSpeed:5,method:F.EDGEBREAKER,quantizationBits:b,quantizationVolume:"mesh"};function P(e,t=j){const s={...j,...t};s.quantizationBits={...b,...t.quantizationBits};const r=new S.Encoder,n=new S.MeshBuilder,o=new S.Mesh,i={},a=new S.DracoInt8Array;for(const t of e.listSemantics()){const a=e.getAttribute(t),c=v(t),u=U(n,a.getComponentType(),o,S[c],a.getCount(),a.getElementSize(),a.getArray());if(-1===u)throw new Error(`Error compressing "${t}" attribute.`);if(i[t]=u,"mesh"===s.quantizationVolume||"POSITION"!==t)r.SetAttributeQuantization(S[c],s.quantizationBits[c]);else{if("object"!=typeof s.quantizationVolume)throw new Error("Invalid quantization volume state.");{const{quantizationVolume:e}=s,t=Math.max(e.max[0]-e.min[0],e.max[1]-e.min[1],e.max[2]-e.min[2]);r.SetAttributeExplicitQuantization(S[c],s.quantizationBits[c],a.getElementSize(),e.min,t)}}}const c=e.getIndices();if(!c)throw new Error("Primitive must have indices.");n.AddFacesToMesh(o,c.getCount()/3,c.getArray()),r.SetSpeedOptions(s.encodeSpeed,s.decodeSpeed),r.SetTrackEncodedProperties(!0),s.method===F.SEQUENTIAL||e.listTargets().length>0?r.SetEncodingMethod(S.MESH_SEQUENTIAL_ENCODING):r.SetEncodingMethod(S.MESH_EDGEBREAKER_ENCODING);const u=r.EncodeMeshToDracoBuffer(o,a);if(u<=0)throw new Error("Error applying Draco compression.");const l=new Uint8Array(u);for(let e=0;e<u;++e)l[e]=a.GetValue(e);const h=e.getAttribute("POSITION").getCount(),f=r.GetNumberOfEncodedPoints(),p=3*r.GetNumberOfEncodedFaces();if(e.listTargets().length>0&&f!==h)throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');return S.destroy(a),S.destroy(o),S.destroy(n),S.destroy(r),{numVertices:f,numIndices:p,data:l,attributeIDs:i}}function v(e){return"POSITION"===e?w.POSITION:"NORMAL"===e?w.NORMAL:e.startsWith("COLOR_")?w.COLOR:e.startsWith("TEXCOORD_")?w.TEX_COORD:w.GENERIC}function U(t,s,r,n,o,i,a){switch(s){case e.Accessor.ComponentType.UNSIGNED_BYTE:return t.AddUInt8Attribute(r,n,o,i,a);case e.Accessor.ComponentType.BYTE:return t.AddInt8Attribute(r,n,o,i,a);case e.Accessor.ComponentType.UNSIGNED_SHORT:return t.AddUInt16Attribute(r,n,o,i,a);case e.Accessor.ComponentType.SHORT:return t.AddInt16Attribute(r,n,o,i,a);case e.Accessor.ComponentType.UNSIGNED_INT:return t.AddUInt32Attribute(r,n,o,i,a);case e.Accessor.ComponentType.FLOAT:return t.AddFloatAttribute(r,n,o,i,a);default:throw new Error(`Unexpected component type, "${s}".`)}}const B="KHR_draco_mesh_compression";class k extends e.Extension{constructor(...t){super(...t),this.extensionName=B,this.prereadTypes=[e.PropertyType.PRIMITIVE],this.prewriteTypes=[e.PropertyType.ACCESSOR],this.readDependencies=["draco3d.decoder"],this.writeDependencies=["draco3d.encoder"],this._decoderModule=null,this._encoderModule=null,this._encoderOptions={}}install(t,s){return"draco3d.decoder"===t&&(this._decoderModule=s,A=this._decoderModule,C={[e.Accessor.ComponentType.FLOAT]:Float32Array,[e.Accessor.ComponentType.UNSIGNED_INT]:Uint32Array,[e.Accessor.ComponentType.UNSIGNED_SHORT]:Uint16Array,[e.Accessor.ComponentType.UNSIGNED_BYTE]:Uint8Array,[e.Accessor.ComponentType.SHORT]:Int16Array,[e.Accessor.ComponentType.BYTE]:Int8Array},_={[e.Accessor.ComponentType.FLOAT]:A.DT_FLOAT32,[e.Accessor.ComponentType.UNSIGNED_INT]:A.DT_UINT32,[e.Accessor.ComponentType.UNSIGNED_SHORT]:A.DT_UINT16,[e.Accessor.ComponentType.UNSIGNED_BYTE]:A.DT_UINT8,[e.Accessor.ComponentType.SHORT]:A.DT_INT16,[e.Accessor.ComponentType.BYTE]:A.DT_INT8}),"draco3d.encoder"===t&&(this._encoderModule=s,S=this._encoderModule),this}setEncoderOptions(e){return this._encoderOptions=e,this}preread(t){if(!this._decoderModule)throw new Error(`[${B}] Please install extension dependency, "draco3d.decoder".`);const s=this.document.getLogger(),r=t.jsonDoc,n=new Map;try{const o=r.json.meshes||[];for(const i of o)for(const o of i.primitives){if(!o.extensions||!o.extensions[B])continue;const i=o.extensions[B];let[a,c]=n.get(i.bufferView)||[];if(!c||!a){const t=r.json.bufferViews[i.bufferView],o=r.json.buffers[t.buffer],u=e.BufferUtils.toView(o.uri?r.resources[o.uri]:r.resources[e.GLB_BUFFER],t.byteOffset||0,t.byteLength);a=new this._decoderModule.Decoder,c=M(a,u),n.set(i.bufferView,[a,c]),s.debug(`[${B}] Decompressed ${u.byteLength} bytes.`)}for(const e in o.attributes){const s=t.jsonDoc.json.accessors[o.attributes[e]],r=a.GetAttributeByUniqueId(c,i.attributes[e]),n=O(a,c,r,s);t.accessors[o.attributes[e]].setArray(n)}void 0!==o.indices&&t.accessors[o.indices].setArray(D(a,c))}}finally{for(const[e,t]of Array.from(n.values()))this._decoderModule.destroy(e),this._decoderModule.destroy(t)}return this}read(e){return this}prewrite(t,s){if(!this._encoderModule)throw new Error(`[${B}] Please install extension dependency, "draco3d.encoder".`);const r=this.document.getLogger();r.debug(`[${B}] Compression options: ${JSON.stringify(this._encoderOptions)}`);const n=function(t){const s=t.getLogger(),r=new Set,n=new Set;for(const o of t.getRoot().listMeshes())for(const t of o.listPrimitives())t.getIndices()?t.getMode()!==e.Primitive.Mode.TRIANGLES?(n.add(t),s.warn(`[${B}] Skipping Draco compression on non-TRIANGLES primitive.`)):r.add(t):(n.add(t),s.warn(`[${B}] Skipping Draco compression on non-indexed primitive.`));const o=t.getRoot().listAccessors(),i=new Map;for(let e=0;e<o.length;e++)i.set(o[e],e);const a=new Map,c=new Set,u=new Map;for(const e of Array.from(r)){let s=G(e,i);if(c.has(s))u.set(e,s);else{if(a.has(e.getIndices())){const s=e.getIndices(),r=s.clone();i.set(r,t.getRoot().listAccessors().length-1),e.swap(s,r)}for(const s of e.listAttributes())if(a.has(s)){const r=s.clone();i.set(r,t.getRoot().listAccessors().length-1),e.swap(s,r)}s=G(e,i),c.add(s),u.set(e,s),a.set(e.getIndices(),s);for(const t of e.listAttributes())a.set(t,s)}}for(const t of Array.from(a.keys())){const s=new Set(t.listParents().map(e=>e.propertyType));if(2!==s.size||!s.has(e.PropertyType.PRIMITIVE)||!s.has(e.PropertyType.ROOT))throw new Error(`[${B}] Compressed accessors must only be used as indices or vertex attributes.`)}for(const e of Array.from(r)){const t=u.get(e),s=e.getIndices();if(a.get(s)!==t||e.listAttributes().some(e=>a.get(e)!==t))throw new Error(`[${B}] Draco primitives must share all, or no, accessors.`)}for(const e of Array.from(n)){const t=e.getIndices();if(a.has(t)||e.listAttributes().some(e=>a.has(e)))throw new Error(`[${B}] Accessor cannot be shared by compressed and uncompressed primitives.`)}return u}(this.document),o=new Map;let i="mesh";"scene"===this._encoderOptions.quantizationVolume&&(1!==this.document.getRoot().listScenes().length?r.warn(`[${B}]: quantizationVolume=scene requires exactly 1 scene.`):i=e.bounds(this.document.getRoot().listScenes().pop()));for(const e of Array.from(n.keys())){const s=n.get(e);if(!s)throw new Error("Unexpected primitive.");if(o.has(s)){o.set(s,o.get(s));continue}const r=e.getIndices(),a=t.jsonDoc.json.accessors,c=P(e,{...this._encoderOptions,quantizationVolume:i});o.set(s,c);const u=t.createAccessorDef(r);u.count=c.numIndices,t.accessorIndexMap.set(r,a.length),a.push(u);for(const s of e.listSemantics()){const r=e.getAttribute(s),n=t.createAccessorDef(r);n.count=c.numVertices,t.accessorIndexMap.set(r,a.length),a.push(n)}const l=e.getAttribute("POSITION").getBuffer()||this.document.getRoot().listBuffers()[0];t.otherBufferViews.has(l)||t.otherBufferViews.set(l,[]),t.otherBufferViews.get(l).push(c.data)}return r.debug(`[${B}] Compressed ${n.size} primitives.`),t.extensionData[B]={primitiveHashMap:n,primitiveEncodingMap:o},this}write(e){const t=e.extensionData[B];for(const s of this.document.getRoot().listMeshes()){const r=e.jsonDoc.json.meshes[e.meshIndexMap.get(s)];for(let n=0;n<s.listPrimitives().length;n++){const o=s.listPrimitives()[n],i=r.primitives[n],a=t.primitiveHashMap.get(o);if(!a)continue;const c=t.primitiveEncodingMap.get(a);i.extensions=i.extensions||{},i.extensions[B]={bufferView:e.otherBufferViewsIndexMap.get(c.data),attributes:c.attributeIDs}}}if(!t.primitiveHashMap.size){const t=e.jsonDoc.json;t.extensionsUsed=(t.extensionsUsed||[]).filter(e=>e!==B),t.extensionsRequired=(t.extensionsRequired||[]).filter(e=>e!==B)}return this}}function G(e,t){const s=[],r=e.getIndices();s.push(t.get(r));for(const r of e.listAttributes())s.push(t.get(r));return s.sort().join("|")}k.EXTENSION_NAME=B,k.EncoderMethod=F;class H extends e.ExtensionProperty{init(){this.extensionName="KHR_lights_punctual",this.propertyType="Light",this.parentTypes=[e.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{color:[1,1,1],intensity:1,type:H.Type.POINT,range:null,innerConeAngle:0,outerConeAngle:Math.PI/4})}getColor(){return this.get("color")}setColor(e){return this.set("color",e)}getColorHex(){return e.ColorUtils.factorToHex(this.getColor())}setColorHex(t){const s=this.getColor().slice();return e.ColorUtils.hexToFactor(t,s),this.setColor(s)}getIntensity(){return this.get("intensity")}setIntensity(e){return this.set("intensity",e)}getType(){return this.get("type")}setType(e){return this.set("type",e)}getRange(){return this.get("range")}setRange(e){return this.set("range",e)}getInnerConeAngle(){return this.get("innerConeAngle")}setInnerConeAngle(e){return this.set("innerConeAngle",e)}getOuterConeAngle(){return this.get("outerConeAngle")}setOuterConeAngle(e){return this.set("outerConeAngle",e)}}H.EXTENSION_NAME="KHR_lights_punctual",H.Type={POINT:"point",SPOT:"spot",DIRECTIONAL:"directional"};const L="KHR_lights_punctual";class V extends e.Extension{constructor(...e){super(...e),this.extensionName=L}createLight(e=""){return new H(this.document.getGraph(),e)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[L])return this;const s=(t.json.extensions[L].lights||[]).map(e=>{const t=this.createLight().setName(e.name||"").setType(e.type);return void 0!==e.color&&t.setColor(e.color),void 0!==e.intensity&&t.setIntensity(e.intensity),void 0!==e.range&&t.setRange(e.range),void 0!==e.spot?.innerConeAngle&&t.setInnerConeAngle(e.spot.innerConeAngle),void 0!==e.spot?.outerConeAngle&&t.setOuterConeAngle(e.spot.outerConeAngle),t});return t.json.nodes.forEach((t,r)=>{t.extensions&&t.extensions[L]&&e.nodes[r].setExtension(L,s[t.extensions[L].light])}),this}write(t){const s=t.jsonDoc;if(0===this.properties.size)return this;const r=[],n=new Map;for(const t of this.properties){const s=t,o={type:s.getType()};e.MathUtils.eq(s.getColor(),[1,1,1])||(o.color=s.getColor()),1!==s.getIntensity()&&(o.intensity=s.getIntensity()),null!=s.getRange()&&(o.range=s.getRange()),s.getName()&&(o.name=s.getName()),s.getType()===H.Type.SPOT&&(o.spot={innerConeAngle:s.getInnerConeAngle(),outerConeAngle:s.getOuterConeAngle()}),r.push(o),n.set(s,r.length-1)}return this.document.getRoot().listNodes().forEach(e=>{const r=e.getExtension(L);if(r){const o=t.nodeIndexMap.get(e),i=s.json.nodes[o];i.extensions=i.extensions||{},i.extensions[L]={light:n.get(r)}}}),s.json.extensions=s.json.extensions||{},s.json.extensions[L]={lights:r},this}}V.EXTENSION_NAME=L;const{R:X,G:K}=e.TextureChannel;class z extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_anisotropy",this.propertyType="Anisotropy",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{anisotropy:0,anisotropyTexture:null,anisotropyTextureInfo:new e.TextureInfo(this.graph,"anisotropyTextureInfo"),anisotropyDirection:[1,0,0],anisotropyDirectionTexture:null,anisotropyDirectionTextureInfo:new e.TextureInfo(this.graph,"anisotropyDirectionTextureInfo")})}getAnisotropy(){return this.get("anisotropy")}setAnisotropy(e){return this.set("anisotropy",e)}getAnisotropyTexture(){return this.getRef("anisotropyTexture")}getAnisotropyTextureInfo(){return this.getRef("anisotropyTexture")?this.getRef("anisotropyTextureInfo"):null}setAnisotropyTexture(e){return this.setRef("anisotropyTexture",e,{channels:X})}getAnisotropyDirection(){return this.get("anisotropyDirection")}setAnisotropyDirection(e){return this.set("anisotropyDirection",e)}getAnisotropyDirectionTexture(){return this.getRef("anisotropyDirectionTexture")}getAnisotropyDirectionTextureInfo(){return this.getRef("anisotropyDirectionTexture")?this.getRef("anisotropyDirectionTextureInfo"):null}setAnisotropyDirectionTexture(e){return this.setRef("anisotropyDirectionTexture",e,{channels:K})}}z.EXTENSION_NAME="KHR_materials_anisotropy";const q="KHR_materials_anisotropy";class $ extends e.Extension{constructor(...e){super(...e),this.extensionName=q}createAnisotropy(){return new z(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[q]){const n=this.createAnisotropy();e.materials[r].setExtension(q,n);const o=t.extensions[q];if(void 0!==o.anisotropy&&n.setAnisotropy(o.anisotropy),void 0!==o.anisotropyDirection&&n.setAnisotropyDirection(o.anisotropyDirection),void 0!==o.anisotropyTexture){const t=o.anisotropyTexture;n.setAnisotropyTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getAnisotropyTextureInfo(),t)}if(void 0!==o.anisotropyDirectionTexture){const t=o.anisotropyDirectionTexture;n.setAnisotropyDirectionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getAnisotropyDirectionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(q);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[q]={anisotropy:r.getAnisotropy(),anisotropyDirection:r.getAnisotropyDirection()};if(r.getAnisotropyTexture()){const t=r.getAnisotropyTexture(),s=r.getAnisotropyTextureInfo();i.anisotropyTexture=e.createTextureInfoDef(t,s)}if(r.getAnisotropyDirectionTexture()){const t=r.getAnisotropyDirectionTexture(),s=r.getAnisotropyDirectionTextureInfo();i.anisotropyDirectionTexture=e.createTextureInfoDef(t,s)}}}),this}}$.EXTENSION_NAME=q;const{R:Q,G:Y,B:W}=e.TextureChannel;class J extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_clearcoat",this.propertyType="Clearcoat",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{clearcoatFactor:0,clearcoatTexture:null,clearcoatTextureInfo:new e.TextureInfo(this.graph,"clearcoatTextureInfo"),clearcoatRoughnessFactor:0,clearcoatRoughnessTexture:null,clearcoatRoughnessTextureInfo:new e.TextureInfo(this.graph,"clearcoatRoughnessTextureInfo"),clearcoatNormalScale:1,clearcoatNormalTexture:null,clearcoatNormalTextureInfo:new e.TextureInfo(this.graph,"clearcoatNormalTextureInfo")})}getClearcoatFactor(){return this.get("clearcoatFactor")}setClearcoatFactor(e){return this.set("clearcoatFactor",e)}getClearcoatTexture(){return this.getRef("clearcoatTexture")}getClearcoatTextureInfo(){return this.getRef("clearcoatTexture")?this.getRef("clearcoatTextureInfo"):null}setClearcoatTexture(e){return this.setRef("clearcoatTexture",e,{channels:Q})}getClearcoatRoughnessFactor(){return this.get("clearcoatRoughnessFactor")}setClearcoatRoughnessFactor(e){return this.set("clearcoatRoughnessFactor",e)}getClearcoatRoughnessTexture(){return this.getRef("clearcoatRoughnessTexture")}getClearcoatRoughnessTextureInfo(){return this.getRef("clearcoatRoughnessTexture")?this.getRef("clearcoatRoughnessTextureInfo"):null}setClearcoatRoughnessTexture(e){return this.setRef("clearcoatRoughnessTexture",e,{channels:Y})}getClearcoatNormalScale(){return this.get("clearcoatNormalScale")}setClearcoatNormalScale(e){return this.set("clearcoatNormalScale",e)}getClearcoatNormalTexture(){return this.getRef("clearcoatNormalTexture")}getClearcoatNormalTextureInfo(){return this.getRef("clearcoatNormalTexture")?this.getRef("clearcoatNormalTextureInfo"):null}setClearcoatNormalTexture(e){return this.setRef("clearcoatNormalTexture",e,{channels:Q|Y|W})}}J.EXTENSION_NAME="KHR_materials_clearcoat";const Z="KHR_materials_clearcoat";class ee extends e.Extension{constructor(...e){super(...e),this.extensionName=Z}createClearcoat(){return new J(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Z]){const n=this.createClearcoat();e.materials[r].setExtension(Z,n);const o=t.extensions[Z];if(void 0!==o.clearcoatFactor&&n.setClearcoatFactor(o.clearcoatFactor),void 0!==o.clearcoatRoughnessFactor&&n.setClearcoatRoughnessFactor(o.clearcoatRoughnessFactor),void 0!==o.clearcoatTexture){const t=o.clearcoatTexture;n.setClearcoatTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatTextureInfo(),t)}if(void 0!==o.clearcoatRoughnessTexture){const t=o.clearcoatRoughnessTexture;n.setClearcoatRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatRoughnessTextureInfo(),t)}if(void 0!==o.clearcoatNormalTexture){const t=o.clearcoatNormalTexture;n.setClearcoatNormalTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatNormalTextureInfo(),t),void 0!==t.scale&&n.setClearcoatNormalScale(t.scale)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Z);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Z]={clearcoatFactor:r.getClearcoatFactor(),clearcoatRoughnessFactor:r.getClearcoatRoughnessFactor()};if(r.getClearcoatTexture()){const t=r.getClearcoatTexture(),s=r.getClearcoatTextureInfo();i.clearcoatTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatRoughnessTexture()){const t=r.getClearcoatRoughnessTexture(),s=r.getClearcoatRoughnessTextureInfo();i.clearcoatRoughnessTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatNormalTexture()){const t=r.getClearcoatNormalTexture(),s=r.getClearcoatNormalTextureInfo();i.clearcoatNormalTexture=e.createTextureInfoDef(t,s),1!==r.getClearcoatNormalScale()&&(i.clearcoatNormalTexture.scale=r.getClearcoatNormalScale())}}}),this}}ee.EXTENSION_NAME=Z;class te extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_emissive_strength",this.propertyType="EmissiveStrength",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{emissiveStrength:1})}getEmissiveStrength(){return this.get("emissiveStrength")}setEmissiveStrength(e){return this.set("emissiveStrength",e)}}te.EXTENSION_NAME="KHR_materials_emissive_strength";const se="KHR_materials_emissive_strength";class re extends e.Extension{constructor(...e){super(...e),this.extensionName=se}createEmissiveStrength(){return new te(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[se]){const r=this.createEmissiveStrength();e.materials[s].setExtension(se,r);const n=t.extensions[se];void 0!==n.emissiveStrength&&r.setEmissiveStrength(n.emissiveStrength)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(se);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[se]={emissiveStrength:r.getEmissiveStrength()}}}),this}}re.EXTENSION_NAME=se;class ne extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_ior",this.propertyType="IOR",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{ior:0})}getIOR(){return this.get("ior")}setIOR(e){return this.set("ior",e)}}ne.EXTENSION_NAME="KHR_materials_ior";const oe="KHR_materials_ior";class ie extends e.Extension{constructor(...e){super(...e),this.extensionName=oe}createIOR(){return new ne(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[oe]){const r=this.createIOR();e.materials[s].setExtension(oe,r);const n=t.extensions[oe];void 0!==n.ior&&r.setIOR(n.ior)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(oe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[oe]={ior:r.getIOR()}}}),this}}ie.EXTENSION_NAME=oe;const{R:ae,G:ce}=e.TextureChannel;class ue extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_iridescence",this.propertyType="Iridescence",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{iridescenceFactor:0,iridescenceTexture:null,iridescenceTextureInfo:new e.TextureInfo(this.graph,"iridescenceTextureInfo"),iridescenceIOR:1.3,iridescenceThicknessMinimum:100,iridescenceThicknessMaximum:400,iridescenceThicknessTexture:null,iridescenceThicknessTextureInfo:new e.TextureInfo(this.graph,"iridescenceThicknessTextureInfo")})}getIridescenceFactor(){return this.get("iridescenceFactor")}setIridescenceFactor(e){return this.set("iridescenceFactor",e)}getIridescenceTexture(){return this.getRef("iridescenceTexture")}getIridescenceTextureInfo(){return this.getRef("iridescenceTexture")?this.getRef("iridescenceTextureInfo"):null}setIridescenceTexture(e){return this.setRef("iridescenceTexture",e,{channels:ae})}getIridescenceIOR(){return this.get("iridescenceIOR")}setIridescenceIOR(e){return this.set("iridescenceIOR",e)}getIridescenceThicknessMinimum(){return this.get("iridescenceThicknessMinimum")}setIridescenceThicknessMinimum(e){return this.set("iridescenceThicknessMinimum",e)}getIridescenceThicknessMaximum(){return this.get("iridescenceThicknessMaximum")}setIridescenceThicknessMaximum(e){return this.set("iridescenceThicknessMaximum",e)}getIridescenceThicknessTexture(){return this.getRef("iridescenceThicknessTexture")}getIridescenceThicknessTextureInfo(){return this.getRef("iridescenceThicknessTexture")?this.getRef("iridescenceThicknessTextureInfo"):null}setIridescenceThicknessTexture(e){return this.setRef("iridescenceThicknessTexture",e,{channels:ce})}}ue.EXTENSION_NAME="KHR_materials_iridescence";const le="KHR_materials_iridescence";class he extends e.Extension{constructor(...e){super(...e),this.extensionName=le}createIridescence(){return new ue(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[le]){const n=this.createIridescence();e.materials[r].setExtension(le,n);const o=t.extensions[le];if(void 0!==o.iridescenceFactor&&n.setIridescenceFactor(o.iridescenceFactor),void 0!==o.iridescenceIor&&n.setIridescenceIOR(o.iridescenceIor),void 0!==o.iridescenceThicknessMinimum&&n.setIridescenceThicknessMinimum(o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&n.setIridescenceThicknessMaximum(o.iridescenceThicknessMaximum),void 0!==o.iridescenceTexture){const t=o.iridescenceTexture;n.setIridescenceTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceTextureInfo(),t)}if(void 0!==o.iridescenceThicknessTexture){const t=o.iridescenceThicknessTexture;n.setIridescenceThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(le);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[le]={};if(r.getIridescenceFactor()>0&&(i.iridescenceFactor=r.getIridescenceFactor()),1.3!==r.getIridescenceIOR()&&(i.iridescenceIor=r.getIridescenceIOR()),100!==r.getIridescenceThicknessMinimum()&&(i.iridescenceThicknessMinimum=r.getIridescenceThicknessMinimum()),400!==r.getIridescenceThicknessMaximum()&&(i.iridescenceThicknessMaximum=r.getIridescenceThicknessMaximum()),r.getIridescenceTexture()){const t=r.getIridescenceTexture(),s=r.getIridescenceTextureInfo();i.iridescenceTexture=e.createTextureInfoDef(t,s)}if(r.getIridescenceThicknessTexture()){const t=r.getIridescenceThicknessTexture(),s=r.getIridescenceThicknessTextureInfo();i.iridescenceThicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}he.EXTENSION_NAME=le;const{R:fe,G:pe,B:xe,A:Te}=e.TextureChannel;class ge extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_pbrSpecularGlossiness",this.propertyType="PBRSpecularGlossiness",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{diffuseFactor:[1,1,1,1],diffuseTexture:null,diffuseTextureInfo:new e.TextureInfo(this.graph,"diffuseTextureInfo"),specularFactor:[1,1,1],glossinessFactor:1,specularGlossinessTexture:null,specularGlossinessTextureInfo:new e.TextureInfo(this.graph,"specularGlossinessTextureInfo")})}getDiffuseFactor(){return this.get("diffuseFactor")}setDiffuseFactor(e){return this.set("diffuseFactor",e)}getDiffuseHex(){return e.ColorUtils.factorToHex(this.getDiffuseFactor())}setDiffuseHex(t){const s=this.getDiffuseFactor().slice();return this.setDiffuseFactor(e.ColorUtils.hexToFactor(t,s))}getDiffuseTexture(){return this.getRef("diffuseTexture")}getDiffuseTextureInfo(){return this.getRef("diffuseTexture")?this.getRef("diffuseTextureInfo"):null}setDiffuseTexture(e){return this.setRef("diffuseTexture",e,{channels:fe|pe|xe|Te})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getGlossinessFactor(){return this.get("glossinessFactor")}setGlossinessFactor(e){return this.set("glossinessFactor",e)}getSpecularGlossinessTexture(){return this.getRef("specularGlossinessTexture")}getSpecularGlossinessTextureInfo(){return this.getRef("specularGlossinessTexture")?this.getRef("specularGlossinessTextureInfo"):null}setSpecularGlossinessTexture(e){return this.setRef("specularGlossinessTexture",e,{channels:fe|pe|xe|Te})}}ge.EXTENSION_NAME="KHR_materials_pbrSpecularGlossiness";const de="KHR_materials_pbrSpecularGlossiness";class me extends e.Extension{constructor(...e){super(...e),this.extensionName=de}createPBRSpecularGlossiness(){return new ge(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[de]){const n=this.createPBRSpecularGlossiness();e.materials[r].setExtension(de,n);const o=t.extensions[de];if(void 0!==o.diffuseFactor&&n.setDiffuseFactor(o.diffuseFactor),void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.glossinessFactor&&n.setGlossinessFactor(o.glossinessFactor),void 0!==o.diffuseTexture){const t=o.diffuseTexture;n.setDiffuseTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getDiffuseTextureInfo(),t)}if(void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;n.setSpecularGlossinessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularGlossinessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(de);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[de]={diffuseFactor:r.getDiffuseFactor(),specularFactor:r.getSpecularFactor(),glossinessFactor:r.getGlossinessFactor()};if(r.getDiffuseTexture()){const t=r.getDiffuseTexture(),s=r.getDiffuseTextureInfo();i.diffuseTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularGlossinessTexture()){const t=r.getSpecularGlossinessTexture(),s=r.getSpecularGlossinessTextureInfo();i.specularGlossinessTexture=e.createTextureInfoDef(t,s)}}}),this}}me.EXTENSION_NAME=de;const{R:Ee,G:ye,B:Ie,A:Re}=e.TextureChannel;class Ne extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_sheen",this.propertyType="Sheen",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{sheenColorFactor:[0,0,0],sheenColorTexture:null,sheenColorTextureInfo:new e.TextureInfo(this.graph,"sheenColorTextureInfo"),sheenRoughnessFactor:0,sheenRoughnessTexture:null,sheenRoughnessTextureInfo:new e.TextureInfo(this.graph,"sheenRoughnessTextureInfo")})}getSheenColorFactor(){return this.get("sheenColorFactor")}getSheenColorHex(){return e.ColorUtils.factorToHex(this.getSheenColorFactor())}setSheenColorFactor(e){return this.set("sheenColorFactor",e)}setSheenColorHex(t){const s=this.getSheenColorFactor().slice();return this.set("sheenColorFactor",e.ColorUtils.hexToFactor(t,s))}getSheenColorTexture(){return this.getRef("sheenColorTexture")}getSheenColorTextureInfo(){return this.getRef("sheenColorTexture")?this.getRef("sheenColorTextureInfo"):null}setSheenColorTexture(e){return this.setRef("sheenColorTexture",e,{channels:Ee|ye|Ie})}getSheenRoughnessFactor(){return this.get("sheenRoughnessFactor")}setSheenRoughnessFactor(e){return this.set("sheenRoughnessFactor",e)}getSheenRoughnessTexture(){return this.getRef("sheenRoughnessTexture")}getSheenRoughnessTextureInfo(){return this.getRef("sheenRoughnessTexture")?this.getRef("sheenRoughnessTextureInfo"):null}setSheenRoughnessTexture(e){return this.setRef("sheenRoughnessTexture",e,{channels:Re})}}Ne.EXTENSION_NAME="KHR_materials_sheen";const Ae="KHR_materials_sheen";class Ce extends e.Extension{constructor(...e){super(...e),this.extensionName=Ae}createSheen(){return new Ne(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ae]){const n=this.createSheen();e.materials[r].setExtension(Ae,n);const o=t.extensions[Ae];if(void 0!==o.sheenColorFactor&&n.setSheenColorFactor(o.sheenColorFactor),void 0!==o.sheenRoughnessFactor&&n.setSheenRoughnessFactor(o.sheenRoughnessFactor),void 0!==o.sheenColorTexture){const t=o.sheenColorTexture;n.setSheenColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenColorTextureInfo(),t)}if(void 0!==o.sheenRoughnessTexture){const t=o.sheenRoughnessTexture;n.setSheenRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenRoughnessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ae);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ae]={sheenColorFactor:r.getSheenColorFactor(),sheenRoughnessFactor:r.getSheenRoughnessFactor()};if(r.getSheenColorTexture()){const t=r.getSheenColorTexture(),s=r.getSheenColorTextureInfo();i.sheenColorTexture=e.createTextureInfoDef(t,s)}if(r.getSheenRoughnessTexture()){const t=r.getSheenRoughnessTexture(),s=r.getSheenRoughnessTextureInfo();i.sheenRoughnessTexture=e.createTextureInfoDef(t,s)}}}),this}}Ce.EXTENSION_NAME=Ae;const{R:_e,G:Se,B:Me,A:De}=e.TextureChannel;class Oe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_specular",this.propertyType="Specular",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{specularFactor:1,specularTexture:null,specularTextureInfo:new e.TextureInfo(this.graph,"specularTextureInfo"),specularColorFactor:[1,1,1],specularColorTexture:null,specularColorTextureInfo:new e.TextureInfo(this.graph,"specularColorTextureInfo")})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getSpecularColorFactor(){return this.get("specularColorFactor")}setSpecularColorFactor(e){return this.set("specularColorFactor",e)}getSpecularColorHex(){return e.ColorUtils.factorToHex(this.getSpecularColorFactor())}setSpecularColorHex(t){const s=this.getSpecularColorFactor().slice();return this.set("specularColorFactor",e.ColorUtils.hexToFactor(t,s))}getSpecularTexture(){return this.getRef("specularTexture")}getSpecularTextureInfo(){return this.getRef("specularTexture")?this.getRef("specularTextureInfo"):null}setSpecularTexture(e){return this.setRef("specularTexture",e,{channels:De})}getSpecularColorTexture(){return this.getRef("specularColorTexture")}getSpecularColorTextureInfo(){return this.getRef("specularColorTexture")?this.getRef("specularColorTextureInfo"):null}setSpecularColorTexture(e){return this.setRef("specularColorTexture",e,{channels:_e|Se|Me})}}Oe.EXTENSION_NAME="KHR_materials_specular";const Fe="KHR_materials_specular";class we extends e.Extension{constructor(...e){super(...e),this.extensionName=Fe}createSpecular(){return new Oe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Fe]){const n=this.createSpecular();e.materials[r].setExtension(Fe,n);const o=t.extensions[Fe];if(void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.specularColorFactor&&n.setSpecularColorFactor(o.specularColorFactor),void 0!==o.specularTexture){const t=o.specularTexture;n.setSpecularTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularTextureInfo(),t)}if(void 0!==o.specularColorTexture){const t=o.specularColorTexture;n.setSpecularColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularColorTextureInfo(),t)}}}),this}write(t){const s=t.jsonDoc;return this.document.getRoot().listMaterials().forEach(r=>{const n=r.getExtension(Fe);if(n){const o=t.materialIndexMap.get(r),i=s.json.materials[o];i.extensions=i.extensions||{};const a=i.extensions[Fe]={};if(1!==n.getSpecularFactor()&&(a.specularFactor=n.getSpecularFactor()),e.MathUtils.eq(n.getSpecularColorFactor(),[1,1,1])||(a.specularColorFactor=n.getSpecularColorFactor()),n.getSpecularTexture()){const e=n.getSpecularTexture(),s=n.getSpecularTextureInfo();a.specularTexture=t.createTextureInfoDef(e,s)}if(n.getSpecularColorTexture()){const e=n.getSpecularColorTexture(),s=n.getSpecularColorTextureInfo();a.specularColorTexture=t.createTextureInfoDef(e,s)}}}),this}}we.EXTENSION_NAME=Fe;const{R:be,G:je,B:Pe,A:ve}=e.TextureChannel;class Ue extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_translucency",this.propertyType="Translucency",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{translucencyFactor:1,translucencyTexture:null,translucencyTextureInfo:new e.TextureInfo(this.graph,"translucencyTextureInfo"),translucencyColorFactor:[1,1,1],translucencyColorTexture:null,translucencyColorTextureInfo:new e.TextureInfo(this.graph,"translucencyColorTextureInfo")})}getTranslucencyFactor(){return this.get("translucencyFactor")}setTranslucencyFactor(e){return this.set("translucencyFactor",e)}getTranslucencyColorFactor(){return this.get("translucencyColorFactor")}setTranslucencyColorFactor(e){return this.set("translucencyColorFactor",e)}getTranslucencyColorHex(){return e.ColorUtils.factorToHex(this.getTranslucencyColorFactor())}setTranslucencyColorHex(t){const s=this.getTranslucencyColorFactor().slice();return this.set("translucencyColorFactor",e.ColorUtils.hexToFactor(t,s))}getTranslucencyTexture(){return this.getRef("translucencyTexture")}getTranslucencyTextureInfo(){return this.getRef("translucencyTexture")?this.getRef("translucencyTextureInfo"):null}setTranslucencyTexture(e){return this.setRef("translucencyTexture",e,{channels:ve})}getTranslucencyColorTexture(){return this.getRef("translucencyColorTexture")}getTranslucencyColorTextureInfo(){return this.getRef("translucencyColorTexture")?this.getRef("translucencyColorTextureInfo"):null}setTranslucencyColorTexture(e){return this.setRef("translucencyColorTexture",e,{channels:be|je|Pe})}}Ue.EXTENSION_NAME="KHR_materials_translucency";const Be="KHR_materials_translucency";class ke extends e.Extension{constructor(...e){super(...e),this.extensionName=Be}createTranslucency(){return new Ue(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Be]){const n=this.createTranslucency();e.materials[r].setExtension(Be,n);const o=t.extensions[Be];if(void 0!==o.translucencyFactor&&n.setTranslucencyFactor(o.translucencyFactor),void 0!==o.translucencyColorFactor&&n.setTranslucencyColorFactor(o.translucencyColorFactor),void 0!==o.translucencyTexture){const t=o.translucencyTexture;n.setTranslucencyTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTranslucencyTextureInfo(),t)}if(void 0!==o.translucencyColorTexture){const t=o.translucencyColorTexture;n.setTranslucencyColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTranslucencyColorTextureInfo(),t)}}}),this}write(t){const s=t.jsonDoc;return this.document.getRoot().listMaterials().forEach(r=>{const n=r.getExtension(Be);if(n){const o=t.materialIndexMap.get(r),i=s.json.materials[o];i.extensions=i.extensions||{};const a=i.extensions[Be]={};if(1!==n.getTranslucencyFactor()&&(a.translucencyFactor=n.getTranslucencyFactor()),e.MathUtils.eq(n.getTranslucencyColorFactor(),[1,1,1])||(a.translucencyColorFactor=n.getTranslucencyColorFactor()),n.getTranslucencyTexture()){const e=n.getTranslucencyTexture(),s=n.getTranslucencyTextureInfo();a.translucencyTexture=t.createTextureInfoDef(e,s)}if(n.getTranslucencyColorTexture()){const e=n.getTranslucencyColorTexture(),s=n.getTranslucencyColorTextureInfo();a.translucencyColorTexture=t.createTextureInfoDef(e,s)}}}),this}}ke.EXTENSION_NAME=Be;const{R:Ge}=e.TextureChannel;class He extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_transmission",this.propertyType="Transmission",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{transmissionFactor:0,transmissionTexture:null,transmissionTextureInfo:new e.TextureInfo(this.graph,"transmissionTextureInfo")})}getTransmissionFactor(){return this.get("transmissionFactor")}setTransmissionFactor(e){return this.set("transmissionFactor",e)}getTransmissionTexture(){return this.getRef("transmissionTexture")}getTransmissionTextureInfo(){return this.getRef("transmissionTexture")?this.getRef("transmissionTextureInfo"):null}setTransmissionTexture(e){return this.setRef("transmissionTexture",e,{channels:Ge})}}He.EXTENSION_NAME="KHR_materials_transmission";const Le="KHR_materials_transmission";class Ve extends e.Extension{constructor(...e){super(...e),this.extensionName=Le}createTransmission(){return new He(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Le]){const n=this.createTransmission();e.materials[r].setExtension(Le,n);const o=t.extensions[Le];if(void 0!==o.transmissionFactor&&n.setTransmissionFactor(o.transmissionFactor),void 0!==o.transmissionTexture){const t=o.transmissionTexture;n.setTransmissionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTransmissionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Le);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Le]={transmissionFactor:r.getTransmissionFactor()};if(r.getTransmissionTexture()){const t=r.getTransmissionTexture(),s=r.getTransmissionTextureInfo();i.transmissionTexture=e.createTextureInfoDef(t,s)}}}),this}}Ve.EXTENSION_NAME=Le;class Xe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_unlit",this.propertyType="Unlit",this.parentTypes=[e.PropertyType.MATERIAL]}}Xe.EXTENSION_NAME="KHR_materials_unlit";const Ke="KHR_materials_unlit";class ze extends e.Extension{constructor(...e){super(...e),this.extensionName=Ke}createUnlit(){return new Xe(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{t.extensions&&t.extensions[Ke]&&e.materials[s].setExtension(Ke,this.createUnlit())}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{if(s.getExtension(Ke)){const r=e.materialIndexMap.get(s),n=t.json.materials[r];n.extensions=n.extensions||{},n.extensions[Ke]={}}}),this}}ze.EXTENSION_NAME=Ke;class qe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Mapping",this.parentTypes=["MappingList"]}getDefaults(){return Object.assign(super.getDefaults(),{material:null,variants:[]})}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}addVariant(e){return this.addRef("variants",e)}removeVariant(e){return this.removeRef("variants",e)}listVariants(){return this.listRefs("variants")}}qe.EXTENSION_NAME="KHR_materials_variants";class $e extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="MappingList",this.parentTypes=[e.PropertyType.PRIMITIVE]}getDefaults(){return Object.assign(super.getDefaults(),{mappings:[]})}addMapping(e){return this.addRef("mappings",e)}removeMapping(e){return this.removeRef("mappings",e)}listMappings(){return this.listRefs("mappings")}}$e.EXTENSION_NAME="KHR_materials_variants";class Qe extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Variant",this.parentTypes=["MappingList"]}}Qe.EXTENSION_NAME="KHR_materials_variants";const Ye="KHR_materials_variants";class We extends e.Extension{constructor(...e){super(...e),this.extensionName=Ye}createMappingList(){return new $e(this.document.getGraph())}createVariant(e=""){return new Qe(this.document.getGraph(),e)}createMapping(){return new qe(this.document.getGraph())}listVariants(){return Array.from(this.properties).filter(e=>e instanceof Qe)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[Ye])return this;const s=(t.json.extensions[Ye].variants||[]).map(e=>this.createVariant().setName(e.name||""));return(t.json.meshes||[]).forEach((t,r)=>{const n=e.meshes[r];(t.primitives||[]).forEach((t,r)=>{if(!t.extensions||!t.extensions[Ye])return;const o=this.createMappingList(),i=t.extensions[Ye];for(const t of i.mappings){const r=this.createMapping();void 0!==t.material&&r.setMaterial(e.materials[t.material]);for(const e of t.variants||[])r.addVariant(s[e]);o.addMapping(r)}n.listPrimitives()[r].setExtension(Ye,o)})}),this}write(e){const t=e.jsonDoc,s=this.listVariants();if(!s.length)return this;const r=[],n=new Map;for(const t of s)n.set(t,r.length),r.push(e.createPropertyDef(t));for(const t of this.document.getRoot().listMeshes()){const s=e.meshIndexMap.get(t);t.listPrimitives().forEach((t,r)=>{const o=t.getExtension(Ye);if(!o)return;const i=e.jsonDoc.json.meshes[s].primitives[r],a=o.listMappings().map(t=>{const s=e.createPropertyDef(t),r=t.getMaterial();return r&&(s.material=e.materialIndexMap.get(r)),s.variants=t.listVariants().map(e=>n.get(e)),s});i.extensions=i.extensions||{},i.extensions[Ye]={mappings:a}})}return t.json.extensions=t.json.extensions||{},t.json.extensions[Ye]={variants:r},this}}We.EXTENSION_NAME=Ye;const{G:Je}=e.TextureChannel;class Ze extends e.ExtensionProperty{init(){this.extensionName="KHR_materials_volume",this.propertyType="Volume",this.parentTypes=[e.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{thicknessFactor:0,thicknessTexture:null,thicknessTextureInfo:new e.TextureInfo(this.graph,"thicknessTexture"),attenuationDistance:Infinity,attenuationColor:[1,1,1]})}getThicknessFactor(){return this.get("thicknessFactor")}setThicknessFactor(e){return this.set("thicknessFactor",e)}getThicknessTexture(){return this.getRef("thicknessTexture")}getThicknessTextureInfo(){return this.getRef("thicknessTexture")?this.getRef("thicknessTextureInfo"):null}setThicknessTexture(e){return this.setRef("thicknessTexture",e,{channels:Je})}getAttenuationDistance(){return this.get("attenuationDistance")}setAttenuationDistance(e){return this.set("attenuationDistance",e)}getAttenuationColor(){return this.get("attenuationColor")}setAttenuationColor(e){return this.set("attenuationColor",e)}getAttenuationColorHex(){return e.ColorUtils.factorToHex(this.getAttenuationColor())}setAttenuationColorHex(t){const s=this.getAttenuationColor().slice();return this.set("attenuationColor",e.ColorUtils.hexToFactor(t,s))}}Ze.EXTENSION_NAME="KHR_materials_volume";const et="KHR_materials_volume";class tt extends e.Extension{constructor(...e){super(...e),this.extensionName=et}createVolume(){return new Ze(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[et]){const n=this.createVolume();e.materials[r].setExtension(et,n);const o=t.extensions[et];if(void 0!==o.thicknessFactor&&n.setThicknessFactor(o.thicknessFactor),void 0!==o.attenuationDistance&&n.setAttenuationDistance(o.attenuationDistance),void 0!==o.attenuationColor&&n.setAttenuationColor(o.attenuationColor),void 0!==o.thicknessTexture){const t=o.thicknessTexture;n.setThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getThicknessTextureInfo(),t)}}}),this}write(t){const s=t.jsonDoc;return this.document.getRoot().listMaterials().forEach(r=>{const n=r.getExtension(et);if(n){const o=t.materialIndexMap.get(r),i=s.json.materials[o];i.extensions=i.extensions||{};const a=i.extensions[et]={};if(n.getThicknessFactor()>0&&(a.thicknessFactor=n.getThicknessFactor()),Number.isFinite(n.getAttenuationDistance())&&(a.attenuationDistance=n.getAttenuationDistance()),e.MathUtils.eq(n.getAttenuationColor(),[1,1,1])||(a.attenuationColor=n.getAttenuationColor()),n.getThicknessTexture()){const e=n.getThicknessTexture(),s=n.getThicknessTextureInfo();a.thicknessTexture=t.createTextureInfoDef(e,s)}}}),this}}tt.EXTENSION_NAME=et;const st="KHR_mesh_quantization";class rt extends e.Extension{constructor(...e){super(...e),this.extensionName=st}read(e){return this}write(e){return this}}rt.EXTENSION_NAME=st;const nt="KHR_texture_basisu";class ot{match(e){return 171===e[0]&&75===e[1]&&84===e[2]&&88===e[3]&&32===e[4]&&50===e[5]&&48===e[6]&&187===e[7]&&13===e[8]&&10===e[9]&&26===e[10]&&10===e[11]}getSize(e){const s=t.read(e);return[s.pixelWidth,s.pixelHeight]}getChannels(e){const s=t.read(e).dataFormatDescriptor[0];if(s.colorModel===t.KTX2Model.ETC1S)return 2===s.samples.length&&15==(15&s.samples[1].channelID)?4:3;if(s.colorModel===t.KTX2Model.UASTC)return 3==(15&s.samples[0].channelID)?4:3;throw new Error(`Unexpected KTX2 colorModel, "${s.colorModel}".`)}getGPUByteLength(e){const s=t.read(e),r=this.getChannels(e)>3;let n=0;for(let e=0;e<s.levels.length;e++){const t=s.levels[e];n+=t.uncompressedByteLength?t.uncompressedByteLength:Math.max(1,Math.floor(s.pixelWidth/Math.pow(2,e)))/4*(Math.max(1,Math.floor(s.pixelHeight/Math.pow(2,e)))/4)*(r?16:8)}return n}}class it extends e.Extension{constructor(...t){super(...t),this.extensionName=nt,this.prereadTypes=[e.PropertyType.TEXTURE]}static register(){e.ImageUtils.registerFormat("image/ktx2",new ot)}preread(e){return e.jsonDoc.json.textures.forEach(e=>{e.extensions&&e.extensions[nt]&&(e.source=e.extensions[nt].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/ktx2"===s.getMimeType()){const r=e.imageIndexMap.get(s);t.json.textures.forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[nt]={source:e.source},delete e.source)})}}),this}}it.EXTENSION_NAME=nt;class at extends e.ExtensionProperty{init(){this.extensionName="KHR_texture_transform",this.propertyType="Transform",this.parentTypes=[e.PropertyType.TEXTURE_INFO]}getDefaults(){return Object.assign(super.getDefaults(),{offset:[0,0],rotation:0,scale:[1,1],texCoord:null})}getOffset(){return this.get("offset")}setOffset(e){return this.set("offset",e)}getRotation(){return this.get("rotation")}setRotation(e){return this.set("rotation",e)}getScale(){return this.get("scale")}setScale(e){return this.set("scale",e)}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}}at.EXTENSION_NAME="KHR_texture_transform";const ct="KHR_texture_transform";class ut extends e.Extension{constructor(...e){super(...e),this.extensionName=ct}createTransform(){return new at(this.document.getGraph())}read(e){for(const[t,s]of Array.from(e.textureInfos.entries())){if(!s.extensions||!s.extensions[ct])continue;const e=this.createTransform(),r=s.extensions[ct];void 0!==r.offset&&e.setOffset(r.offset),void 0!==r.rotation&&e.setRotation(r.rotation),void 0!==r.scale&&e.setScale(r.scale),void 0!==r.texCoord&&e.setTexCoord(r.texCoord),t.setExtension(ct,e)}return this}write(t){const s=Array.from(t.textureInfoDefMap.entries());for(const[t,r]of s){const s=t.getExtension(ct);if(!s)continue;r.extensions=r.extensions||{};const n={},o=e.MathUtils.eq;o(s.getOffset(),[0,0])||(n.offset=s.getOffset()),0!==s.getRotation()&&(n.rotation=s.getRotation()),o(s.getScale(),[1,1])||(n.scale=s.getScale()),null!=s.getTexCoord()&&(n.texCoord=s.getTexCoord()),r.extensions[ct]=n}return this}}ut.EXTENSION_NAME=ct;const lt=[e.PropertyType.ROOT,e.PropertyType.SCENE,e.PropertyType.NODE,e.PropertyType.MESH,e.PropertyType.MATERIAL,e.PropertyType.TEXTURE,e.PropertyType.ANIMATION];class ht extends e.ExtensionProperty{init(){this.extensionName="KHR_xmp_json_ld",this.propertyType="Packet",this.parentTypes=lt}getDefaults(){return Object.assign(super.getDefaults(),{context:{},properties:{}})}getContext(){return this.get("context")}setContext(e){return this.set("context",{...e})}listProperties(){return Object.keys(this.get("properties"))}getProperty(e){const t=this.get("properties");return e in t?t[e]:null}setProperty(e,t){this._assertContext(e);const s={...this.get("properties")};return t?s[e]=t:delete s[e],this.set("properties",s)}toJSONLD(){return{"@context":ft(this.get("context")),...ft(this.get("properties"))}}fromJSONLD(e){const t=(e=ft(e))["@context"];return t&&this.set("context",t),delete e["@context"],this.set("properties",e)}_assertContext(e){if(!(e.split(":")[0]in this.get("context")))throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)}}function ft(e){return JSON.parse(JSON.stringify(e))}ht.EXTENSION_NAME="KHR_xmp_json_ld";const pt="KHR_xmp_json_ld";class xt extends e.Extension{constructor(...e){super(...e),this.extensionName=pt}createPacket(){return new ht(this.document.getGraph())}listPackets(){return Array.from(this.properties)}read(e){const t=e.jsonDoc.json.extensions?.[pt];if(!t||!t.packets)return this;const s=e.jsonDoc.json,r=this.document.getRoot(),n=t.packets.map(e=>this.createPacket().fromJSONLD(e)),o=[[s.asset],s.scenes,s.nodes,s.meshes,s.materials,s.images,s.animations],i=[[r],r.listScenes(),r.listNodes(),r.listMeshes(),r.listMaterials(),r.listTextures(),r.listAnimations()];for(let e=0;e<o.length;e++){const t=o[e]||[];for(let s=0;s<t.length;s++){const r=t[s];r.extensions&&r.extensions[pt]&&i[e][s].setExtension(pt,n[r.extensions[pt].packet])}}return this}write(t){const{json:s}=t.jsonDoc,r=[];for(const n of this.properties){r.push(n.toJSONLD());for(const o of n.listParents()){let n;switch(o.propertyType){case e.PropertyType.ROOT:n=s.asset;break;case e.PropertyType.SCENE:n=s.scenes[t.sceneIndexMap.get(o)];break;case e.PropertyType.NODE:n=s.nodes[t.nodeIndexMap.get(o)];break;case e.PropertyType.MESH:n=s.meshes[t.meshIndexMap.get(o)];break;case e.PropertyType.MATERIAL:n=s.materials[t.materialIndexMap.get(o)];break;case e.PropertyType.TEXTURE:n=s.images[t.imageIndexMap.get(o)];break;case e.PropertyType.ANIMATION:n=s.animations[t.animationIndexMap.get(o)];break;default:n=null,this.document.getLogger().warn(`[${pt}]: Unsupported parent property, "${o.propertyType}"`)}n&&(n.extensions=n.extensions||{},n.extensions[pt]={packet:r.length-1})}}return r.length>0&&(s.extensions=s.extensions||{},s.extensions[pt]={packets:r}),this}}xt.EXTENSION_NAME=pt;const Tt=[k,V,$,ee,re,ie,he,me,we,Ce,ke,Ve,ze,We,tt,rt,it,ut,xt],gt=[n,E,R,...Tt];exports.ALL_EXTENSIONS=gt,exports.Anisotropy=z,exports.Clearcoat=J,exports.DracoMeshCompression=k,exports.EmissiveStrength=te,exports.INSTANCE_ATTRIBUTE="INSTANCE_ATTRIBUTE",exports.IOR=ne,exports.InstancedMesh=s,exports.Iridescence=ue,exports.KHRONOS_EXTENSIONS=Tt,exports.Light=H,exports.LightsPunctual=V,exports.Mapping=qe,exports.MappingList=$e,exports.MaterialsAnisotropy=$,exports.MaterialsClearcoat=ee,exports.MaterialsEmissiveStrength=re,exports.MaterialsIOR=ie,exports.MaterialsIridescence=he,exports.MaterialsPBRSpecularGlossiness=me,exports.MaterialsSheen=Ce,exports.MaterialsSpecular=we,exports.MaterialsTranslucency=ke,exports.MaterialsTransmission=Ve,exports.MaterialsUnlit=ze,exports.MaterialsVariants=We,exports.MaterialsVolume=tt,exports.MeshGPUInstancing=n,exports.MeshQuantization=rt,exports.MeshoptCompression=E,exports.PBRSpecularGlossiness=ge,exports.Packet=ht,exports.Sheen=Ne,exports.Specular=Oe,exports.TextureBasisu=it,exports.TextureTransform=ut,exports.TextureWebP=R,exports.Transform=at,exports.Translucency=Ue,exports.Transmission=He,exports.Unlit=Xe,exports.Variant=Qe,exports.Volume=Ze,exports.XMP=xt;
 //# sourceMappingURL=extensions.js.map
diff --git a/dist/extensions.js.map b/dist/extensions.js.map
index f4e9ce7be1eb4e6210e8c4b8a9db151734a23a13..f08f5abcb0604310bfd8d164e5c3777cfe2509ab 100644
--- a/dist/extensions.js.map
+++ b/dist/extensions.js.map
@@ -1 +1 @@
-{"version":3,"file":"extensions.js","sources":["../src/ext-mesh-gpu-instancing/instanced-mesh.ts","../src/constants.ts","../src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts","../src/ext-meshopt-compression/constants.ts","../src/ext-meshopt-compression/encoder.ts","../src/ext-meshopt-compression/meshopt-compression.ts","../src/ext-meshopt-compression/decoder.ts","../src/ext-texture-webp/texture-webp.ts","../src/khr-draco-mesh-compression/decoder.ts","../src/khr-draco-mesh-compression/encoder.ts","../src/khr-draco-mesh-compression/draco-mesh-compression.ts","../src/khr-lights-punctual/light.ts","../src/khr-lights-punctual/lights-punctual.ts","../src/khr-materials-clearcoat/clearcoat.ts","../src/khr-materials-clearcoat/materials-clearcoat.ts","../src/khr-materials-emissive-strength/emissive-strength.ts","../src/khr-materials-emissive-strength/materials-emissive-strength.ts","../src/khr-materials-ior/ior.ts","../src/khr-materials-ior/materials-ior.ts","../src/khr-materials-iridescence/iridescence.ts","../src/khr-materials-iridescence/materials-iridescence.ts","../src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts","../src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts","../src/khr-materials-sheen/sheen.ts","../src/khr-materials-sheen/materials-sheen.ts","../src/khr-materials-specular/specular.ts","../src/khr-materials-specular/materials-specular.ts","../src/khr-materials-transmission/transmission.ts","../src/khr-materials-transmission/materials-transmission.ts","../src/khr-materials-unlit/unlit.ts","../src/khr-materials-unlit/materials-unlit.ts","../src/khr-materials-variants/mapping.ts","../src/khr-materials-variants/mapping-list.ts","../src/khr-materials-variants/variant.ts","../src/khr-materials-variants/materials-variants.ts","../src/khr-materials-volume/volume.ts","../src/khr-materials-volume/materials-volume.ts","../src/khr-mesh-quantization/mesh-quantization.ts","../src/khr-texture-basisu/texture-basisu.ts","../src/khr-texture-transform/transform.ts","../src/khr-texture-transform/texture-transform.ts","../src/khr-xmp-json-ld/packet.ts","../src/khr-xmp-json-ld/xmp.ts","../src/extensions.ts"],"sourcesContent":["import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\n\ninterface IInstancedMesh extends IProperty {\n\tattributes: { [key: string]: Accessor };\n}\n\n// See BufferViewUsage in `writer-context.ts`.\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\n\n/**\n * # InstancedMesh\n *\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link MeshGPUInstancing}.\n */\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\n\tpublic declare propertyType: 'InstancedMesh';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\n\t\tthis.propertyType = 'InstancedMesh';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: {} });\n\t}\n\n\t/** Returns an instance attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\n\t * instance count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\n\t}\n\n\t/**\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\n\t * will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n","export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\nexport const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';\n","import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh';\n\nconst NAME = EXT_MESH_GPU_INSTANCING;\n\ninterface InstancedMeshDef {\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\n/**\n * # MeshGPUInstancing\n *\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\n * prepares mesh data for efficient GPU instancing.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\n * batch.\n *\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\n * > is important to note that (1) GPU instancing and other optimizations are possible  and\n * > encouraged  even without this extension, and (2) other common meanings of the term\n * > \"instancing\" exist, distinct from this extension. See\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\n * > of the `EXT_mesh_gpu_instancing` specification._\n *\n * Properties:\n * - {@link InstancedMesh}\n *\n * ### Example\n *\n * The `MeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\n * which may be attached to any {@link Node} instance. For example:\n *\n * ```typescript\n * import { MeshGPUInstancing } from '@gltf-transform/extensions';\n *\n * // Create standard mesh, node, and scene hierarchy.\n * // ...\n *\n * // Assign positions for each instance.\n * const batchPositions = doc.createAccessor('instance_positions')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0,\n * \t\t1, 0, 0,\n * \t\t2, 0, 0,\n * \t]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(buffer);\n *\n * // Assign IDs for each instance.\n * const batchIDs = doc.createAccessor('instance_ids')\n * \t.setArray(new Uint8Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR)\n * \t.setBuffer(buffer);\n *\n * // Create an Extension attached to the Document.\n * const batchExtension = document.createExtension(MeshGPUInstancing)\n * \t.setRequired(true);\n * const batch = batchExtension.createInstancedMesh()\n * \t.setAttribute('TRANSLATION', batchPositions)\n * \t.setAttribute('_ID', batchIDs);\n *\n * node\n * \t.setMesh(mesh)\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\n * ```\n *\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\n * be prefixed with an underscore (`_*`).\n */\nexport class MeshGPUInstancing extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly provideTypes = [PropertyType.NODE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\n\tpublic createInstancedMesh(): InstancedMesh {\n\t\treturn new InstancedMesh(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\n\t\t\tconst instancedMesh = this.createInstancedMesh();\n\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\n\t\t\t}\n\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\n\t\t// views grouped by parent reference.\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\n\t\tfor (const prop of this.properties) {\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\n\t\t\t\tif (instancedMesh) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\n\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\n\t\t\t\t\t});\n\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import type { GLTF, TypedArray } from '@gltf-transform/core';\n\nexport enum EncoderMethod {\n\tQUANTIZE = 'quantize',\n\tFILTER = 'filter',\n}\n\nexport interface MeshoptBufferExtension {\n\tfallback?: boolean;\n}\n\nexport enum MeshoptMode {\n\tATTRIBUTES = 'ATTRIBUTES',\n\tTRIANGLES = 'TRIANGLES',\n\tINDICES = 'INDICES',\n}\n\nexport enum MeshoptFilter {\n\tNONE = 'NONE',\n\tOCTAHEDRAL = 'OCTAHEDRAL',\n\tQUATERNION = 'QUATERNION',\n\tEXPONENTIAL = 'EXPONENTIAL',\n}\n\nexport interface MeshoptBufferViewExtension {\n\tbuffer: number;\n\tbyteOffset: number;\n\tbyteLength: number;\n\tbyteStride: number;\n\tcount: number;\n\tmode: MeshoptMode;\n\tfilter?: MeshoptFilter;\n}\n\n/**\n * When using filters, the accessor definition written to the file will not necessarily have the\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\n * output, so float32 input must be ignored.\n */\nexport interface PreparedAccessor {\n\tarray: TypedArray;\n\tbyteStride: number;\n\tnormalized: boolean;\n\tcomponentType: GLTF.AccessorComponentType;\n\tmin?: number[];\n\tmax?: number[];\n}\n","import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants';\nimport {\n\tAccessor,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBufferUtils,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPrimitive,\n\tRoot,\n\tTypedArray,\n\tTypedArrayConstructor,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\nconst { normalize, denormalize } = MathUtils;\n\n/** Pre-processes array with required filters or padding. */\nexport function prepareAccessor(\n\taccessor: Accessor,\n\tencoder: typeof MeshoptEncoder,\n\tmode: MeshoptMode,\n\tfilterOptions: { filter: MeshoptFilter; bits?: number }\n): PreparedAccessor {\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\n\tconst result: PreparedAccessor = {\n\t\tarray: accessor.getArray()!,\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\n\t\tcomponentType: accessor.getComponentType(),\n\t\tnormalized: accessor.getNormalized(),\n\t};\n\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\n\n\tif (filter !== MeshoptFilter.NONE) {\n\t\tlet array = accessor.getNormalized() ? denormalizeArray(accessor) : new Float32Array(result.array);\n\n\t\tswitch (filter) {\n\t\t\tcase MeshoptFilter.EXPONENTIAL: //  K single-precision floating point values.\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\n\t\t\t\tresult.componentType = FLOAT;\n\t\t\t\tresult.normalized = false;\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: //  four 8- or 16-bit normalized values.\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.QUATERNION: //  four 16-bit normalized values.\n\t\t\t\tresult.byteStride = 8;\n\t\t\t\tresult.componentType = SHORT;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid filter.');\n\t\t}\n\n\t\tresult.min = accessor.getMin([]);\n\t\tresult.max = accessor.getMax([]);\n\t\tif (accessor.getNormalized()) {\n\t\t\tresult.min = result.min.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t\tresult.max = result.max.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t}\n\t\tif (result.normalized) {\n\t\t\tresult.min = result.min.map((v) => normalize(v, result.componentType));\n\t\t\tresult.max = result.max.map((v) => normalize(v, result.componentType));\n\t\t}\n\t} else if (result.byteStride % 4) {\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\n\t}\n\n\treturn result;\n}\n\nfunction denormalizeArray(attribute: Accessor): Float32Array {\n\tconst componentType = attribute.getComponentType();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\tfor (let i = 0; i < srcArray.length; i++) {\n\t\tdstArray[i] = denormalize(srcArray[i], componentType);\n\t}\n\treturn dstArray;\n}\n\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\n\tconst elementCount = srcArray.length / elementSize;\n\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\n\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n\n/** Pad normals with a .w component for octahedral encoding. */\nfunction padNormals(srcArray: Float32Array): Float32Array {\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\n\t\tdstArray[i * 4] = srcArray[i * 3];\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\n\t}\n\treturn dstArray;\n}\n\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\n\t\t});\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\n\t}\n\n\treturn MeshoptMode.ATTRIBUTES;\n}\n\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\n\tconst refs = doc\n\t\t.getGraph()\n\t\t.listParentEdges(accessor)\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\n\n\tfor (const ref of refs) {\n\t\tconst refName = ref.getName();\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\n\n\t\t// Indices.\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\n\n\t\t// Attributes.\n\t\t//\n\t\t// NOTES:\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\n\t\t//   quantization for these attributes.\n\t\tif (refName === 'attributes') {\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'NORMAL') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey === 'TANGENT') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// Animation.\n\t\tif (refName === 'output') {\n\t\t\tconst targetPath = getTargetPath(accessor);\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\treturn { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/489\n\t\tif (refName === 'input') return { filter: MeshoptFilter.NONE };\n\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\n\t}\n\n\treturn { filter: MeshoptFilter.NONE };\n}\n\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\n\tfor (const sampler of accessor.listParents()) {\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\n\t\tfor (const channel of sampler.listParents()) {\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\n\t\t\treturn channel.getTargetPath();\n\t\t}\n\t}\n\treturn null;\n}\n","import {\n\tAccessor,\n\tBuffer,\n\tBufferUtils,\n\tExtension,\n\tGLB_BUFFER,\n\tGLTF,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants';\nimport { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder';\nimport { isFallbackBuffer } from './decoder';\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\n\nconst NAME = EXT_MESHOPT_COMPRESSION;\n\ninterface EncoderOptions {\n\tmethod?: EncoderMethod;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\n\tmethod: EncoderMethod.QUANTIZE,\n};\n\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\n\n/**\n * # MeshoptCompression\n *\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)\n * provides compression and fast decoding for geometry, morph targets, and animations.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\n * library) offers a lightweight decoder with very fast runtime decompression, and is\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\n * large, other complementary compression methods should be used as well.\n *\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\n * pre-optimizes assets for this purpose  without this secondary compression, the size\n * reduction is considerably less.\n *\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\n * considerably faster than Draco decoding, neither compression method will improve runtime\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\n * vertex count or draw calls  not just compress it. Finally, be aware that Meshopt compression is\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\n * writing files, and must be provided by the application. Compression may alternatively be applied\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { MeshoptCompression } from '@gltf-transform/extensions';\n * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';\n *\n * await MeshoptDecoder.ready;\n * await MeshoptEncoder.ready;\n *\n * const io = new NodeIO()\n *\t.registerExtensions([MeshoptCompression])\n *\t.registerDependencies({\n *\t\t'meshopt.decoder': MeshoptDecoder,\n *\t\t'meshopt.encoder': MeshoptEncoder,\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode. (Medium, -c)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize()\n * );\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.QUANTIZE });\n * await io.write('compressed-medium.glb', document);\n *\n * // Write and encode. (High, -cc)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\n * );\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.FILTER });\n * await io.write('compressed-high.glb', document);\n * ```\n */\nexport class MeshoptCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['meshopt.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'meshopt.decoder') {\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\n\t\t}\n\t\tif (key === 'meshopt.encoder') {\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\n\t *\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\n\t * \t`gltfpack -cc`.\n\t *\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\n\t * with both methods.\n\t *\n\t * Example:\n\t *\n\t * ```ts\n\t * doc.createExtension(MeshoptCompression)\n\t * \t.setRequired(true)\n\t * \t.setEncoderOptions({\n\t * \t\tmethod: MeshoptCompression.EncoderMethod.QUANTIZE\n\t * \t});\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Decoding.\n\t */\n\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\n\t\tif (!this._decoder) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\n\t\t}\n\t\tif (!this._decoder.supported) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\n\t\t}\n\n\t\tif (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prereadBuffers(context);\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\n\t\t\tthis._prereadPrimitives(context);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @internal Decode buffer views. */\n\tprivate _prereadBuffers(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\t\tviewDefs.forEach((viewDef, index) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\n\t\t\tconst count = meshoptDef.count;\n\t\t\tconst stride = meshoptDef.byteStride;\n\t\t\tconst result = new Uint8Array(count * stride);\n\n\t\t\tconst bufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\n\n\t\t\tcontext.bufferViews[index] = result;\n\t\t});\n\t}\n\n\t/**\n\t * Mark fallback buffers and replacements.\n\t *\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\n\t * after Buffers have been parsed.\n\t * @internal\n\t */\n\tprivate _prereadPrimitives(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\n\t\t//\n\t\tviewDefs.forEach((viewDef) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @hidden Removes Fallback buffers, if extension is required. */\n\tpublic read(_context: ReaderContext): this {\n\t\tif (!this.isRequired()) return this;\n\n\t\t// Replace fallback buffers.\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\n\t\t\t\tif (parent instanceof Accessor) {\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallbackBuffer.dispose();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Encoding.\n\t */\n\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\n\t\tif (propertyType === PropertyType.ACCESSOR) {\n\t\t\tthis._prewriteAccessors(context);\n\t\t} else if (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prewriteBuffers(context);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @internal Claims accessors that can be compressed. */\n\tprivate _prewriteAccessors(context: WriterContext): void {\n\t\tconst json = context.jsonDoc.json;\n\t\tconst encoder = this._encoder!;\n\t\tconst options = this._encoderOptions;\n\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\n\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\n\t\tthis._encoderBufferViews = {};\n\t\tthis._encoderBufferViewData = {};\n\t\tthis._encoderBufferViewAccessors = {};\n\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\n\t\t\t// Example: https://skfb.ly/6qAD8\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\n\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\n\t\t\tconst filter =\n\t\t\t\toptions.method === EncoderMethod.FILTER\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\n\t\t\tconst { array, byteStride } = preparedAccessor;\n\n\t\t\tconst buffer = accessor.getBuffer();\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\n\n\t\t\t// Buffer view grouping key.\n\t\t\tconst key = [usage, mode, filter.filter, byteStride, bufferIndex].join(':');\n\n\t\t\tlet bufferView = this._encoderBufferViews[key];\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\n\t\t\t// Write new buffer view, if needed.\n\t\t\tif (!bufferView || !bufferViewData) {\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\n\t\t\t\t\tbuffer: fallbackBufferIndex,\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\n\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\n\t\t\t\t\textensions: {\n\t\t\t\t\t\t[NAME]: {\n\t\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\n\t\t\t\t\t\t\tbyteStride: byteStride,\n\t\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Write accessor.\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\tjson.accessors!.push(accessorDef);\n\t\t\tbufferViewAccessors.push(accessorDef);\n\n\t\t\t// Update buffer view.\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n\t\t\tbufferView.byteLength += array.byteLength;\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\n\t\t}\n\t}\n\n\t/** @internal Writes compressed buffer views. */\n\tprivate _prewriteBuffers(context: WriterContext): void {\n\t\tconst encoder = this._encoder!;\n\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\n\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\n\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\n\n\t\t\tbufferViewData.length = 0;\n\t\t\tbufferViewData.push(compressedData);\n\t\t\totherBufferViews.push(compressedData);\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\n\t\t}\n\t}\n\n\t/** @hidden Puts encoded data into glTF output. */\n\tpublic write(context: WriterContext): this {\n\t\tlet fallbackBufferByteOffset = 0;\n\n\t\t// Write final encoded buffer view properties.\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\n\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\n\t\t\t}\n\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\n\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\n\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\n\t\t}\n\n\t\t// Write final fallback buffer.\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\n\t\tfallbackBuffer.dispose();\n\n\t\treturn this;\n\t}\n}\n","import { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport type { GLTF } from '@gltf-transform/core';\nimport type { MeshoptBufferExtension } from './constants';\n\n/**\n * Returns true for a fallback buffer, else false.\n *\n *   - All references to the fallback buffer must come from bufferViews that\n *     have a EXT_meshopt_compression extension specified.\n *   - No references to the fallback buffer may come from\n *     EXT_meshopt_compression extension JSON.\n */\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\n\treturn !!fallbackDef.fallback;\n}\n","import {\n\tBufferUtils,\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { EXT_TEXTURE_WEBP } from '../constants';\n\nconst NAME = EXT_TEXTURE_WEBP;\n\nclass WEBPImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\n\t}\n\tgetSize(array: Uint8Array): vec2 | null {\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\n\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\n\t\tlet offset = 12;\n\t\twhile (offset < view.byteLength) {\n\t\t\tconst chunkId = BufferUtils.decodeText(\n\t\t\t\tnew Uint8Array([\n\t\t\t\t\tview.getUint8(offset),\n\t\t\t\t\tview.getUint8(offset + 1),\n\t\t\t\t\tview.getUint8(offset + 2),\n\t\t\t\t\tview.getUint8(offset + 3),\n\t\t\t\t])\n\t\t\t);\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\n\t\t\tif (chunkId === 'VP8 ') {\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\n\t\t\t\treturn [width, height];\n\t\t\t} else if (chunkId === 'VP8L') {\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\n\t\t\t\treturn [width, height];\n\t\t\t}\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\n\t\t}\n\n\t\treturn null;\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * # TextureWebP\n *\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\n * enables WebP images for any material texture.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * WebP typically provides the minimal transmission\n * size, but [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\n * like Basis Universal, with the `KHR_texture_basisu` extension.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureWebP } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const webpExtension = document.createExtension(TextureWebP)\n * \t.setRequired(true);\n * document.createTexture('MyWebPTexture')\n * \t.setMimeType('image/webp')\n * \t.setImage(fs.readFileSync('my-texture.webp'));\n * ```\n *\n * WebP conversion is not done automatically when adding the extension as shown above  you must\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\n *\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\n * JPEG image data.\n */\nexport class TextureWebP extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\n\t\ttextureDefs.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\nexport let decoderModule: DecoderModule;\n\n// Initialized when decoder module loads.\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\nlet DATA_TYPE: { [key: number]: DataType };\n\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\n\tconst buffer = new decoderModule.DecoderBuffer();\n\ttry {\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\n\t\t}\n\n\t\tconst dracoMesh = new decoderModule.Mesh();\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\n\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\n\t\t}\n\n\t\treturn dracoMesh;\n\t} finally {\n\t\tdecoderModule.destroy(buffer);\n\t}\n}\n\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\n\tconst numFaces = mesh.num_faces();\n\tconst numIndices = numFaces * 3;\n\n\tlet ptr: number;\n\tlet indices: Uint16Array | Uint32Array;\n\n\tif (mesh.num_points() <= 65534) {\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t} else {\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t}\n\n\tdecoderModule._free(ptr);\n\n\treturn indices;\n}\n\nexport function decodeAttribute(\n\tdecoder: Decoder,\n\tmesh: Mesh,\n\tattribute: Attribute,\n\taccessorDef: GLTF.IAccessor\n): TypedArray {\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\n\tconst numComponents = attribute.num_components();\n\tconst numPoints = mesh.num_points();\n\tconst numValues = numPoints * numComponents;\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\n\n\tconst ptr = decoderModule._malloc(byteLength);\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\tdecoderModule._free(ptr);\n\n\treturn array;\n}\n\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\n\tdecoderModule = _decoderModule;\n\n\tCOMPONENT_ARRAY = {\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\n\t};\n\n\tDATA_TYPE = {\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\n\t};\n}\n","import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\n\nexport let encoderModule: EncoderModule;\n\nexport enum EncoderMethod {\n\tEDGEBREAKER = 1,\n\tSEQUENTIAL = 0,\n}\n\nenum AttributeEnum {\n\tPOSITION = 'POSITION',\n\tNORMAL = 'NORMAL',\n\tCOLOR = 'COLOR',\n\tTEX_COORD = 'TEX_COORD',\n\tGENERIC = 'GENERIC',\n}\n\nconst DEFAULT_QUANTIZATION_BITS = {\n\t[AttributeEnum.POSITION]: 14,\n\t[AttributeEnum.NORMAL]: 10,\n\t[AttributeEnum.COLOR]: 8,\n\t[AttributeEnum.TEX_COORD]: 12,\n\t[AttributeEnum.GENERIC]: 12,\n};\n\nexport interface EncodedPrimitive {\n\tnumVertices: number;\n\tnumIndices: number;\n\tdata: Uint8Array;\n\tattributeIDs: { [key: string]: number };\n}\n\nexport interface EncoderOptions {\n\tdecodeSpeed?: number;\n\tencodeSpeed?: number;\n\tmethod?: EncoderMethod;\n\tquantizationBits?: { [key: string]: number };\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\n\tdecodeSpeed: 5,\n\tencodeSpeed: 5,\n\tmethod: EncoderMethod.EDGEBREAKER,\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\n\tquantizationVolume: 'mesh',\n};\n\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\n\tencoderModule = _encoderModule;\n}\n\n/**\n * References:\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\n */\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\n\n\tconst encoder = new encoderModule.Encoder();\n\tconst builder = new encoderModule.MeshBuilder();\n\tconst mesh = new encoderModule.Mesh();\n\n\tconst attributeIDs: { [key: string]: number } = {};\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tconst attributeEnum = getAttributeEnum(semantic);\n\t\tconst attributeID: number = addAttribute(\n\t\t\tbuilder,\n\t\t\tattribute.getComponentType(),\n\t\t\tmesh,\n\t\t\tencoderModule[attributeEnum],\n\t\t\tattribute.getCount(),\n\t\t\tattribute.getElementSize(),\n\t\t\tattribute.getArray()!\n\t\t);\n\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\n\n\t\tattributeIDs[semantic] = attributeID;\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\n\t\t\tencoder.SetAttributeQuantization(encoderModule[attributeEnum], options.quantizationBits[attributeEnum]);\n\t\t} else if (typeof options.quantizationVolume === 'object') {\n\t\t\tconst { quantizationVolume } = options;\n\t\t\tconst range = Math.max(\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2]\n\t\t\t);\n\t\t\tencoder.SetAttributeExplicitQuantization(\n\t\t\t\tencoderModule[attributeEnum],\n\t\t\t\toptions.quantizationBits[attributeEnum],\n\t\t\t\tattribute.getElementSize(),\n\t\t\t\tquantizationVolume.min,\n\t\t\t\trange\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error('Invalid quantization volume state.');\n\t\t}\n\t}\n\n\tconst indices = prim.getIndices();\n\tif (!indices) throw new Error('Primitive must have indices.');\n\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\n\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n\tencoder.SetTrackEncodedProperties(true);\n\n\t// Preserve vertex order for primitives with morph targets.\n\tif (options.method === EncoderMethod.SEQUENTIAL || prim.listTargets().length > 0) {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n\t} else {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n\t}\n\n\tconst byteLength = encoder.EncodeMeshToDracoBuffer(mesh, dracoBuffer);\n\tif (byteLength <= 0) throw new Error('Error applying Draco compression.');\n\n\tconst data = new Uint8Array(byteLength);\n\tfor (let i = 0; i < byteLength; ++i) {\n\t\tdata[i] = dracoBuffer.GetValue(i);\n\t}\n\n\tconst prevNumVertices = prim.getAttribute('POSITION')!.getCount();\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\n\n\tif (prim.listTargets().length > 0 && numVertices !== prevNumVertices) {\n\t\tthrow new Error(\n\t\t\t'Compression reduced vertex count unexpectedly, corrupting morph targets.' +\n\t\t\t\t' Applying the \"weld\" function before compression may resolve the issue.'\n\t\t);\n\t}\n\n\tencoderModule.destroy(dracoBuffer);\n\tencoderModule.destroy(mesh);\n\tencoderModule.destroy(builder);\n\tencoderModule.destroy(encoder);\n\n\treturn { numVertices, numIndices, data, attributeIDs };\n}\n\nfunction getAttributeEnum(semantic: string): AttributeEnum {\n\tif (semantic === 'POSITION') {\n\t\treturn AttributeEnum.POSITION;\n\t} else if (semantic === 'NORMAL') {\n\t\treturn AttributeEnum.NORMAL;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\treturn AttributeEnum.COLOR;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\treturn AttributeEnum.TEX_COORD;\n\t}\n\treturn AttributeEnum.GENERIC;\n}\n\nfunction addAttribute(\n\tbuilder: MeshBuilder,\n\tcomponentType: GLTF.AccessorComponentType,\n\tmesh: Mesh,\n\tattribute: number,\n\tcount: number,\n\titemSize: number,\n\tarray: TypedArray\n): number {\n\tswitch (componentType) {\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.BYTE:\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.SHORT:\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\n\t\tdefault:\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\n\t}\n}\n","import {\n\tAccessor,\n\tbbox,\n\tbounds,\n\tBufferUtils,\n\tDocument,\n\tExtension,\n\tGLB_BUFFER,\n\tPrimitive,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder';\nimport { EncodedPrimitive, encodeGeometry, EncoderMethod, EncoderOptions, initEncoderModule } from './encoder';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\ninterface DracoPrimitiveExtension {\n\tbufferView: number;\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\ninterface DracoWriterContext {\n\tprimitiveHashMap: Map<Primitive, string>;\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\n}\n\n/**\n * # DracoMeshCompression\n *\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\n * provides advanced compression for mesh geometry.\n *\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\n * in many cases. When animation or textures are large, other complementary compression methods\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\n * size savings.\n *\n * Be aware that decompression happens before uploading to the GPU  this will add some latency to\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\n * or draw calls  not just compress it. Finally, be aware that Draco compression is lossy:\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\n * and must be provided by the application.\n *\n * ### Encoding options\n *\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\n * edgebreaker method will give higher compression in general, but changes the\n * order of the model's vertices. To preserve index order, use sequential\n * compression. When a mesh uses morph targets, or a high decoding speed is\n * selected, sequential compression will automatically be chosen.\n *\n * Both speed options affect the encoder's choice of algorithms. For example, a\n * requirement for fast decoding may prevent the encoder from using the best\n * compression methods even if the encoding speed is set to 0. In general, the\n * faster of the two options limits the choice of features that can be used by the\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\n * the encoder to choose the optimal method out of the available features for the\n * given --decodeSpeed.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { DracoMeshCompression } from '@gltf-transform/extensions';\n *\n * import draco3d from 'draco3dgltf';\n *\n * // ...\n *\n * const io = new NodeIO()\n *\t.registerExtensions([DracoMeshCompression])\n *\t.registerDependencies({\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode.\n * document.createExtension(DracoMeshCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({\n * \t\tmethod: DracoMeshCompression.EncoderMethod.EDGEBREAKER,\n * \t\tencodeSpeed: 5,\n * \t\tdecodeSpeed: 5,\n * \t});\n * await io.write('compressed.glb', document);\n * ```\n */\nexport class DracoMeshCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['draco3d.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/**\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\n\t */\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoderModule: DecoderModule | null = null;\n\tprivate _encoderModule: EncoderModule | null = null;\n\tprivate _encoderOptions: EncoderOptions = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'draco3d.decoder') {\n\t\t\tthis._decoderModule = dependency as DecoderModule;\n\t\t\tinitDecoderModule(this._decoderModule);\n\t\t}\n\t\tif (key === 'draco3d.encoder') {\n\t\t\tthis._encoderModule = dependency as EncoderModule;\n\t\t\tinitEncoderModule(this._encoderModule);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets Draco compression options. Compression does not take effect until the Document is\n\t * written with an I/O class.\n\t *\n\t * Defaults:\n\t * ```\n\t * decodeSpeed?: number = 5;\n\t * encodeSpeed?: number = 5;\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = options;\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tif (!this._decoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\n\n\t\ttry {\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\t\tfor (const meshDef of meshDefs) {\n\t\t\t\tfor (const primDef of meshDef.primitives) {\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\n\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\n\n\t\t\t\t\tif (!dracoMesh || !decoder) {\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\t\t\t\tconst resource = bufferDef.uri\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\n\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attributes.\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\n\t\t\t\t\tif (primDef.indices !== undefined) {\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\n\t\t\t\tthis._decoderModule.destroy(decoder);\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\n\t\tif (!this._encoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\n\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\n\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\n\t\t\t} else {\n\t\t\t\tquantizationVolume = bounds(this.document.getRoot().listScenes().pop()!);\n\t\t\t}\n\t\t}\n\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\n\t\t\tconst primHash = primitiveHashMap.get(prim);\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\n\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\n\n\t\t\t// Create a new EncodedPrimitive.\n\t\t\tconst encodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\n\n\t\t\t// Create indices definition, update count.\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\n\t\t\tindicesDef.count = encodedPrim.numIndices;\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\n\t\t\taccessorDefs.push(indicesDef);\n\n\t\t\t// Create attribute definitions, update count.\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\n\t\t\t\taccessorDefs.push(attributeDef);\n\t\t\t}\n\n\t\t\t// Map compressed buffer view to a Buffer.\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\n\t\t}\n\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\n\n\t\tcontext.extensionData[NAME] = {\n\t\t\tprimitiveHashMap,\n\t\t\tprimitiveEncodingMap,\n\t\t} as DracoWriterContext;\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\n\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\n\t\t\t\tconst primDef = meshDef.primitives[i];\n\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\n\t\t\t\tif (!primHash) continue;\n\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = {\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Omit the extension if nothing was compressed.\n\t\tif (!dracoContext.primitiveHashMap.size) {\n\t\t\tconst json = context.jsonDoc.json;\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\n * fail, and would break assumptions required for compression, this function will throw an error.\n */\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\n\tconst logger = doc.getLogger();\n\tconst included = new Set<Primitive>();\n\tconst excluded = new Set<Primitive>();\n\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tif (!prim.getIndices()) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-indexed primitive.`);\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-TRIANGLES primitive.`);\n\t\t\t} else {\n\t\t\t\tincluded.add(prim);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create an Accessor->index mapping.\n\tconst accessors = doc.getRoot().listAccessors();\n\tconst accessorIndices = new Map<Accessor, number>();\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\n\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\n\t// compressed Primitive and Accessor to this hash key.\n\tconst includedAccessors = new Map<Accessor, string>();\n\tconst includedHashKeys = new Set<string>();\n\tconst primToHashKey = new Map<Primitive, string>();\n\tfor (const prim of Array.from(included)) {\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\n\n\t\t// If accessors of an identical primitive have already been checked, we're done.\n\t\tif (includedHashKeys.has(hashKey)) {\n\t\t\tprimToHashKey.set(prim, hashKey);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\t\tconst dstIndices = indices.clone();\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\n\t\t}\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tif (includedAccessors.has(attribute)) {\n\t\t\t\tconst dstAttribute = attribute.clone();\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\n\t\t\t}\n\t\t}\n\n\t\t// With conflicts resolved, compute the hash key again.\n\t\thashKey = createHashKey(prim, accessorIndices);\n\n\t\t// Commit the primitive and its accessors to the hash key.\n\t\tincludedHashKeys.add(hashKey);\n\t\tprimToHashKey.set(prim, hashKey);\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tincludedAccessors.set(attribute, hashKey);\n\t\t}\n\t}\n\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\n\t\t}\n\t}\n\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\n\tfor (const prim of Array.from(included)) {\n\t\tconst hashKey = primToHashKey.get(prim);\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\n\t\t) {\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\n\t\t}\n\t}\n\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\n\tfor (const prim of Array.from(excluded)) {\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\n\t\t}\n\t}\n\n\treturn primToHashKey;\n}\n\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\n\tconst hashElements = [];\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\n\thashElements.push(indexMap.get(indices));\n\tfor (const attribute of prim.listAttributes()) {\n\t\thashElements.push(indexMap.get(attribute));\n\t}\n\n\treturn hashElements.sort().join('|');\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\nimport { ColorUtils } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\n\ninterface ILight extends IProperty {\n\tcolor: vec3;\n\tintensity: number;\n\ttype: PunctualLightType;\n\trange: number | null;\n\tinnerConeAngle: number;\n\touterConeAngle: number;\n}\n\ntype PunctualLightType = 'point' | 'spot' | 'directional';\n\n/**\n * # Light\n *\n * Defines a light attached to a {@link Node}. See {@link LightsPunctual}.\n */\nexport class Light extends ExtensionProperty<ILight> {\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\n\tpublic declare propertyType: 'Light';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\t/**********************************************************************************************\n\t * CONSTANTS.\n\t */\n\n\tpublic static Type: Record<string, PunctualLightType> = {\n\t\tPOINT: 'point',\n\t\tSPOT: 'spot',\n\t\tDIRECTIONAL: 'directional',\n\t};\n\n\t/**********************************************************************************************\n\t * INSTANCE.\n\t */\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\n\t\tthis.propertyType = 'Light';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<ILight> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tcolor: [1, 1, 1] as vec3,\n\t\t\tintensity: 1,\n\t\t\ttype: Light.Type.POINT,\n\t\t\trange: null,\n\t\t\tinnerConeAngle: 0,\n\t\t\touterConeAngle: Math.PI / 4,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * COLOR.\n\t */\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic getColor(): vec3 {\n\t\treturn this.get('color');\n\t}\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic setColor(color: vec3): this {\n\t\treturn this.set('color', color);\n\t}\n\n\t/** Light color; sRGB hexadecimal color. */\n\tpublic getColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getColor());\n\t}\n\n\t/** Light color; sRGB hexadecimal color. */\n\tpublic setColorHex(hex: number): this {\n\t\tconst color = this.getColor().slice() as vec3;\n\t\tColorUtils.hexToFactor(hex, color);\n\t\treturn this.setColor(color);\n\t}\n\n\t/**********************************************************************************************\n\t * INTENSITY.\n\t */\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic getIntensity(): number {\n\t\treturn this.get('intensity');\n\t}\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic setIntensity(intensity: number): this {\n\t\treturn this.set('intensity', intensity);\n\t}\n\n\t/**********************************************************************************************\n\t * TYPE.\n\t */\n\n\t/** Type. */\n\tpublic getType(): PunctualLightType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Type. */\n\tpublic setType(type: PunctualLightType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**********************************************************************************************\n\t * RANGE.\n\t */\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic getRange(): number | null {\n\t\treturn this.get('range');\n\t}\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic setRange(range: number | null): this {\n\t\treturn this.set('range', range);\n\t}\n\n\t/**********************************************************************************************\n\t * SPOT LIGHT PROPERTIES\n\t */\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\n\t * < outerConeAngle.\n\t */\n\tpublic getInnerConeAngle(): number {\n\t\treturn this.get('innerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\n\t * < outerConeAngle.\n\t */\n\tpublic setInnerConeAngle(angle: number): this {\n\t\treturn this.set('innerConeAngle', angle);\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t *  PI / 2.0.\n\t */\n\tpublic getOuterConeAngle(): number {\n\t\treturn this.get('outerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t *  PI / 2.0.\n\t */\n\tpublic setOuterConeAngle(angle: number): this {\n\t\treturn this.set('outerConeAngle', angle);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\nimport { Light } from './light';\n\nconst NAME = KHR_LIGHTS_PUNCTUAL;\n\ninterface LightsPunctualRootDef {\n\tlights?: LightDef[];\n}\n\ninterface LightsPunctualNodeDef {\n\tlight: number;\n}\n\ninterface LightDef {\n\tname?: string;\n\tcolor?: vec3;\n\tintensity?: number;\n\trange?: number;\n\ttype: 'spot' | 'point' | 'directional';\n\tspot?: {\n\t\tinnerConeAngle?: number;\n\t\touterConeAngle?: number;\n\t};\n}\n\n/**\n * # LightsPunctual\n *\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\n * spot.\n *\n * Punctual lights are parameterized, infinitely small points that emit light in\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\n * of that node.\n *\n * Properties:\n * - {@link Light}\n *\n * ### Example\n *\n * ```typescript\n * import { LightsPunctual, Light, LightType } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const lightsExtension = document.createExtension(LightsPunctual);\n *\n * // Create a Light property.\n * const light = lightsExtension.createLight()\n *\t.setType(LightType.POINT)\n *\t.setIntensity(2.0)\n *\t.setColor([1.0, 0.0, 0.0]);\n *\n * // Attach the property to a Material.\n * node.setExtension('KHR_lights_punctual', light);\n * ```\n */\nexport class LightsPunctual extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\n\tpublic createLight(name = ''): Light {\n\t\treturn new Light(this.document.getGraph(), name);\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\n\t\tconst lights = lightDefs.map((lightDef) => {\n\t\t\tconst light = this.createLight()\n\t\t\t\t.setName(lightDef.name || '')\n\t\t\t\t.setType(lightDef.type);\n\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\n\n\t\t\tif (lightDef.spot?.innerConeAngle !== undefined) {\n\t\t\t\tlight.setInnerConeAngle(lightDef.spot.innerConeAngle);\n\t\t\t}\n\t\t\tif (lightDef.spot?.outerConeAngle !== undefined) {\n\t\t\t\tlight.setOuterConeAngle(lightDef.spot.outerConeAngle);\n\t\t\t}\n\n\t\t\treturn light;\n\t\t});\n\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (this.properties.size === 0) return this;\n\n\t\tconst lightDefs = [];\n\t\tconst lightIndexMap = new Map<Light, number>();\n\n\t\tfor (const property of this.properties) {\n\t\t\tconst light = property as Light;\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\n\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\n\n\t\t\tif (light.getName()) lightDef.name = light.getName();\n\n\t\t\tif (light.getType() === Light.Type.SPOT) {\n\t\t\t\tlightDef.spot = {\n\t\t\t\t\tinnerConeAngle: light.getInnerConeAngle(),\n\t\t\t\t\touterConeAngle: light.getOuterConeAngle(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlightDefs.push(lightDef);\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\n\t\t}\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\n\t\t\t\tif (light) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\n\t\t\t\t}\n\t\t\t});\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\n\ninterface IClearcoat extends IProperty {\n\tclearcoatFactor: number;\n\tclearcoatTexture: Texture;\n\tclearcoatTextureInfo: TextureInfo;\n\n\tclearcoatRoughnessFactor: number;\n\tclearcoatRoughnessTexture: Texture;\n\tclearcoatRoughnessTextureInfo: TextureInfo;\n\n\tclearcoatNormalScale: number;\n\tclearcoatNormalTexture: Texture;\n\tclearcoatNormalTextureInfo: TextureInfo;\n}\n\nconst { R, G, B } = TextureChannel;\n\n/**\n * # Clearcoat\n *\n * Defines clear coat for a PBR material. See {@link MaterialsClearcoat}.\n */\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\n\tpublic declare propertyType: 'Clearcoat';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\n\t\tthis.propertyType = 'Clearcoat';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IClearcoat> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tclearcoatFactor: 0,\n\t\t\tclearcoatTexture: null,\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\n\n\t\t\tclearcoatRoughnessFactor: 0,\n\t\t\tclearcoatRoughnessTexture: null,\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\n\n\t\t\tclearcoatNormalScale: 1,\n\t\t\tclearcoatNormalTexture: null,\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat.\n\t */\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic getClearcoatFactor(): number {\n\t\treturn this.get('clearcoatFactor');\n\t}\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatFactor(factor: number): this {\n\t\treturn this.set('clearcoatFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\n\t * normal map properties.\n\t */\n\tpublic getClearcoatTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat texture. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat roughness.\n\t */\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic getClearcoatRoughnessFactor(): number {\n\t\treturn this.get('clearcoatRoughnessFactor');\n\t}\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat roughness texture. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat normals.\n\t */\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic getClearcoatNormalScale(): number {\n\t\treturn this.get('clearcoatNormalScale');\n\t}\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalScale(scale: number): this {\n\t\treturn this.set('clearcoatNormalScale', scale);\n\t}\n\n\t/**\n\t * Clearcoat normal map. Independent of the material base layer normal map.\n\t */\n\tpublic getClearcoatNormalTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatNormalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat normal texture. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\nimport { Clearcoat } from './clearcoat';\n\nconst NAME = KHR_MATERIALS_CLEARCOAT;\n\ninterface ClearcoatDef {\n\tclearcoatFactor?: number;\n\tclearcoatRoughnessFactor?: number;\n\tclearcoatTexture?: GLTF.ITextureInfo;\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\n}\n\n/**\n * # MaterialsClearcoat\n *\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)\n * defines a clear coating on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\n *\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\n *\n * A clear coat is a common technique used in Physically-Based\n * Rendering for a protective layer applied to a base material.\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\n *\n * Properties:\n * - {@link Clearcoat}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const clearcoatExtension = document.createExtension(MaterialsClearcoat);\n *\n * // Create Clearcoat property.\n * const clearcoat = clearcoatExtension.createClearcoat()\n *\t.setClearcoatFactor(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\n * ```\n */\nexport class MaterialsClearcoat extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\n\tpublic createClearcoat(): Clearcoat {\n\t\treturn new Clearcoat(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst clearcoat = this.createClearcoat();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\n\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\n\t\t\t\tif (clearcoat) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\n\t\t\t\t\t} as ClearcoatDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\n\ninterface IEmissiveStrength extends IProperty {\n\temissiveStrength: number;\n}\n\n/**\n * # EmissiveStrength\n *\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\n * (HDR) emissive materials. See {@link MaterialsEmissiveStrength}.\n */\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare propertyType: 'EmissiveStrength';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\t\tthis.propertyType = 'EmissiveStrength';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\n\t}\n\n\t/**********************************************************************************************\n\t * EmissiveStrength.\n\t */\n\n\t/** EmissiveStrength. */\n\tpublic getEmissiveStrength(): number {\n\t\treturn this.get('emissiveStrength');\n\t}\n\n\t/** EmissiveStrength. */\n\tpublic setEmissiveStrength(strength: number): this {\n\t\treturn this.set('emissiveStrength', strength);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\nimport { EmissiveStrength } from './emissive-strength';\n\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\ninterface EmissiveStrengthDef {\n\temissiveStrength?: number;\n}\n\n/**\n * # MaterialsEmissiveStrength\n *\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\n *\n * [[include:UNRATIFIED_EXTENSIONS_NOTE.md]]\n *\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\n *\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\n * given arbitrarily high values.\n *\n * For implementations where a physical light unit is needed, the units for the multiplicative\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\n * emissive factor of 1.0 results in a fully exposed pixel.\n *\n * Properties:\n * - {@link EmissiveStrength}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const emissiveStrengthExtension = document.createExtension(MaterialsEmissiveStrength);\n *\n * // Create EmissiveStrength property.\n * const emissiveStrength = emissiveStrengthExtension\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\n * ```\n */\nexport class MaterialsEmissiveStrength extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\n\tpublic createEmissiveStrength(): EmissiveStrength {\n\t\treturn new EmissiveStrength(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\n\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\n\t\t\t\tif (emissiveStrength) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\n\t\t\t\t\t} as EmissiveStrengthDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\n\ninterface IIOR extends IProperty {\n\tior: number;\n}\n\n/**\n * # IOR\n *\n * Defines index of refraction for a PBR {@link Material}. See {@link MaterialsIOR}.\n */\nexport class IOR extends ExtensionProperty<IIOR> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\n\tpublic declare propertyType: 'IOR';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\n\t\tthis.propertyType = 'IOR';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIOR> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 0 });\n\t}\n\n\t/**********************************************************************************************\n\t * IOR.\n\t */\n\n\t/** IOR. */\n\tpublic getIOR(): number {\n\t\treturn this.get('ior');\n\t}\n\n\t/** IOR. */\n\tpublic setIOR(ior: number): this {\n\t\treturn this.set('ior', ior);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\nimport { IOR } from './ior';\n\nconst NAME = KHR_MATERIALS_IOR;\n\ninterface IORDef {\n\tior?: number;\n}\n\n/**\n * # MaterialsIOR\n *\n * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)\n * defines index of refraction on a glTF PBR material.\n *\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\n * refraction to a certain value.\n *\n * Properties:\n * - {@link IOR}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsIOR, IOR } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iorExtension = document.createExtension(MaterialsIOR);\n *\n * // Create IOR property.\n * const ior = iorExtension.createIOR().setIOR(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_ior', ior);\n * ```\n */\nexport class MaterialsIOR extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new IOR property for use on a {@link Material}. */\n\tpublic createIOR(): IOR {\n\t\treturn new IOR(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst ior = this.createIOR();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\n\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iorDef.ior !== undefined) {\n\t\t\t\t\tior.setIOR(iorDef.ior);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\n\t\t\t\tif (ior) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\tior: ior.getIOR(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\n\ninterface IIridescence extends IProperty {\n\tiridescenceFactor: number;\n\tiridescenceTexture: Texture;\n\tiridescenceTextureInfo: TextureInfo;\n\tiridescenceIOR: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: Texture;\n\tiridescenceThicknessTextureInfo: TextureInfo;\n}\n\nconst { R, G } = TextureChannel;\n\n/**\n * # Iridescence\n *\n * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link MaterialsIridescence}.\n */\nexport class Iridescence extends ExtensionProperty<IIridescence> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare propertyType: 'Iridescence';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IRIDESCENCE;\n\t\tthis.propertyType = 'Iridescence';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIridescence> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tiridescenceFactor: 0.0,\n\t\t\tiridescenceTexture: null,\n\t\t\tiridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),\n\t\t\tiridescenceIOR: 1.3,\n\t\t\tiridescenceThicknessMinimum: 100,\n\t\t\tiridescenceThicknessMaximum: 400,\n\t\t\tiridescenceThicknessTexture: null,\n\t\t\tiridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence.\n\t */\n\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\n\tpublic getIridescenceFactor(): number {\n\t\treturn this.get('iridescenceFactor');\n\t}\n\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\n\tpublic setIridescenceFactor(factor: number): this {\n\t\treturn this.set('iridescenceFactor', factor);\n\t}\n\n\t/**\n\t * Iridescence intensity.\n\t *\n\t * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\n\t * be packed with additional data in the other channels.\n\t */\n\tpublic getIridescenceTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;\n\t}\n\n\t/** Iridescence intensity. See {@link getIridescenceTexture}. */\n\tpublic setIridescenceTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence IOR.\n\t */\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic getIridescenceIOR(): number {\n\t\treturn this.get('iridescenceIOR');\n\t}\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic setIridescenceIOR(ior: number): this {\n\t\treturn this.set('iridescenceIOR', ior);\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence thickness.\n\t */\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMinimum(): number {\n\t\treturn this.get('iridescenceThicknessMinimum');\n\t}\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMinimum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMinimum', thickness);\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMaximum(): number {\n\t\treturn this.get('iridescenceThicknessMaximum');\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMaximum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMaximum', thickness);\n\t}\n\n\t/**\n\t * The green channel of this texture defines the thickness of the\n\t * thin-film layer by blending between the minimum and maximum thickness.\n\t */\n\tpublic getIridescenceThicknessTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceThicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence thickness texture.\n\t * If no texture is attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;\n\t}\n\n\t/** Sets iridescence thickness texture. See {@link getIridescenceThicknessTexture}. */\n\tpublic setIridescenceThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceThicknessTexture', texture, { channels: G });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\nimport { Iridescence } from './iridescence';\n\nconst NAME = KHR_MATERIALS_IRIDESCENCE;\n\ninterface IridescenceDef {\n\tiridescenceFactor: number;\n\tiridescenceTexture: GLTF.ITextureInfo;\n\tiridescenceIOR: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsIridescence\n *\n * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)\n * defines iridescence (thin film interference) on a PBR material.\n *\n * Iridescence describes an effect where hue varies depending on the viewing\n * angle and illumination angle: A thin-film of a semi-transparent layer\n * results in inter-reflections and due to thin-film interference, certain\n * wavelengths get absorbed or amplified. Iridescence can be seen on soap\n * bubbles, oil films, or on the wings of many insects. With this extension,\n * thickness and index of refraction (IOR) of the thin-film can be specified,\n * enabling iridescent materials.\n *\n * Properties:\n * - {@link Iridescence}\n *\n * ### Example\n *\n * The `MaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsIridescence, Iridescence } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iridescenceExtension = document.createExtension(MaterialsIridescence);\n *\n * // Create an Iridescence property.\n * const iridescence = iridescenceExtension.createIridescence()\n * \t.setIridescenceFactor(1.0)\n * \t.setIridescenceIOR(1.8);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_iridescence', iridescence);\n * ```\n */\nexport class MaterialsIridescence extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Iridescence property for use on a {@link Material}. */\n\tpublic createIridescence(): Iridescence {\n\t\treturn new Iridescence(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst iridescence = this.createIridescence();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, iridescence);\n\n\t\t\t\tconst iridescenceDef = materialDef.extensions[NAME] as IridescenceDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iridescenceDef.iridescenceFactor !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceIOR !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceIOR(iridescenceDef.iridescenceIOR);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMinimum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMaximum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (iridescenceDef.iridescenceTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst iridescence = material.getExtension<Iridescence>(NAME);\n\t\t\t\tif (iridescence) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst iridescenceDef = (materialDef.extensions[NAME] = {} as IridescenceDef);\n\n\t\t\t\t\tif (iridescence.getIridescenceFactor() > 0) {\n\t\t\t\t\t\tiridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceIOR() !== 1.3) {\n\t\t\t\t\t\tiridescenceDef.iridescenceIOR = iridescence.getIridescenceIOR();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMinimum() !== 100) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMaximum() !== 400) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (iridescence.getIridescenceTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceThicknessTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\n\ninterface IPBRSpecularGlossiness extends IProperty {\n\tdiffuseFactor: vec4;\n\tdiffuseTexture: Texture;\n\tdiffuseTextureInfo: TextureInfo;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tspecularGlossinessTexture: Texture;\n\tspecularGlossinessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # PBRSpecularGlossiness\n *\n * Converts a {@link Material} to a spec/gloss workflow. See {@link MaterialsPBRSpecularGlossiness}.\n */\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\n\t\t\tdiffuseTexture: null,\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tglossinessFactor: 1.0,\n\t\t\tspecularGlossinessTexture: null,\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse.\n\t */\n\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\n\tpublic getDiffuseFactor(): vec4 {\n\t\treturn this.get('diffuseFactor');\n\t}\n\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseFactor(factor: vec4): this {\n\t\treturn this.set('diffuseFactor', factor);\n\t}\n\n\t/** Diffuse; sRGB hexadecimal color. */\n\tpublic getDiffuseHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getDiffuseFactor());\n\t}\n\n\t/** Diffuse; sRGB hexadecimal color. */\n\tpublic setDiffuseHex(hex: number): this {\n\t\tconst factor = this.getDiffuseFactor().slice() as vec4;\n\t\treturn this.setDiffuseFactor(ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\n\t * spec/gloss PBR workflow.\n\t */\n\tpublic getDiffuseTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\n\t}\n\n\t/** Sets diffuse texture. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A });\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. */\n\tpublic getSpecularFactor(): vec3 {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. */\n\tpublic setSpecularFactor(factor: vec3): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Glossiness.\n\t */\n\n\t/** Glossiness; linear multiplier. */\n\tpublic getGlossinessFactor(): number {\n\t\treturn this.get('glossinessFactor');\n\t}\n\n\t/** Glossiness; linear multiplier. */\n\tpublic setGlossinessFactor(factor: number): this {\n\t\treturn this.set('glossinessFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Specular/Glossiness.\n\t */\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic getSpecularGlossinessTexture(): Texture | null {\n\t\treturn this.getRef('specularGlossinessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\n\t}\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness';\n\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\ninterface SpecularGlossinessDef {\n\tdiffuseFactor?: vec4;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tdiffuseTexture?: GLTF.ITextureInfo;\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsPBRSpecularGlossiness\n *\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\n *\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\n * > {@link MaterialsSpecular} extension instead, which provides specular data within a metal/rough\n * > workflow._\n *\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\n *\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\n *\n * Properties:\n * - {@link PBRSpecularGlossiness}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specGlossExtension = document.createExtension(MaterialsPBRSpecularGlossiness);\n *\n * // Create a PBRSpecularGlossiness property.\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\n * \t.setSpecularFactor(1.0);\n *\n * // // Assign to a Material.\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\n * ```\n */\nexport class MaterialsPBRSpecularGlossiness extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\n\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\n\t\t\t\tif (specGloss) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\n\t\t\t\t\t} as SpecularGlossinessDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\n\ninterface ISheen extends IProperty {\n\tsheenColorFactor: vec3;\n\tsheenColorTexture: Texture;\n\tsheenColorTextureInfo: TextureInfo;\n\tsheenRoughnessFactor: number;\n\tsheenRoughnessTexture: Texture;\n\tsheenRoughnessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Sheen\n *\n * Defines sheen on a PBR {@link Material}. See {@link MaterialsSheen}.\n */\nexport class Sheen extends ExtensionProperty<ISheen> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\n\tpublic declare propertyType: 'Sheen';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\n\t\tthis.propertyType = 'Sheen';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISheen> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\n\t\t\tsheenColorTexture: null,\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\n\t\t\tsheenRoughnessFactor: 0.0,\n\t\t\tsheenRoughnessTexture: null,\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen color.\n\t */\n\n\t/** Sheen; linear multiplier. */\n\tpublic getSheenColorFactor(): vec3 {\n\t\treturn this.get('sheenColorFactor');\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic getSheenColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSheenColorFactor());\n\t}\n\n\t/** Sheen; linear multiplier. */\n\tpublic setSheenColorFactor(factor: vec3): this {\n\t\treturn this.set('sheenColorFactor', factor);\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic setSheenColorHex(hex: number): this {\n\t\tconst factor = this.getSheenColorFactor().slice() as vec3;\n\t\treturn this.set('sheenColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Sheen color texture, in sRGB colorspace.\n\t */\n\tpublic getSheenColorTexture(): Texture | null {\n\t\treturn this.getRef('sheenColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\n\t}\n\n\t/** Sets sheen color texture. See {@link getSheenColorTexture}. */\n\tpublic setSheenColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen roughness.\n\t */\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic getSheenRoughnessFactor(): number {\n\t\treturn this.get('sheenRoughnessFactor');\n\t}\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic setSheenRoughnessFactor(factor: number): this {\n\t\treturn this.set('sheenRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getSheenRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('sheenRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\nimport { Sheen } from './sheen';\n\nconst NAME = KHR_MATERIALS_SHEEN;\n\ninterface SheenDef {\n\tsheenColorFactor?: vec3;\n\tsheenRoughnessFactor?: number;\n\tsheenColorTexture?: GLTF.ITextureInfo;\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSheen\n *\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\n * defines a velvet-like sheen layered on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\n *\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\n * > Group._\n *\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\n * cloth and fabric materials.\n *\n * Properties:\n * - {@link Sheen}\n *\n * ### Example\n *\n * The `MaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSheen, Sheen } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const sheenExtension = document.createExtension(MaterialsSheen);\n *\n * // Create a Sheen property.\n * const sheen = sheenExtension.createSheen()\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_sheen', sheen);\n * ```\n */\nexport class MaterialsSheen extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Sheen property for use on a {@link Material}. */\n\tpublic createSheen(): Sheen {\n\t\treturn new Sheen(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst sheen = this.createSheen();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\n\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\n\t\t\t\tif (sheen) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\n\t\t\t\t\t} as SheenDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\n\ninterface ISpecular extends IProperty {\n\tspecularFactor: number;\n\tspecularTexture: Texture;\n\tspecularTextureInfo: TextureInfo;\n\tspecularColorFactor: vec3;\n\tspecularColorTexture: Texture;\n\tspecularColorTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Specular\n *\n * Defines specular reflectivity on a PBR {@link Material}. See {@link MaterialsSpecular}.\n */\nexport class Specular extends ExtensionProperty<ISpecular> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\n\tpublic declare propertyType: 'Specular';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\n\t\tthis.propertyType = 'Specular';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISpecular> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tspecularFactor: 1.0,\n\t\t\tspecularTexture: null,\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tspecularColorTexture: null,\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic getSpecularFactor(): number {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic setSpecularFactor(factor: number): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\n\tpublic getSpecularColorFactor(): vec3 {\n\t\treturn this.get('specularColorFactor');\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\n\tpublic setSpecularColorFactor(factor: vec3): this {\n\t\treturn this.set('specularColorFactor', factor);\n\t}\n\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\n\tpublic getSpecularColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSpecularColorFactor());\n\t}\n\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\n\tpublic setSpecularColorHex(hex: number): this {\n\t\tconst factor = this.getSpecularColorFactor().slice() as vec3;\n\t\treturn this.set('specularColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\n\t * diffuse material.\n\t *\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\n\t * be packed with specular color (RGB) into a single texture.\n\t */\n\tpublic getSpecularTexture(): Texture | null {\n\t\treturn this.getRef('specularTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\n\t}\n\n\t/** Sets specular texture. See {@link getSpecularTexture}. */\n\tpublic setSpecularTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\n\t}\n\n\t/**\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\n\t *\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\n\t * factor (A) into a single texture.\n\t */\n\tpublic getSpecularColorTexture(): Texture | null {\n\t\treturn this.getRef('specularColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular color texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\n\t}\n\n\t/** Sets specular color texture. See {@link getSpecularColorTexture}. */\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\nimport { Specular } from './specular';\n\nconst NAME = KHR_MATERIALS_SPECULAR;\n\ninterface SpecularDef {\n\tspecularFactor?: number;\n\tspecularColorFactor?: vec3;\n\tspecularTexture?: GLTF.ITextureInfo;\n\tspecularColorTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSpecular\n *\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)\n * adjusts the strength of the specular reflection in the dielectric BRDF.\n *\n * MaterialsSpecular is a better alternative to the older\n * {@link MaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\n * provides specular information while remaining within a metal/rough PBR workflow. A\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\n *\n * Properties:\n * - {@link Specular}\n *\n * ### Example\n *\n * The `MaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSpecular, Specular } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specularExtension = document.createExtension(MaterialsSpecular);\n *\n * // Create a Specular property.\n * const specular = specularExtension.createSpecular()\n * \t.setSpecularFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_specular', specular);\n * ```\n */\nexport class MaterialsSpecular extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Specular property for use on a {@link Material}. */\n\tpublic createSpecular(): Specular {\n\t\treturn new Specular(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specular = this.createSpecular();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\n\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\n\t\t\t\tif (specular) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\n\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specular.getSpecularTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\n\ninterface ITransmission extends IProperty {\n\ttransmissionFactor: number;\n\ttransmissionTexture: Texture;\n\ttransmissionTextureInfo: TextureInfo;\n}\n\nconst { R } = TextureChannel;\n\n/**\n * # Transmission\n *\n * Defines optical transmission on a PBR {@link Material}. See {@link MaterialsTransmission}.\n */\nexport class Transmission extends ExtensionProperty<ITransmission> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\n\tpublic declare propertyType: 'Transmission';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\n\t\tthis.propertyType = 'Transmission';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransmission> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\ttransmissionFactor: 0.0,\n\t\t\ttransmissionTexture: null,\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Transmission.\n\t */\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic getTransmissionFactor(): number {\n\t\treturn this.get('transmissionFactor');\n\t}\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionFactor(factor: number): this {\n\t\treturn this.set('transmissionFactor', factor);\n\t}\n\n\t/**\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\n\t * addition of the `KHR_materials_volume` extension.\n\t */\n\tpublic getTransmissionTexture(): Texture | null {\n\t\treturn this.getRef('transmissionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\n\t}\n\n\t/** Sets transmission texture. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\nimport { Transmission } from './transmission';\n\nconst NAME = KHR_MATERIALS_TRANSMISSION;\n\ninterface TransmissionDef {\n\ttransmissionFactor?: number;\n\ttransmissionTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsTransmission\n *\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\n * scattering, or dispersion.\n *\n * While default PBR materials using alpha blending become invisible as their opacity approaches\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\n * transmission values. When combined with {@link MaterialsVolume}, transmission may be used for\n * thicker materials and refractive effects.\n *\n * Properties:\n * - {@link Transmission}\n *\n * ### Example\n *\n * The `MaterialsTransmission` class provides a single {@link ExtensionProperty} type,\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsTransmission, Transmission } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transmissionExtension = document.createExtension(MaterialsTransmission);\n *\n * // Create a Transmission property.\n * const transmission = transmissionExtension.createTransmission()\n * \t.setTransmissionFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_transmission', transmission);\n * ```\n */\nexport class MaterialsTransmission extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transmission property for use on a {@link Material}. */\n\tpublic createTransmission(): Transmission {\n\t\treturn new Transmission(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst transmission = this.createTransmission();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\n\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\n\t\t\t\tif (transmission) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\n\t\t\t\t\t} as TransmissionDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\n\n/**\n * # Unlit\n *\n * Converts a PBR {@link Material} to an unlit shading model. See {@link MaterialsUnlit}.\n */\nexport class Unlit extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\n\tpublic declare propertyType: 'Unlit';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\n\t\tthis.propertyType = 'Unlit';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\nimport { Unlit } from './unlit';\n\nconst NAME = KHR_MATERIALS_UNLIT;\n\n/**\n * # MaterialsUnlit\n *\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)\n * defines an unlit shading model for use in glTF 2.0 materials.\n *\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\n *\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\n *\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\n * effects like hand painted illustrative styles or baked toon shaders.\n *\n * Properties:\n * - {@link Unlit}\n *\n * ### Example\n *\n * The `MaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\n * be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsUnlit, Unlit } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const unlitExtension = document.createExtension(MaterialsUnlit);\n *\n * // Create an Unlit property.\n * const unlit = unlitExtension.createUnlit();\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_unlit', unlit);\n * ```\n */\nexport class MaterialsUnlit extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Unlit property for use on a {@link Material}. */\n\tpublic createUnlit(): Unlit {\n\t\treturn new Unlit(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Material, Nullable } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport type { Variant } from './variant';\n\ninterface IMapping extends IProperty {\n\tmaterial: Material;\n\tvariants: Variant[];\n}\n\n/**\n * # Mapping\n *\n * Maps {@link Variant}s to {@link Material}s. See {@link MaterialsVariants}.\n */\nexport class Mapping extends ExtensionProperty<IMapping> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Mapping';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Mapping';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n\n\tprotected getDefaults(): Nullable<IMapping> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: [] });\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/** Adds a {@link Variant} to this mapping. */\n\tpublic addVariant(variant: Variant): this {\n\t\treturn this.addRef('variants', variant);\n\t}\n\n\t/** Removes a {@link Variant} from this mapping. */\n\tpublic removeVariant(variant: Variant): this {\n\t\treturn this.removeRef('variants', variant);\n\t}\n\n\t/** Lists {@link Variant}s in this mapping. */\n\tpublic listVariants(): Variant[] {\n\t\treturn this.listRefs('variants');\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport type { Mapping } from './mapping';\n\ninterface IMappingList extends IProperty {\n\tmappings: Mapping[];\n}\n\n/**\n * # MappingList\n *\n * List of material variant {@link Mapping}s. See {@link MaterialsVariants}.\n */\nexport class MappingList extends ExtensionProperty<IMappingList> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'MappingList';\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'MappingList';\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\n\t}\n\n\tprotected getDefaults(): Nullable<IMappingList> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: [] });\n\t}\n\n\t/** Adds a {@link Mapping} to this mapping. */\n\tpublic addMapping(mapping: Mapping): this {\n\t\treturn this.addRef('mappings', mapping);\n\t}\n\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\n\tpublic removeMapping(mapping: Mapping): this {\n\t\treturn this.removeRef('mappings', mapping);\n\t}\n\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\n\tpublic listMappings(): Mapping[] {\n\t\treturn this.listRefs('mappings');\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\n\n/**\n * # Variant\n *\n * Defines a variant of a {@link Material}. See {@link MaterialsVariants}.\n */\nexport class Variant extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Variant';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Variant';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport { Mapping } from './mapping';\nimport { MappingList } from './mapping-list';\nimport { Variant } from './variant';\n\nconst NAME = KHR_MATERIALS_VARIANTS;\n\ninterface VariantsRootDef {\n\tvariants: VariantDef[];\n}\n\ninterface VariantDef {\n\tname?: string;\n}\n\ninterface VariantPrimDef {\n\tmappings: VariantMappingDef[];\n}\n\ninterface VariantMappingDef {\n\tmaterial: number;\n\tvariants: number[];\n}\n\n/**\n * # MaterialsVariants\n *\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\n *\n * ![Illustration](/media/extensions/khr-materials-variants.png)\n *\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\n *\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\n * `MaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\n * defining the variants available to an application. Triggering a variant is out of scope of this\n * extension, but could be handled in the application with a UI dropdown, particular game states,\n * and so on.\n *\n * Mesh geometry cannot be changed by this extension, although another extension\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\n *\n * Properties:\n * - {@link Variant}\n * - {@link Mapping}\n * - {@link MappingList}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsVariants } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const variantExtension = document.createExtension(MaterialsVariants);\n *\n * // Create some Variant states.\n * const healthyVariant = variantExtension.createVariant('Healthy');\n * const damagedVariant = variantExtension.createVariant('Damaged');\n *\n * // Create mappings from a Variant state to a Material.\n * const healthyMapping = variantExtension.createMapping()\n * \t.addVariant(healthyVariant)\n * \t.setMaterial(healthyMat);\n * const damagedMapping = variantExtension.createMapping()\n * \t.addVariant(damagedVariant)\n * \t.setMaterial(damagedMat);\n *\n * // Attach the mappings to a Primitive.\n * primitive.setExtension(\n * \t'KHR_materials_variants',\n * \tvariantExtension.createMappingList()\n * \t\t.addMapping(healthyMapping)\n * \t\t.addMapping(damagedMapping)\n * );\n * ```\n *\n * A few notes about this extension:\n *\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\n * \t instead, so assign that material accordingly. This material can be  but doesn't have to be \n * \t associated with one of the available variants.\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\n * \t Variant will be chosen by the viewer.\n * 3. Variant names are how these states are identified, so choose informative names.\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\n * \t the option of downloading only textures associated with the default state, and lazy-loading\n * \t any textures for inactive Variants only when they are needed.\n */\nexport class MaterialsVariants extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new MappingList property. */\n\tpublic createMappingList(): MappingList {\n\t\treturn new MappingList(this.document.getGraph());\n\t}\n\n\t/** Creates a new Variant property. */\n\tpublic createVariant(name = ''): Variant {\n\t\treturn new Variant(this.document.getGraph(), name);\n\t}\n\n\t/** Creates a new Mapping property. */\n\tpublic createMapping(): Mapping {\n\t\treturn new Mapping(this.document.getGraph());\n\t}\n\n\t/** Lists all Variants on the current Document. */\n\tpublic listVariants(): Variant[] {\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\t// Read all top-level variant names.\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\n\t\tconst variantDefs = variantsRootDef.variants || [];\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\n\n\t\t// For each mesh primitive, read its material/variant mappings.\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\n\t\t\tconst mesh = context.meshes[meshIndex];\n\t\t\tconst primDefs = meshDef.primitives || [];\n\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst mappingList = this.createMappingList();\n\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\n\t\t\t\t\tconst mapping = this.createMapping();\n\n\t\t\t\t\tif (mappingDef.material !== undefined) {\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingList.addMapping(mapping);\n\t\t\t\t}\n\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst variants = this.listVariants();\n\t\tif (!variants.length) return this;\n\n\t\t// Write all top-level variant names.\n\t\tconst variantDefs = [];\n\t\tconst variantIndexMap = new Map<Variant, number>();\n\t\tfor (const variant of variants) {\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\n\t\t}\n\n\t\t// For each mesh primitive, write its material/variant mappings.\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\n\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\n\t\t\t\tif (!mappingList) return;\n\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\n\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\n\n\t\t\t\t\tconst material = mapping.getMaterial();\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\n\n\t\t\t\t\treturn mappingDef;\n\t\t\t\t});\n\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\n\t\t\t});\n\t\t}\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\n\ninterface IVolume extends IProperty {\n\tthicknessFactor: number;\n\tthicknessTexture: Texture;\n\tthicknessTextureInfo: TextureInfo;\n\tattenuationDistance: number;\n\tattenuationColor: vec3;\n}\n\nconst { G } = TextureChannel;\n\n/**\n * # Volume\n *\n * Defines volume on a PBR {@link Material}. See {@link MaterialsVolume}.\n */\nexport class Volume extends ExtensionProperty<IVolume> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\n\tpublic declare propertyType: 'Volume';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\n\t\tthis.propertyType = 'Volume';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IVolume> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tthicknessFactor: 0.0,\n\t\t\tthicknessTexture: null,\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\n\t\t\tattenuationDistance: Infinity,\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Thickness.\n\t */\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic getThicknessFactor(): number {\n\t\treturn this.get('thicknessFactor');\n\t}\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic setThicknessFactor(factor: number): this {\n\t\treturn this.set('thicknessFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic getThicknessTexture(): Texture | null {\n\t\treturn this.getRef('thicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic setThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Attenuation.\n\t */\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic getAttenuationDistance(): number {\n\t\treturn this.get('attenuationDistance');\n\t}\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic setAttenuationDistance(distance: number): this {\n\t\treturn this.set('attenuationDistance', distance);\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColor(): vec3 {\n\t\treturn this.get('attenuationColor');\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColor(color: vec3): this {\n\t\treturn this.set('attenuationColor', color);\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getAttenuationColor());\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColorHex(hex: number): this {\n\t\tconst factor = this.getAttenuationColor().slice() as vec3;\n\t\treturn this.set('attenuationColor', ColorUtils.hexToFactor(hex, factor));\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\nimport { Volume } from './volume';\n\nconst NAME = KHR_MATERIALS_VOLUME;\n\ninterface VolumeDef {\n\tthicknessFactor?: number;\n\tthicknessTexture?: GLTF.ITextureInfo;\n\tattenuationDistance?: number;\n\tattenuationColor?: vec3;\n}\n\n/**\n * # MaterialsVolume\n *\n * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\n * translucency.\n *\n * ![Illustration](/media/extensions/khr-materials-volume.png)\n *\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\n * > volume (right). The overall color depends on the distance the light traveled through it; at\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\n * > large distances. Source: Khronos Group._\n *\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\n * effects will require future (TBD) extensions.\n *\n * The volume extension must be combined with {@link MaterialsTransmission} or\n * `KHR_materials_translucency` in order to define entry of light into the volume.\n *\n * Properties:\n * - {@link Volume}\n *\n * ### Example\n *\n * The `MaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\n * may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsVolume, Volume } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const volumeExtension = document.createExtension(MaterialsVolume);\n *\n * // Create a Volume property.\n * const volume = volumeExtension.createVolume()\n * \t.setThicknessFactor(1.0)\n * \t.setThicknessTexture(texture)\n * \t.setAttenuationDistance(1.0)\n * \t.setAttenuationColorHex(0xFFEEEE);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_volume', volume);\n * ```\n *\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\n */\nexport class MaterialsVolume extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Volume property for use on a {@link Material}. */\n\tpublic createVolume(): Volume {\n\t\treturn new Volume(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst volume = this.createVolume();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\n\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tvolume.setThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\n\t\t\t\tif (volume) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\n\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (volume.getThicknessTexture()) {\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MESH_QUANTIZATION } from '../constants';\n\nconst NAME = KHR_MESH_QUANTIZATION;\n\n/**\n * # MeshQuantization\n *\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\n *\n * Quantization provides a memory/precision tradeoff  depending on the application needs, 16-bit or\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\n * mesh might be written to a uint16 {@link Accessor}, with values `065536`, normalized to be\n * interpreted as `01`. With an additional 10x scale on any node {@link Node} instantiating the\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\n * up to 50% file size reduction.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing more flexible use of\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\n * types would yield an invalid glTF document, under the stricter core glTF specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { MeshQuantization } from '@gltf-transform/extensions';\n * import { quantize } from '@gltf-transform/functions';\n *\n * // Create an Extension attached to the Document.\n * const quantizationExtension = document.createExtension(MeshQuantization).setRequired(true);\n *\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\n * // or apply the provided quantize() function to compute quantized accessors automatically:\n * await document.transform(quantize({\n * \tquantizePosition: 16,\n * \tquantizeNormal: 12,\n * \tquantizeTexcoord: 14\n * }));\n * ```\n *\n * For more documentation about automatic quantization, see the {@link quantize} function.\n */\nexport class MeshQuantization extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tread(_: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\twrite(_: WriterContext): this {\n\t\treturn this;\n\t}\n}\n","import { KTX2Model, read as readKTX } from 'ktx-parse';\nimport {\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { KHR_TEXTURE_BASISU } from '../constants';\n\nconst NAME = KHR_TEXTURE_BASISU;\n\ninterface BasisuDef {\n\tsource: number;\n}\n\nclass KTX2ImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray[0] === 0xab &&\n\t\t\tarray[1] === 0x4b &&\n\t\t\tarray[2] === 0x54 &&\n\t\t\tarray[3] === 0x58 &&\n\t\t\tarray[4] === 0x20 &&\n\t\t\tarray[5] === 0x32 &&\n\t\t\tarray[6] === 0x30 &&\n\t\t\tarray[7] === 0xbb &&\n\t\t\tarray[8] === 0x0d &&\n\t\t\tarray[9] === 0x0a &&\n\t\t\tarray[10] === 0x1a &&\n\t\t\tarray[11] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst container = readKTX(array);\n\t\treturn [container.pixelWidth, container.pixelHeight];\n\t}\n\tgetChannels(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\tif (dfd.colorModel === KTX2Model.ETC1S) {\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === 15 ? 4 : 3;\n\t\t} else if (dfd.colorModel === KTX2Model.UASTC) {\n\t\t\treturn (dfd.samples[0].channelID & 0xf) === 3 ? 4 : 3;\n\t\t}\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\n\t}\n\tgetGPUByteLength(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst hasAlpha = this.getChannels(array) > 3;\n\n\t\tlet uncompressedBytes = 0;\n\t\tfor (let i = 0; i < container.levels.length; i++) {\n\t\t\tconst level = container.levels[i];\n\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\n\t\t\tif (level.uncompressedByteLength) {\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\n\t\t\t} else {\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\n\t\t\t}\n\t\t}\n\n\t\treturn uncompressedBytes;\n\t}\n}\n\n/**\n * # TextureBasisu\n *\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\n *\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\n * framerate while uploading images, or where GPU memory is limited.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureBasisu } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const basisuExtension = document.createExtension(TextureBasisu)\n * \t.setRequired(true);\n * document.createTexture('MyCompressedTexture')\n * \t.setMimeType('image/ktx2')\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\n * ```\n *\n * Compression is not done automatically when adding the extension as shown above  you must\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\n * [glTF-Transform CLI](/cli.html) has functions to help with this, or any similar KTX2-capable\n * utility will work.\n *\n * When the `KHR_texture_basisu` extension is added to a file by glTF-Transform, the extension\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\n * PNG or JPEG image data.\n *\n * > _**NOTICE:** Compressing some textures  particularly 3-component (RGB) normal maps, and\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\n * > texture before compressing it.\n * >\n * > For best results when authoring new textures, use\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\n * > prominent UV seams._\n */\nexport class TextureBasisu extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\n\t\t\t\ttextureDef.source = basisuDef.source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\n\ninterface ITransform extends IProperty {\n\toffset: vec2;\n\trotation: number;\n\tscale: vec2;\n\ttexCoord: number | null; // null  do not override TextureInfo.\n}\n\n/**\n * # Transform\n *\n * Defines UV transform for a {@link TextureInfo}. See {@link TextureTransform}.\n */\nexport class Transform extends ExtensionProperty<ITransform> {\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\n\tpublic declare propertyType: 'Transform';\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\n\t\tthis.propertyType = 'Transform';\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransform> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\toffset: [0.0, 0.0] as vec2,\n\t\t\trotation: 0,\n\t\t\tscale: [1.0, 1.0] as vec2,\n\t\t\ttexCoord: null,\n\t\t});\n\t}\n\n\tpublic getOffset(): vec2 {\n\t\treturn this.get('offset');\n\t}\n\tpublic setOffset(offset: vec2): this {\n\t\treturn this.set('offset', offset);\n\t}\n\n\tpublic getRotation(): number {\n\t\treturn this.get('rotation');\n\t}\n\tpublic setRotation(rotation: number): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\tpublic getScale(): vec2 {\n\t\treturn this.get('scale');\n\t}\n\tpublic setScale(scale: vec2): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\tpublic getTexCoord(): number | null {\n\t\treturn this.get('texCoord');\n\t}\n\tpublic setTexCoord(texCoord: number | null): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\nimport { Transform } from './transform';\n\nconst NAME = KHR_TEXTURE_TRANSFORM;\n\ninterface TransformDef {\n\toffset?: vec2;\n\trotation?: number;\n\tscale?: vec2;\n\ttexCoord?: number;\n}\n\n/**\n * # TextureTransform\n *\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\n *\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\n * this time.\n *\n * Properties:\n * - {@link Transform}\n *\n * ### Example\n *\n * The `TextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\n * may be attached to any {@link TextureInfo} instance. For example:\n *\n * ```typescript\n * import { TextureTransform } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transformExtension = document.createExtension(TextureTransform)\n * \t.setRequired(true);\n *\n * // Create a reusable Transform.\n * const transform = transformExtension.createTransform()\n * \t.setScale([100, 100]);\n *\n * // Apply the Transform to a Material's baseColorTexture.\n * document.createMaterial()\n * \t.setBaseColorTexture(myTexture)\n * \t.getBaseColorTextureInfo()\n * \t.setExtension('KHR_texture_transform', transform);\n * ```\n */\nexport class TextureTransform extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\n\tpublic createTransform(): Transform {\n\t\treturn new Transform(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\n\n\t\t\tconst transform = this.createTransform();\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\n\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\n\n\t\t\ttextureInfo.setExtension(NAME, transform);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\n\t\t\tif (!transform) continue;\n\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\n\t\t\tconst transformDef = {} as TransformDef;\n\n\t\t\tconst eq = MathUtils.eq;\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\n\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { Nullable, PropertyType, ExtensionProperty, IProperty } from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants';\n\ntype Term = string;\ntype TermDefinition = string | Record<string, string>;\n\ntype Value = string | number | boolean;\n\nconst PARENT_TYPES = [\n\tPropertyType.ROOT,\n\tPropertyType.SCENE,\n\tPropertyType.NODE,\n\tPropertyType.MESH,\n\tPropertyType.MATERIAL,\n\tPropertyType.TEXTURE,\n\tPropertyType.ANIMATION,\n];\n\ninterface IPacket extends IProperty {\n\t// https://json-ld.org/spec/latest/json-ld/#the-context\n\tcontext: Record<Term, TermDefinition>;\n\tproperties: Record<string, Value | Record<string, unknown>>;\n}\n\n/**\n * # Packet\n *\n * Defines an XMP packet associated with a Document or Property. See {@link XMP}.\n */\nexport class Packet extends ExtensionProperty<IPacket> {\n\tpublic declare propertyType: 'Packet';\n\tpublic declare parentTypes: typeof PARENT_TYPES;\n\tpublic declare extensionName: typeof KHR_XMP_JSON_LD;\n\tpublic static EXTENSION_NAME = KHR_XMP_JSON_LD;\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_XMP_JSON_LD;\n\t\tthis.propertyType = 'Packet';\n\t\tthis.parentTypes = PARENT_TYPES;\n\t}\n\n\tprotected getDefaults(): Nullable<IPacket> {\n\t\treturn Object.assign(super.getDefaults(), { context: {}, properties: {} });\n\t}\n\n\t/**********************************************************************************************\n\t * Context.\n\t */\n\n\t/**\n\t * Returns the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t */\n\tpublic getContext(): Record<Term, TermDefinition> {\n\t\treturn this.get('context');\n\t}\n\n\t/**\n\t * Sets the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setContext({\n\t *   dc: 'http://purl.org/dc/elements/1.1/',\n\t *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\n\t * });\n\t * ```\n\t *\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t * @param definition URI for XMP namespace.\n\t */\n\tpublic setContext(context: Record<Term, TermDefinition>): this {\n\t\treturn this.set('context', { ...context });\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Lists properties defined in this packet.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.listProperties(); //  ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\n\t * ```\n\t */\n\tpublic listProperties(): string[] {\n\t\treturn Object.keys(this.get('properties'));\n\t}\n\n\t/**\n\t * Returns the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.getProperty('dc:Creator'); //  {\"@list\": [\"Acme, Inc.\"]}\n\t * packet.getProperty('dc:Title'); //  {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\n\t * packet.getProperty('xmp:CreateDate'); //  \"2022-01-01\"\n\t * ```\n\t */\n\tpublic getProperty(name: string): Value | Record<string, unknown> | null {\n\t\tconst properties = this.get('properties');\n\t\treturn name in properties ? properties[name] : null;\n\t}\n\n\t/**\n\t * Sets the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\n\t * packet.setProperty('dc:Title', {\n\t * \t'@type': 'rdf:Alt',\n\t * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\n\t * });\n\t * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\n\t * ```\n\t */\n\tpublic setProperty(name: string, value: Value | Record<string, unknown>): this {\n\t\tthis._assertContext(name);\n\n\t\tconst properties = { ...this.get('properties') };\n\t\tif (value) {\n\t\t\tproperties[name] = value;\n\t\t} else {\n\t\t\tdelete properties[name];\n\t\t}\n\t\treturn this.set('properties', properties);\n\t}\n\n\t/**********************************************************************************************\n\t * Serialize / Deserialize.\n\t */\n\n\t/**\n\t * Serializes the packet context and properties to a JSONLD object.\n\t */\n\tpublic toJSONLD(): Record<string, unknown> {\n\t\tconst context = copyJSON(this.get('context'));\n\t\tconst properties = copyJSON(this.get('properties'));\n\t\treturn { '@context': context, ...properties };\n\t}\n\n\t/**\n\t * Deserializes a JSONLD packet, then overwrites existing context and properties with\n\t * the new values.\n\t */\n\tpublic fromJSONLD(jsonld: Record<string, unknown>): this {\n\t\tjsonld = copyJSON(jsonld);\n\n\t\t// Context.\n\t\tconst context = jsonld['@context'] as Record<Term, TermDefinition>;\n\t\tif (context) this.set('context', context);\n\t\tdelete jsonld['@context'];\n\n\t\t// Properties.\n\t\treturn this.set('properties', jsonld as Record<string, string | Record<string, unknown>>);\n\t}\n\n\t/**********************************************************************************************\n\t * Validation.\n\t */\n\n\t/** @hidden */\n\tprivate _assertContext(name: string) {\n\t\tconst prefix = name.split(':')[0];\n\t\tif (!(prefix in this.get('context'))) {\n\t\t\tthrow new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\n\t\t}\n\t}\n}\n\nfunction copyJSON<T>(object: T): T {\n\treturn JSON.parse(JSON.stringify(object));\n}\n","import {\n\tAnimation,\n\tExtension,\n\tGLTF,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPropertyType,\n\tReaderContext,\n\tScene,\n\tTexture,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants';\nimport { Packet } from './packet';\n\nconst NAME = KHR_XMP_JSON_LD;\n\ntype XMPPacketDef = Record<string, unknown>;\n\ntype XMPParentDef =\n\t| GLTF.IAsset\n\t| GLTF.IScene\n\t| GLTF.INode\n\t| GLTF.IMesh\n\t| GLTF.IMaterial\n\t| GLTF.ITexture\n\t| GLTF.IAnimation;\n\ninterface XMPPropertyDef {\n\tpacket: number;\n}\n\ninterface XMPRootDef {\n\tpackets?: XMPPacketDef[];\n}\n\n/**\n * # XMP\n *\n * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)\n * defines XMP metadata associated with a glTF asset.\n *\n * XMP metadata provides standardized fields describing the content, provenance, usage\n * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the\n * parsing or runtime behavior of the content  for that, use custom extensions, custom vertex\n * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred\n * for binary content like mesh data, animations, or textures.\n *\n * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}\n * to the document {@link Root}. In less common cases where metadata must be associated with\n * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},\n * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.\n *\n * Within each packet, XMP properties become available when an\n * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered\n * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not\n * registered as context. While not all XMP namespaces are relevant to 3D assets, some common\n * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`\n * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)\n * orientation data.\n *\n * Common XMP contexts for 3D models include:\n *\n * | Prefix      | URI                                         | Name                           |\n * |:------------|:--------------------------------------------|:-------------------------------|\n * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |\n * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |\n * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |\n * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |\n * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |\n *\n * Only the XMP contexts required for a packet should be assigned, and different packets\n * in the same asset may use different contexts.\n *\n * Properties:\n * - {@link Packet}\n *\n * ### Example\n *\n * ```typescript\n * import { XMP, Packet } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const xmpExtension = document.createExtension(XMP);\n *\n * // Create Packet property.\n * const packet = xmpExtension.createPacket()\n * \t.setContext({\n * \t\tdc: 'http://purl.org/dc/elements/1.1/',\n * \t})\n *\t.setProperty('dc:Creator', {\"@list\": [\"Acme, Inc.\"]});\n *\n * // Option 1: Assign to Document Root.\n * document.getRoot().setExtension('KHR_xmp_json_ld', packet);\n *\n * // Option 2: Assign to a specific Property.\n * texture.setExtension('KHR_xmp_json_ld', packet);\n * ```\n */\nexport class XMP extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\n\tpublic createPacket(): Packet {\n\t\treturn new Packet(this.document.getGraph());\n\t}\n\n\t/** Lists XMP packets currently defined in a {@link Document}. */\n\tpublic listPackets(): Packet[] {\n\t\treturn Array.from(this.properties) as Packet[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst extensionDef = context.jsonDoc.json.extensions?.[NAME] as XMPRootDef | undefined;\n\t\tif (!extensionDef || !extensionDef.packets) return this;\n\n\t\t// Deserialize packets.\n\t\tconst json = context.jsonDoc.json;\n\t\tconst root = this.document.getRoot();\n\t\tconst packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\n\n\t\tconst defLists = [\n\t\t\t[json.asset],\n\t\t\tjson.scenes,\n\t\t\tjson.nodes,\n\t\t\tjson.meshes,\n\t\t\tjson.materials,\n\t\t\tjson.images,\n\t\t\tjson.animations,\n\t\t];\n\n\t\tconst propertyLists = [\n\t\t\t[root],\n\t\t\troot.listScenes(),\n\t\t\troot.listNodes(),\n\t\t\troot.listMeshes(),\n\t\t\troot.listMaterials(),\n\t\t\troot.listTextures(),\n\t\t\troot.listAnimations(),\n\t\t];\n\n\t\t// Assign packets.\n\t\tfor (let i = 0; i < defLists.length; i++) {\n\t\t\tconst defs = defLists[i] || [];\n\t\t\tfor (let j = 0; j < defs.length; j++) {\n\t\t\t\tconst def = defs[j];\n\t\t\t\tif (def.extensions && def.extensions[NAME]) {\n\t\t\t\t\tconst xmpDef = def.extensions[NAME] as XMPPropertyDef;\n\t\t\t\t\tpropertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst { json } = context.jsonDoc;\n\n\t\tconst packetDefs = [];\n\n\t\tfor (const packet of this.properties as Set<Packet>) {\n\t\t\t// Serialize packets.\n\t\t\tpacketDefs.push(packet.toJSONLD());\n\n\t\t\t// Assign packets.\n\n\t\t\tfor (const parent of packet.listParents()) {\n\t\t\t\tlet parentDef: XMPParentDef | null;\n\n\t\t\t\tswitch (parent.propertyType) {\n\t\t\t\t\tcase PropertyType.ROOT:\n\t\t\t\t\t\tparentDef = json.asset;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.SCENE:\n\t\t\t\t\t\tparentDef = json.scenes![context.sceneIndexMap.get(parent as Scene)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.NODE:\n\t\t\t\t\t\tparentDef = json.nodes![context.nodeIndexMap.get(parent as Node)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MESH:\n\t\t\t\t\t\tparentDef = json.meshes![context.meshIndexMap.get(parent as Mesh)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MATERIAL:\n\t\t\t\t\t\tparentDef = json.materials![context.materialIndexMap.get(parent as Material)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.TEXTURE:\n\t\t\t\t\t\tparentDef = json.images![context.imageIndexMap.get(parent as Texture)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.ANIMATION:\n\t\t\t\t\t\tparentDef = json.animations![context.animationIndexMap.get(parent as Animation)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparentDef = null;\n\t\t\t\t\t\tthis.document\n\t\t\t\t\t\t\t.getLogger()\n\t\t\t\t\t\t\t.warn(`[${NAME}]: Unsupported parent property, \"${parent.propertyType}\"`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!parentDef) continue;\n\n\t\t\t\tparentDef.extensions = parentDef.extensions || {};\n\t\t\t\tparentDef.extensions[NAME] = { packet: packetDefs.length - 1 };\n\t\t\t}\n\t\t}\n\n\t\tif (packetDefs.length > 0) {\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[NAME] = { packets: packetDefs };\n\t\t}\n\n\t\treturn this;\n\t}\n}\n","/** @module extensions */\n\nimport { MeshGPUInstancing } from './ext-mesh-gpu-instancing';\nimport { MeshoptCompression } from './ext-meshopt-compression';\nimport { TextureWebP } from './ext-texture-webp';\nimport { DracoMeshCompression } from './khr-draco-mesh-compression';\nimport { LightsPunctual } from './khr-lights-punctual';\nimport { MaterialsClearcoat } from './khr-materials-clearcoat';\nimport { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';\nimport { MaterialsIOR } from './khr-materials-ior';\nimport { MaterialsIridescence } from './khr-materials-iridescence';\nimport { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';\nimport { MaterialsSheen } from './khr-materials-sheen';\nimport { MaterialsSpecular } from './khr-materials-specular';\nimport { MaterialsTransmission } from './khr-materials-transmission';\nimport { MaterialsUnlit } from './khr-materials-unlit';\nimport { MaterialsVariants } from './khr-materials-variants';\nimport { MaterialsVolume } from './khr-materials-volume';\nimport { MeshQuantization } from './khr-mesh-quantization';\nimport { TextureBasisu } from './khr-texture-basisu';\nimport { TextureTransform } from './khr-texture-transform';\nimport { XMP } from './khr-xmp-json-ld';\n\nexport const KHRONOS_EXTENSIONS = [\n\tDracoMeshCompression,\n\tLightsPunctual,\n\tMaterialsClearcoat,\n\tMaterialsEmissiveStrength,\n\tMaterialsIOR,\n\tMaterialsIridescence,\n\tMaterialsPBRSpecularGlossiness,\n\tMaterialsSpecular,\n\tMaterialsSheen,\n\tMaterialsTransmission,\n\tMaterialsUnlit,\n\tMaterialsVariants,\n\tMaterialsVolume,\n\tMeshQuantization,\n\tTextureBasisu,\n\tTextureTransform,\n\tXMP,\n];\n\nexport const ALL_EXTENSIONS = [MeshGPUInstancing, MeshoptCompression, TextureWebP, ...KHRONOS_EXTENSIONS];\n\nexport * from './ext-mesh-gpu-instancing';\nexport * from './ext-meshopt-compression';\nexport * from './ext-texture-webp';\nexport * from './khr-draco-mesh-compression';\nexport * from './khr-lights-punctual';\nexport * from './khr-materials-clearcoat';\nexport * from './khr-materials-emissive-strength';\nexport * from './khr-materials-ior';\nexport * from './khr-materials-iridescence';\nexport * from './khr-materials-sheen';\nexport * from './khr-materials-specular';\nexport * from './khr-materials-pbr-specular-glossiness';\nexport * from './khr-materials-transmission';\nexport * from './khr-materials-unlit';\nexport * from './khr-materials-variants';\nexport * from './khr-materials-volume';\nexport * from './khr-mesh-quantization';\nexport * from './khr-texture-basisu';\nexport * from './khr-texture-transform';\nexport * from './khr-xmp-json-ld';\n"],"names":["InstancedMesh","ExtensionProperty","init","this","extensionName","propertyType","parentTypes","PropertyType","NODE","getDefaults","Object","assign","super","attributes","getAttribute","semantic","getRefMap","setAttribute","accessor","setRefMap","usage","listAttributes","listRefMapValues","listSemantics","listRefMapKeys","EXTENSION_NAME","NAME","MeshGPUInstancing","Extension","provideTypes","prewriteTypes","ACCESSOR","createInstancedMesh","document","getGraph","read","context","jsonDoc","json","nodes","forEach","nodeDef","nodeIndex","extensions","instancedMeshDef","instancedMesh","accessors","setExtension","prewrite","accessorUsageGroupedByParent","add","prop","properties","attribute","addAccessorToUsageGroup","write","getRoot","listNodes","node","getExtension","nodeIndexMap","get","accessorIndexMap","EncoderMethod","MeshoptMode","MeshoptFilter","BYTE","SHORT","FLOAT","Accessor","ComponentType","normalize","denormalize","MathUtils","prepareAccessor","encoder","mode","filterOptions","filter","bits","result","array","getArray","byteStride","getElementSize","getComponentSize","componentType","getComponentType","normalized","getNormalized","ATTRIBUTES","NONE","srcArray","dstArray","Float32Array","length","i","denormalizeArray","EXPONENTIAL","encodeFilterExp","getCount","OCTAHEDRAL","il","padNormals","encodeFilterOct","QUATERNION","encodeFilterQuat","Error","min","getMin","max","getMax","map","v","elementSize","elementStride","BufferUtils","padNumber","BYTES_PER_ELEMENT","constructor","j","padArrayElements","byteLength","getMeshoptMode","WriterContext","BufferViewUsage","ELEMENT_ARRAY_BUFFER","listParents","some","parent","Primitive","getMode","Mode","TRIANGLES","INDICES","getMeshoptFilter","doc","refs","listParentEdges","edge","getParent","Root","ref","refName","getName","refKey","getAttributes","key","startsWith","targetPath","getTargetPath","sampler","AnimationSampler","channel","AnimationChannel","DEFAULT_ENCODER_OPTIONS","method","QUANTIZE","MeshoptCompression","prereadTypes","BUFFER","PRIMITIVE","readDependencies","writeDependencies","_decoder","_decoderFallbackBufferMap","Map","_encoder","_encoderOptions","_encoderFallbackBuffer","_encoderBufferViews","_encoderBufferViewData","_encoderBufferViewAccessors","install","dependency","setEncoderOptions","options","preread","isRequired","supported","_prereadBuffers","_prereadPrimitives","bufferViews","viewDef","index","meshoptDef","byteOffset","count","stride","Uint8Array","bufferDef","buffers","buffer","source","toView","uri","resources","GLB_BUFFER","decodeGltfBuffer","fallback","set","_context","fallbackBuffer","swap","dispose","_prewriteAccessors","_prewriteBuffers","createBuffer","fallbackBufferIndex","listBuffers","indexOf","listAccessors","getAccessorUsage","FILTER","preparedAccessor","getBuffer","bufferIndex","join","bufferView","bufferViewData","bufferViewAccessors","target","USAGE_TO_TARGET","ARRAY_BUFFER","undefined","[object Object]","accessorDef","createAccessorDef","push","EXT_meshopt_compression","otherBufferViews","concat","encodeGltfBuffer","compressedData","pad","fallbackBufferByteOffset","bufferViewIndex","otherBufferViewsIndexMap","finalBufferViewDef","compressedByteOffset","bufferIndexMap","fallbackBufferDef","WEBPImageUtils","match","getSize","RIFF","decodeText","slice","WEBP","view","DataView","offset","chunkId","getUint8","chunkByteLength","getUint32","getInt16","b0","b1","b2","getChannels","_buffer","TextureWebP","TEXTURE","ImageUtils","registerFormat","textures","textureDef","listTextures","texture","getMimeType","imageIndex","imageIndexMap","decoderModule","COMPONENT_ARRAY","DATA_TYPE","encoderModule","decodeGeometry","decoder","data","DecoderBuffer","Init","GetEncodedGeometryType","TRIANGULAR_MESH","dracoMesh","Mesh","DecodeBufferToMesh","ok","ptr","destroy","decodeIndex","mesh","numIndices","num_faces","indices","num_points","Uint16Array","_malloc","GetTrianglesUInt16Array","HEAPU16","Uint32Array","GetTrianglesUInt32Array","HEAPU32","_free","decodeAttribute","dataType","ArrayCtor","numComponents","num_components","numValues","GetAttributeDataArrayForAllPoints","HEAPF32","AttributeEnum","DEFAULT_QUANTIZATION_BITS","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","decodeSpeed","encodeSpeed","EDGEBREAKER","quantizationBits","quantizationVolume","encodeGeometry","prim","_options","Encoder","builder","MeshBuilder","attributeIDs","dracoBuffer","DracoInt8Array","attributeEnum","getAttributeEnum","attributeID","addAttribute","SetAttributeQuantization","range","Math","SetAttributeExplicitQuantization","getIndices","AddFacesToMesh","SetSpeedOptions","SetTrackEncodedProperties","SEQUENTIAL","listTargets","SetEncodingMethod","MESH_SEQUENTIAL_ENCODING","MESH_EDGEBREAKER_ENCODING","EncodeMeshToDracoBuffer","GetValue","prevNumVertices","numVertices","GetNumberOfEncodedPoints","GetNumberOfEncodedFaces","itemSize","UNSIGNED_BYTE","AddUInt8Attribute","AddInt8Attribute","UNSIGNED_SHORT","AddUInt16Attribute","AddInt16Attribute","UNSIGNED_INT","AddUInt32Attribute","AddFloatAttribute","DracoMeshCompression","_decoderModule","_encoderModule","Int16Array","Int8Array","DT_FLOAT32","DT_UINT32","DT_UINT16","DT_UINT8","DT_INT16","DT_INT8","logger","getLogger","dracoMeshes","meshDefs","meshes","meshDef","primDef","primitives","dracoDef","bufferViewDef","Decoder","debug","dracoAttribute","GetAttributeByUniqueId","attributeArray","setArray","Array","from","values","_propertyType","JSON","stringify","primitiveHashMap","included","Set","excluded","listMeshes","listPrimitives","warn","accessorIndices","includedAccessors","includedHashKeys","primToHashKey","hashKey","createHashKey","has","dstIndices","clone","dstAttribute","keys","size","ROOT","attr","listDracoPrimitives","primitiveEncodingMap","listScenes","bounds","pop","primHash","accessorDefs","encodedPrim","indicesDef","attributeDef","extensionData","dracoContext","meshIndexMap","extensionsUsed","name","extensionsRequired","indexMap","hashElements","sort","Light","color","intensity","type","Type","POINT","innerConeAngle","outerConeAngle","PI","getColor","setColor","getColorHex","ColorUtils","factorToHex","setColorHex","hex","hexToFactor","getIntensity","setIntensity","getType","setType","getRange","setRange","getInnerConeAngle","setInnerConeAngle","angle","getOuterConeAngle","setOuterConeAngle","SPOT","DIRECTIONAL","LightsPunctual","createLight","lights","lightDef","light","setName","spot","lightDefs","lightIndexMap","property","eq","R","G","B","TextureChannel","Clearcoat","MATERIAL","clearcoatFactor","clearcoatTexture","clearcoatTextureInfo","TextureInfo","graph","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatRoughnessTextureInfo","clearcoatNormalScale","clearcoatNormalTexture","clearcoatNormalTextureInfo","getClearcoatFactor","setClearcoatFactor","factor","getClearcoatTexture","getRef","getClearcoatTextureInfo","setClearcoatTexture","setRef","channels","getClearcoatRoughnessFactor","setClearcoatRoughnessFactor","getClearcoatRoughnessTexture","getClearcoatRoughnessTextureInfo","setClearcoatRoughnessTexture","getClearcoatNormalScale","setClearcoatNormalScale","scale","getClearcoatNormalTexture","getClearcoatNormalTextureInfo","setClearcoatNormalTexture","MaterialsClearcoat","createClearcoat","textureDefs","materials","materialDef","materialIndex","clearcoat","clearcoatDef","textureInfoDef","setTextureInfo","listMaterials","material","materialIndexMap","textureInfo","createTextureInfoDef","EmissiveStrength","emissiveStrength","getEmissiveStrength","setEmissiveStrength","strength","MaterialsEmissiveStrength","createEmissiveStrength","emissiveStrengthDef","IOR","ior","getIOR","setIOR","MaterialsIOR","createIOR","iorDef","Iridescence","iridescenceFactor","iridescenceTexture","iridescenceTextureInfo","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","iridescenceThicknessTextureInfo","getIridescenceFactor","setIridescenceFactor","getIridescenceTexture","getIridescenceTextureInfo","setIridescenceTexture","getIridescenceIOR","setIridescenceIOR","getIridescenceThicknessMinimum","setIridescenceThicknessMinimum","thickness","getIridescenceThicknessMaximum","setIridescenceThicknessMaximum","getIridescenceThicknessTexture","getIridescenceThicknessTextureInfo","setIridescenceThicknessTexture","MaterialsIridescence","createIridescence","iridescence","iridescenceDef","A","PBRSpecularGlossiness","diffuseFactor","diffuseTexture","diffuseTextureInfo","specularFactor","glossinessFactor","specularGlossinessTexture","specularGlossinessTextureInfo","getDiffuseFactor","setDiffuseFactor","getDiffuseHex","setDiffuseHex","getDiffuseTexture","getDiffuseTextureInfo","setDiffuseTexture","getSpecularFactor","setSpecularFactor","getGlossinessFactor","setGlossinessFactor","getSpecularGlossinessTexture","getSpecularGlossinessTextureInfo","setSpecularGlossinessTexture","MaterialsPBRSpecularGlossiness","createPBRSpecularGlossiness","specGloss","specGlossDef","Sheen","sheenColorFactor","sheenColorTexture","sheenColorTextureInfo","sheenRoughnessFactor","sheenRoughnessTexture","sheenRoughnessTextureInfo","getSheenColorFactor","getSheenColorHex","setSheenColorFactor","setSheenColorHex","getSheenColorTexture","getSheenColorTextureInfo","setSheenColorTexture","getSheenRoughnessFactor","setSheenRoughnessFactor","getSheenRoughnessTexture","getSheenRoughnessTextureInfo","setSheenRoughnessTexture","MaterialsSheen","createSheen","sheen","sheenDef","Specular","specularTexture","specularTextureInfo","specularColorFactor","specularColorTexture","specularColorTextureInfo","getSpecularColorFactor","setSpecularColorFactor","getSpecularColorHex","setSpecularColorHex","getSpecularTexture","getSpecularTextureInfo","setSpecularTexture","getSpecularColorTexture","getSpecularColorTextureInfo","setSpecularColorTexture","MaterialsSpecular","createSpecular","specular","specularDef","Transmission","transmissionFactor","transmissionTexture","transmissionTextureInfo","getTransmissionFactor","setTransmissionFactor","getTransmissionTexture","getTransmissionTextureInfo","setTransmissionTexture","MaterialsTransmission","createTransmission","transmission","transmissionDef","Unlit","MaterialsUnlit","createUnlit","Mapping","variants","getMaterial","setMaterial","addVariant","variant","addRef","removeVariant","removeRef","listVariants","listRefs","MappingList","mappings","addMapping","mapping","removeMapping","listMappings","Variant","MaterialsVariants","createMappingList","createVariant","createMapping","variantDef","meshIndex","primIndex","mappingList","variantPrimDef","mappingDef","variantIndex","variantDefs","variantIndexMap","createPropertyDef","mappingDefs","Volume","thicknessFactor","thicknessTexture","thicknessTextureInfo","attenuationDistance","Infinity","attenuationColor","getThicknessFactor","setThicknessFactor","getThicknessTexture","getThicknessTextureInfo","setThicknessTexture","getAttenuationDistance","setAttenuationDistance","distance","getAttenuationColor","setAttenuationColor","getAttenuationColorHex","setAttenuationColorHex","MaterialsVolume","createVolume","volume","volumeDef","Number","isFinite","MeshQuantization","_","KTX2ImageUtils","container","readKTX","pixelWidth","pixelHeight","dfd","dataFormatDescriptor","colorModel","KTX2Model","ETC1S","samples","channelID","UASTC","getGPUByteLength","hasAlpha","uncompressedBytes","levels","level","uncompressedByteLength","floor","pow","TextureBasisu","Transform","TEXTURE_INFO","rotation","texCoord","getOffset","setOffset","getRotation","setRotation","getScale","setScale","getTexCoord","setTexCoord","TextureTransform","createTransform","textureInfos","entries","transform","transformDef","textureInfoEntries","textureInfoDefMap","PARENT_TYPES","SCENE","MESH","ANIMATION","Packet","getContext","setContext","listProperties","getProperty","setProperty","value","_assertContext","toJSONLD","@context","copyJSON","fromJSONLD","jsonld","split","object","parse","XMP","createPacket","listPackets","extensionDef","packets","root","packetDef","defLists","asset","scenes","images","animations","propertyLists","listAnimations","defs","def","packet","packetDefs","parentDef","sceneIndexMap","animationIndexMap","KHRONOS_EXTENSIONS","ALL_EXTENSIONS"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"extensions.js","sources":["../src/ext-mesh-gpu-instancing/instanced-mesh.ts","../src/constants.ts","../src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts","../src/ext-meshopt-compression/constants.ts","../src/ext-meshopt-compression/encoder.ts","../src/ext-meshopt-compression/meshopt-compression.ts","../src/ext-meshopt-compression/decoder.ts","../src/ext-texture-webp/texture-webp.ts","../src/khr-draco-mesh-compression/decoder.ts","../src/khr-draco-mesh-compression/encoder.ts","../src/khr-draco-mesh-compression/draco-mesh-compression.ts","../src/khr-lights-punctual/light.ts","../src/khr-lights-punctual/lights-punctual.ts","../src/khr-materials-anisotropy/anisotropy.ts","../src/khr-materials-anisotropy/materials-anisotropy.ts","../src/khr-materials-clearcoat/clearcoat.ts","../src/khr-materials-clearcoat/materials-clearcoat.ts","../src/khr-materials-emissive-strength/emissive-strength.ts","../src/khr-materials-emissive-strength/materials-emissive-strength.ts","../src/khr-materials-ior/ior.ts","../src/khr-materials-ior/materials-ior.ts","../src/khr-materials-iridescence/iridescence.ts","../src/khr-materials-iridescence/materials-iridescence.ts","../src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts","../src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts","../src/khr-materials-sheen/sheen.ts","../src/khr-materials-sheen/materials-sheen.ts","../src/khr-materials-specular/specular.ts","../src/khr-materials-specular/materials-specular.ts","../src/khr-materials-translucency/translucency.ts","../src/khr-materials-translucency/materials-translucency.ts","../src/khr-materials-transmission/transmission.ts","../src/khr-materials-transmission/materials-transmission.ts","../src/khr-materials-unlit/unlit.ts","../src/khr-materials-unlit/materials-unlit.ts","../src/khr-materials-variants/mapping.ts","../src/khr-materials-variants/mapping-list.ts","../src/khr-materials-variants/variant.ts","../src/khr-materials-variants/materials-variants.ts","../src/khr-materials-volume/volume.ts","../src/khr-materials-volume/materials-volume.ts","../src/khr-mesh-quantization/mesh-quantization.ts","../src/khr-texture-basisu/texture-basisu.ts","../src/khr-texture-transform/transform.ts","../src/khr-texture-transform/texture-transform.ts","../src/khr-xmp-json-ld/packet.ts","../src/khr-xmp-json-ld/xmp.ts","../src/extensions.ts"],"sourcesContent":["import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\r\n\r\ninterface IInstancedMesh extends IProperty {\r\n\tattributes: { [key: string]: Accessor };\r\n}\r\n\r\n// See BufferViewUsage in `writer-context.ts`.\r\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\r\n\r\n/**\r\n * # InstancedMesh\r\n *\r\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link MeshGPUInstancing}.\r\n */\r\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\r\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\r\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\r\n\tpublic declare propertyType: 'InstancedMesh';\r\n\tpublic declare parentTypes: [PropertyType.NODE];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\r\n\t\tthis.propertyType = 'InstancedMesh';\r\n\t\tthis.parentTypes = [PropertyType.NODE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: {} });\r\n\t}\r\n\r\n\t/** Returns an instance attribute as an {@link Accessor}. */\r\n\tpublic getAttribute(semantic: string): Accessor | null {\r\n\t\treturn this.getRefMap('attributes', semantic);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\r\n\t * instance count.\r\n\t */\r\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\r\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\r\n\t}\r\n\r\n\t/**\r\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\r\n\t * will be consistent with the order returned by {@link .listSemantics}().\r\n\t */\r\n\tpublic listAttributes(): Accessor[] {\r\n\t\treturn this.listRefMapValues('attributes');\r\n\t}\r\n\r\n\t/**\r\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\r\n\t * consistent with the order returned by {@link .listAttributes}().\r\n\t */\r\n\tpublic listSemantics(): string[] {\r\n\t\treturn this.listRefMapKeys('attributes');\r\n\t}\r\n}\r\n","export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\r\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\r\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\r\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\r\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\r\nexport const KHR_MATERIALS_ANISOTROPY = 'KHR_materials_anisotropy';\r\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\r\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\r\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\r\nexport const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';\r\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\r\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\r\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\r\nexport const KHR_MATERIALS_TRANSLUCENCY = 'KHR_materials_translucency';\r\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\r\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\r\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\r\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\r\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\r\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\r\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\r\nexport const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';\r\n","import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\r\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh';\r\n\r\nconst NAME = EXT_MESH_GPU_INSTANCING;\r\n\r\ninterface InstancedMeshDef {\r\n\tattributes: {\r\n\t\t[name: string]: number;\r\n\t};\r\n}\r\n\r\n/**\r\n * # MeshGPUInstancing\r\n *\r\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\r\n * prepares mesh data for efficient GPU instancing.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\r\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\r\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\r\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\r\n * batch.\r\n *\r\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\r\n * > is important to note that (1) GPU instancing and other optimizations are possible  and\r\n * > encouraged  even without this extension, and (2) other common meanings of the term\r\n * > \"instancing\" exist, distinct from this extension. See\r\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\r\n * > of the `EXT_mesh_gpu_instancing` specification._\r\n *\r\n * Properties:\r\n * - {@link InstancedMesh}\r\n *\r\n * ### Example\r\n *\r\n * The `MeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\r\n * which may be attached to any {@link Node} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MeshGPUInstancing } from '@gltf-transform/extensions';\r\n *\r\n * // Create standard mesh, node, and scene hierarchy.\r\n * // ...\r\n *\r\n * // Assign positions for each instance.\r\n * const batchPositions = doc.createAccessor('instance_positions')\r\n * \t.setArray(new Float32Array([\r\n * \t\t0, 0, 0,\r\n * \t\t1, 0, 0,\r\n * \t\t2, 0, 0,\r\n * \t]))\r\n * \t.setType(Accessor.Type.VEC3)\r\n * \t.setBuffer(buffer);\r\n *\r\n * // Assign IDs for each instance.\r\n * const batchIDs = doc.createAccessor('instance_ids')\r\n * \t.setArray(new Uint8Array([0, 1, 2]))\r\n * \t.setType(Accessor.Type.SCALAR)\r\n * \t.setBuffer(buffer);\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const batchExtension = document.createExtension(MeshGPUInstancing)\r\n * \t.setRequired(true);\r\n * const batch = batchExtension.createInstancedMesh()\r\n * \t.setAttribute('TRANSLATION', batchPositions)\r\n * \t.setAttribute('_ID', batchIDs);\r\n *\r\n * node\r\n * \t.setMesh(mesh)\r\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\r\n * ```\r\n *\r\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\r\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\r\n * be prefixed with an underscore (`_*`).\r\n */\r\nexport class MeshGPUInstancing extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly provideTypes = [PropertyType.NODE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\r\n\tpublic createInstancedMesh(): InstancedMesh {\r\n\t\treturn new InstancedMesh(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\r\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\r\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\r\n\t\t\tconst instancedMesh = this.createInstancedMesh();\r\n\r\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\r\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic prewrite(context: WriterContext): this {\r\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\r\n\t\t// views grouped by parent reference.\r\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\r\n\t\tfor (const prop of this.properties) {\r\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\r\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listNodes()\r\n\t\t\t.forEach((node) => {\r\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\r\n\t\t\t\tif (instancedMesh) {\r\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\r\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\r\n\r\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\r\n\r\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\r\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\r\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import type { GLTF, TypedArray } from '@gltf-transform/core';\r\n\r\nexport enum EncoderMethod {\r\n\tQUANTIZE = 'quantize',\r\n\tFILTER = 'filter',\r\n}\r\n\r\nexport interface MeshoptBufferExtension {\r\n\tfallback?: boolean;\r\n}\r\n\r\nexport enum MeshoptMode {\r\n\tATTRIBUTES = 'ATTRIBUTES',\r\n\tTRIANGLES = 'TRIANGLES',\r\n\tINDICES = 'INDICES',\r\n}\r\n\r\nexport enum MeshoptFilter {\r\n\tNONE = 'NONE',\r\n\tOCTAHEDRAL = 'OCTAHEDRAL',\r\n\tQUATERNION = 'QUATERNION',\r\n\tEXPONENTIAL = 'EXPONENTIAL',\r\n}\r\n\r\nexport interface MeshoptBufferViewExtension {\r\n\tbuffer: number;\r\n\tbyteOffset: number;\r\n\tbyteLength: number;\r\n\tbyteStride: number;\r\n\tcount: number;\r\n\tmode: MeshoptMode;\r\n\tfilter?: MeshoptFilter;\r\n}\r\n\r\n/**\r\n * When using filters, the accessor definition written to the file will not necessarily have the\r\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\r\n * output, so float32 input must be ignored.\r\n */\r\nexport interface PreparedAccessor {\r\n\tarray: TypedArray;\r\n\tbyteStride: number;\r\n\tnormalized: boolean;\r\n\tcomponentType: GLTF.AccessorComponentType;\r\n\tmin?: number[];\r\n\tmax?: number[];\r\n}\r\n","import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants';\r\nimport {\r\n\tAccessor,\r\n\tAnimationChannel,\r\n\tAnimationSampler,\r\n\tBufferUtils,\r\n\tDocument,\r\n\tGLTF,\r\n\tMathUtils,\r\n\tPrimitive,\r\n\tRoot,\r\n\tTypedArray,\r\n\tTypedArrayConstructor,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport type { MeshoptEncoder } from 'meshoptimizer';\r\n\r\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\r\nconst { normalize, denormalize } = MathUtils;\r\n\r\n/** Pre-processes array with required filters or padding. */\r\nexport function prepareAccessor(\r\n\taccessor: Accessor,\r\n\tencoder: typeof MeshoptEncoder,\r\n\tmode: MeshoptMode,\r\n\tfilterOptions: { filter: MeshoptFilter; bits?: number }\r\n): PreparedAccessor {\r\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\r\n\tconst result: PreparedAccessor = {\r\n\t\tarray: accessor.getArray()!,\r\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\r\n\t\tcomponentType: accessor.getComponentType(),\r\n\t\tnormalized: accessor.getNormalized(),\r\n\t};\r\n\r\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\r\n\r\n\tif (filter !== MeshoptFilter.NONE) {\r\n\t\tlet array = accessor.getNormalized() ? denormalizeArray(accessor) : new Float32Array(result.array);\r\n\r\n\t\tswitch (filter) {\r\n\t\t\tcase MeshoptFilter.EXPONENTIAL: //  K single-precision floating point values.\r\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\r\n\t\t\t\tresult.componentType = FLOAT;\r\n\t\t\t\tresult.normalized = false;\r\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: //  four 8- or 16-bit normalized values.\r\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\r\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\r\n\t\t\t\tresult.normalized = true;\r\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\r\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MeshoptFilter.QUATERNION: //  four 16-bit normalized values.\r\n\t\t\t\tresult.byteStride = 8;\r\n\t\t\t\tresult.componentType = SHORT;\r\n\t\t\t\tresult.normalized = true;\r\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Invalid filter.');\r\n\t\t}\r\n\r\n\t\tresult.min = accessor.getMin([]);\r\n\t\tresult.max = accessor.getMax([]);\r\n\t\tif (accessor.getNormalized()) {\r\n\t\t\tresult.min = result.min.map((v) => denormalize(v, accessor.getComponentType()));\r\n\t\t\tresult.max = result.max.map((v) => denormalize(v, accessor.getComponentType()));\r\n\t\t}\r\n\t\tif (result.normalized) {\r\n\t\t\tresult.min = result.min.map((v) => normalize(v, result.componentType));\r\n\t\t\tresult.max = result.max.map((v) => normalize(v, result.componentType));\r\n\t\t}\r\n\t} else if (result.byteStride % 4) {\r\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\r\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction denormalizeArray(attribute: Accessor): Float32Array {\r\n\tconst componentType = attribute.getComponentType();\r\n\tconst srcArray = attribute.getArray()!;\r\n\tconst dstArray = new Float32Array(srcArray.length);\r\n\tfor (let i = 0; i < srcArray.length; i++) {\r\n\t\tdstArray[i] = denormalize(srcArray[i], componentType);\r\n\t}\r\n\treturn dstArray;\r\n}\r\n\r\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\r\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\r\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\r\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\r\n\tconst elementCount = srcArray.length / elementSize;\r\n\r\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\r\n\r\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\r\n\t\tfor (let j = 0; j < elementSize; j++) {\r\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\r\n\t\t}\r\n\t}\r\n\r\n\treturn dstArray;\r\n}\r\n\r\n/** Pad normals with a .w component for octahedral encoding. */\r\nfunction padNormals(srcArray: Float32Array): Float32Array {\r\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\r\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\r\n\t\tdstArray[i * 4] = srcArray[i * 3];\r\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\r\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\r\n\t}\r\n\treturn dstArray;\r\n}\r\n\r\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\r\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\r\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\r\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\r\n\t\t});\r\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\r\n\t}\r\n\r\n\treturn MeshoptMode.ATTRIBUTES;\r\n}\r\n\r\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\r\n\tconst refs = doc\r\n\t\t.getGraph()\r\n\t\t.listParentEdges(accessor)\r\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\r\n\r\n\tfor (const ref of refs) {\r\n\t\tconst refName = ref.getName();\r\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\r\n\r\n\t\t// Indices.\r\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\r\n\r\n\t\t// Attributes.\r\n\t\t//\r\n\t\t// NOTES:\r\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\r\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\r\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\r\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\r\n\t\t//   quantization for these attributes.\r\n\t\tif (refName === 'attributes') {\r\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey === 'NORMAL') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\r\n\t\t\tif (refKey === 'TANGENT') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\r\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\r\n\t\t}\r\n\r\n\t\t// Animation.\r\n\t\tif (refName === 'output') {\r\n\t\t\tconst targetPath = getTargetPath(accessor);\r\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\r\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\r\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\r\n\t\t\treturn { filter: MeshoptFilter.NONE };\r\n\t\t}\r\n\r\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/489\r\n\t\tif (refName === 'input') return { filter: MeshoptFilter.NONE };\r\n\r\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\r\n\t}\r\n\r\n\treturn { filter: MeshoptFilter.NONE };\r\n}\r\n\r\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\r\n\tfor (const sampler of accessor.listParents()) {\r\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\r\n\t\tfor (const channel of sampler.listParents()) {\r\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\r\n\t\t\treturn channel.getTargetPath();\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n","import {\r\n\tAccessor,\r\n\tBuffer,\r\n\tBufferUtils,\r\n\tExtension,\r\n\tGLB_BUFFER,\r\n\tGLTF,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants';\r\nimport { EXT_MESHOPT_COMPRESSION } from '../constants';\r\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder';\r\nimport { isFallbackBuffer } from './decoder';\r\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\r\n\r\nconst NAME = EXT_MESHOPT_COMPRESSION;\r\n\r\ninterface EncoderOptions {\r\n\tmethod?: EncoderMethod;\r\n}\r\n\r\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\r\n\tmethod: EncoderMethod.QUANTIZE,\r\n};\r\n\r\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\r\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\r\n\r\n/**\r\n * # MeshoptCompression\r\n *\r\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)\r\n * provides compression and fast decoding for geometry, morph targets, and animations.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\r\n * library) offers a lightweight decoder with very fast runtime decompression, and is\r\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\r\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\r\n * large, other complementary compression methods should be used as well.\r\n *\r\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\r\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\r\n * pre-optimizes assets for this purpose  without this secondary compression, the size\r\n * reduction is considerably less.\r\n *\r\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\r\n * considerably faster than Draco decoding, neither compression method will improve runtime\r\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\r\n * vertex count or draw calls  not just compress it. Finally, be aware that Meshopt compression is\r\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\r\n * compression should generally be the last stage of an art workflow, and uncompressed original\r\n * files should be kept.\r\n *\r\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\r\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\r\n * writing files, and must be provided by the application. Compression may alternatively be applied\r\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { NodeIO } from '@gltf-transform/core';\r\n * import { MeshoptCompression } from '@gltf-transform/extensions';\r\n * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';\r\n *\r\n * await MeshoptDecoder.ready;\r\n * await MeshoptEncoder.ready;\r\n *\r\n * const io = new NodeIO()\r\n *\t.registerExtensions([MeshoptCompression])\r\n *\t.registerDependencies({\r\n *\t\t'meshopt.decoder': MeshoptDecoder,\r\n *\t\t'meshopt.encoder': MeshoptEncoder,\r\n *\t});\r\n *\r\n * // Read and decode.\r\n * const document = await io.read('compressed.glb');\r\n *\r\n * // Write and encode. (Medium, -c)\r\n * await document.transform(\r\n * \treorder({encoder: MeshoptEncoder}),\r\n * \tquantize()\r\n * );\r\n * document.createExtension(MeshoptCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.QUANTIZE });\r\n * await io.write('compressed-medium.glb', document);\r\n *\r\n * // Write and encode. (High, -cc)\r\n * await document.transform(\r\n * \treorder({encoder: MeshoptEncoder}),\r\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\r\n * );\r\n * document.createExtension(MeshoptCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.FILTER });\r\n * await io.write('compressed-high.glb', document);\r\n * ```\r\n */\r\nexport class MeshoptCompression extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\r\n\t/** @hidden */\r\n\tpublic readonly readDependencies = ['meshopt.decoder'];\r\n\t/** @hidden */\r\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\r\n\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\tpublic static readonly EncoderMethod = EncoderMethod;\r\n\r\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\r\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\r\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\r\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\r\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\r\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\r\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\r\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\r\n\r\n\t/** @hidden */\r\n\tpublic install(key: string, dependency: unknown): this {\r\n\t\tif (key === 'meshopt.decoder') {\r\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\r\n\t\t}\r\n\t\tif (key === 'meshopt.encoder') {\r\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\r\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\r\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\r\n\t *\r\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\r\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\r\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\r\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\r\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\r\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\r\n\t * \t`gltfpack -cc`.\r\n\t *\r\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\r\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\r\n\t * with both methods.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```ts\r\n\t * doc.createExtension(MeshoptCompression)\r\n\t * \t.setRequired(true)\r\n\t * \t.setEncoderOptions({\r\n\t * \t\tmethod: MeshoptCompression.EncoderMethod.QUANTIZE\r\n\t * \t});\r\n\t * ```\r\n\t */\r\n\tpublic setEncoderOptions(options: EncoderOptions): this {\r\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Decoding.\r\n\t */\r\n\r\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\r\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\r\n\t\tif (!this._decoder) {\r\n\t\t\tif (!this.isRequired()) return this;\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\r\n\t\t}\r\n\t\tif (!this._decoder.supported) {\r\n\t\t\tif (!this.isRequired()) return this;\r\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\r\n\t\t}\r\n\r\n\t\tif (propertyType === PropertyType.BUFFER) {\r\n\t\t\tthis._prereadBuffers(context);\r\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\r\n\t\t\tthis._prereadPrimitives(context);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @internal Decode buffer views. */\r\n\tprivate _prereadBuffers(context: ReaderContext): void {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\r\n\t\tviewDefs.forEach((viewDef, index) => {\r\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\r\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\r\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\r\n\t\t\tconst count = meshoptDef.count;\r\n\t\t\tconst stride = meshoptDef.byteStride;\r\n\t\t\tconst result = new Uint8Array(count * stride);\r\n\r\n\t\t\tconst bufferDef = jsonDoc.json.buffers![viewDef.buffer];\r\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\r\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\r\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\r\n\r\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\r\n\r\n\t\t\tcontext.bufferViews[index] = result;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Mark fallback buffers and replacements.\r\n\t *\r\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\r\n\t * after Buffers have been parsed.\r\n\t * @internal\r\n\t */\r\n\tprivate _prereadPrimitives(context: ReaderContext): void {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\r\n\r\n\t\t//\r\n\t\tviewDefs.forEach((viewDef) => {\r\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\r\n\r\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\r\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\r\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\r\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\r\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/** @hidden Removes Fallback buffers, if extension is required. */\r\n\tpublic read(_context: ReaderContext): this {\r\n\t\tif (!this.isRequired()) return this;\r\n\r\n\t\t// Replace fallback buffers.\r\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\r\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\r\n\t\t\t\tif (parent instanceof Accessor) {\r\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfallbackBuffer.dispose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Encoding.\r\n\t */\r\n\r\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\r\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\r\n\t\tif (propertyType === PropertyType.ACCESSOR) {\r\n\t\t\tthis._prewriteAccessors(context);\r\n\t\t} else if (propertyType === PropertyType.BUFFER) {\r\n\t\t\tthis._prewriteBuffers(context);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @internal Claims accessors that can be compressed. */\r\n\tprivate _prewriteAccessors(context: WriterContext): void {\r\n\t\tconst json = context.jsonDoc.json;\r\n\t\tconst encoder = this._encoder!;\r\n\t\tconst options = this._encoderOptions;\r\n\r\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\r\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\r\n\r\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\r\n\t\tthis._encoderBufferViews = {};\r\n\t\tthis._encoderBufferViewData = {};\r\n\t\tthis._encoderBufferViewAccessors = {};\r\n\r\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\r\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\r\n\t\t\t// Example: https://skfb.ly/6qAD8\r\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\r\n\r\n\t\t\tconst usage = context.getAccessorUsage(accessor);\r\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\r\n\t\t\tconst filter =\r\n\t\t\t\toptions.method === EncoderMethod.FILTER\r\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\r\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\r\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\r\n\t\t\tconst { array, byteStride } = preparedAccessor;\r\n\r\n\t\t\tconst buffer = accessor.getBuffer();\r\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\r\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\r\n\r\n\t\t\t// Buffer view grouping key.\r\n\t\t\tconst key = [usage, mode, filter.filter, byteStride, bufferIndex].join(':');\r\n\r\n\t\t\tlet bufferView = this._encoderBufferViews[key];\r\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\r\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\r\n\r\n\t\t\t// Write new buffer view, if needed.\r\n\t\t\tif (!bufferView || !bufferViewData) {\r\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\r\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\r\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\r\n\t\t\t\t\tbuffer: fallbackBufferIndex,\r\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\r\n\t\t\t\t\tbyteOffset: 0,\r\n\t\t\t\t\tbyteLength: 0,\r\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\r\n\t\t\t\t\textensions: {\r\n\t\t\t\t\t\t[NAME]: {\r\n\t\t\t\t\t\t\tbuffer: bufferIndex,\r\n\t\t\t\t\t\t\tbyteOffset: 0,\r\n\t\t\t\t\t\t\tbyteLength: 0,\r\n\t\t\t\t\t\t\tmode: mode,\r\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\r\n\t\t\t\t\t\t\tbyteStride: byteStride,\r\n\t\t\t\t\t\t\tcount: 0,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Write accessor.\r\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\r\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\r\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\r\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\r\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\r\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\r\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\r\n\t\t\tjson.accessors!.push(accessorDef);\r\n\t\t\tbufferViewAccessors.push(accessorDef);\r\n\r\n\t\t\t// Update buffer view.\r\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\r\n\t\t\tbufferView.byteLength += array.byteLength;\r\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\r\n\t\t}\r\n\t}\r\n\r\n\t/** @internal Writes compressed buffer views. */\r\n\tprivate _prewriteBuffers(context: WriterContext): void {\r\n\t\tconst encoder = this._encoder!;\r\n\r\n\t\tfor (const key in this._encoderBufferViews) {\r\n\t\t\tconst bufferView = this._encoderBufferViews[key];\r\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\r\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\r\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\r\n\r\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\r\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\r\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\r\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\r\n\r\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\r\n\r\n\t\t\tbufferViewData.length = 0;\r\n\t\t\tbufferViewData.push(compressedData);\r\n\t\t\totherBufferViews.push(compressedData);\r\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @hidden Puts encoded data into glTF output. */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tlet fallbackBufferByteOffset = 0;\r\n\r\n\t\t// Write final encoded buffer view properties.\r\n\t\tfor (const key in this._encoderBufferViews) {\r\n\t\t\tconst bufferView = this._encoderBufferViews[key];\r\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\r\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\r\n\r\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\r\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\r\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\r\n\t\t\t}\r\n\r\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\r\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\r\n\r\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\r\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\r\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\r\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\r\n\r\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\r\n\t\t}\r\n\r\n\t\t// Write final fallback buffer.\r\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\r\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\r\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\r\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\r\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\r\n\t\tfallbackBuffer.dispose();\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { EXT_MESHOPT_COMPRESSION } from '../constants';\r\nimport type { GLTF } from '@gltf-transform/core';\r\nimport type { MeshoptBufferExtension } from './constants';\r\n\r\n/**\r\n * Returns true for a fallback buffer, else false.\r\n *\r\n *   - All references to the fallback buffer must come from bufferViews that\r\n *     have a EXT_meshopt_compression extension specified.\r\n *   - No references to the fallback buffer may come from\r\n *     EXT_meshopt_compression extension JSON.\r\n */\r\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\r\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\r\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\r\n\treturn !!fallbackDef.fallback;\r\n}\r\n","import {\r\n\tBufferUtils,\r\n\tExtension,\r\n\tImageUtils,\r\n\tImageUtilsFormat,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n\tvec2,\r\n} from '@gltf-transform/core';\r\nimport { EXT_TEXTURE_WEBP } from '../constants';\r\n\r\nconst NAME = EXT_TEXTURE_WEBP;\r\n\r\nclass WEBPImageUtils implements ImageUtilsFormat {\r\n\tmatch(array: Uint8Array): boolean {\r\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\r\n\t}\r\n\tgetSize(array: Uint8Array): vec2 | null {\r\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\r\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\r\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\r\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\r\n\r\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\r\n\r\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\r\n\t\tlet offset = 12;\r\n\t\twhile (offset < view.byteLength) {\r\n\t\t\tconst chunkId = BufferUtils.decodeText(\r\n\t\t\t\tnew Uint8Array([\r\n\t\t\t\t\tview.getUint8(offset),\r\n\t\t\t\t\tview.getUint8(offset + 1),\r\n\t\t\t\t\tview.getUint8(offset + 2),\r\n\t\t\t\t\tview.getUint8(offset + 3),\r\n\t\t\t\t])\r\n\t\t\t);\r\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\r\n\t\t\tif (chunkId === 'VP8 ') {\r\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\r\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\r\n\t\t\t\treturn [width, height];\r\n\t\t\t} else if (chunkId === 'VP8L') {\r\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\r\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\r\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\r\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\r\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\r\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\r\n\t\t\t\treturn [width, height];\r\n\t\t\t}\r\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\tgetChannels(_buffer: Uint8Array): number {\r\n\t\treturn 4;\r\n\t}\r\n}\r\n\r\n/**\r\n * # TextureWebP\r\n *\r\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\r\n * enables WebP images for any material texture.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * WebP typically provides the minimal transmission\r\n * size, but [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\r\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\r\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\r\n * like Basis Universal, with the `KHR_texture_basisu` extension.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\r\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\r\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\r\n * specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TextureWebP } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const webpExtension = document.createExtension(TextureWebP)\r\n * \t.setRequired(true);\r\n * document.createTexture('MyWebPTexture')\r\n * \t.setMimeType('image/webp')\r\n * \t.setImage(fs.readFileSync('my-texture.webp'));\r\n * ```\r\n *\r\n * WebP conversion is not done automatically when adding the extension as shown above  you must\r\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\r\n *\r\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\r\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\r\n * JPEG image data.\r\n */\r\nexport class TextureWebP extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tpublic static register(): void {\r\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\r\n\t\ttextureDefs.forEach((textureDef) => {\r\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\r\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tpublic read(context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listTextures()\r\n\t\t\t.forEach((texture) => {\r\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\r\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\r\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\r\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\r\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\r\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\r\n\t\t\t\t\t\t\tdelete textureDef.source;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\r\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\r\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\r\n\r\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\r\n\r\nexport let decoderModule: DecoderModule;\r\n\r\n// Initialized when decoder module loads.\r\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\r\nlet DATA_TYPE: { [key: number]: DataType };\r\n\r\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\r\n\tconst buffer = new decoderModule.DecoderBuffer();\r\n\ttry {\r\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\r\n\r\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\r\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\r\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\r\n\t\t}\r\n\r\n\t\tconst dracoMesh = new decoderModule.Mesh();\r\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\r\n\r\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\r\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\r\n\t\t}\r\n\r\n\t\treturn dracoMesh;\r\n\t} finally {\r\n\t\tdecoderModule.destroy(buffer);\r\n\t}\r\n}\r\n\r\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\r\n\tconst numFaces = mesh.num_faces();\r\n\tconst numIndices = numFaces * 3;\r\n\r\n\tlet ptr: number;\r\n\tlet indices: Uint16Array | Uint32Array;\r\n\r\n\tif (mesh.num_points() <= 65534) {\r\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\r\n\t\tptr = decoderModule._malloc(byteLength);\r\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\r\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\r\n\t} else {\r\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\r\n\t\tptr = decoderModule._malloc(byteLength);\r\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\r\n\t}\r\n\r\n\tdecoderModule._free(ptr);\r\n\r\n\treturn indices;\r\n}\r\n\r\nexport function decodeAttribute(\r\n\tdecoder: Decoder,\r\n\tmesh: Mesh,\r\n\tattribute: Attribute,\r\n\taccessorDef: GLTF.IAccessor\r\n): TypedArray {\r\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\r\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\r\n\tconst numComponents = attribute.num_components();\r\n\tconst numPoints = mesh.num_points();\r\n\tconst numValues = numPoints * numComponents;\r\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\r\n\r\n\tconst ptr = decoderModule._malloc(byteLength);\r\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\r\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\r\n\tdecoderModule._free(ptr);\r\n\r\n\treturn array;\r\n}\r\n\r\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\r\n\tdecoderModule = _decoderModule;\r\n\r\n\tCOMPONENT_ARRAY = {\r\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\r\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\r\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\r\n\t};\r\n\r\n\tDATA_TYPE = {\r\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\r\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\r\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\r\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\r\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\r\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\r\n\t};\r\n}\r\n","import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\r\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\r\n\r\nexport let encoderModule: EncoderModule;\r\n\r\nexport enum EncoderMethod {\r\n\tEDGEBREAKER = 1,\r\n\tSEQUENTIAL = 0,\r\n}\r\n\r\nenum AttributeEnum {\r\n\tPOSITION = 'POSITION',\r\n\tNORMAL = 'NORMAL',\r\n\tCOLOR = 'COLOR',\r\n\tTEX_COORD = 'TEX_COORD',\r\n\tGENERIC = 'GENERIC',\r\n}\r\n\r\nconst DEFAULT_QUANTIZATION_BITS = {\r\n\t[AttributeEnum.POSITION]: 14,\r\n\t[AttributeEnum.NORMAL]: 10,\r\n\t[AttributeEnum.COLOR]: 8,\r\n\t[AttributeEnum.TEX_COORD]: 12,\r\n\t[AttributeEnum.GENERIC]: 12,\r\n};\r\n\r\nexport interface EncodedPrimitive {\r\n\tnumVertices: number;\r\n\tnumIndices: number;\r\n\tdata: Uint8Array;\r\n\tattributeIDs: { [key: string]: number };\r\n}\r\n\r\nexport interface EncoderOptions {\r\n\tdecodeSpeed?: number;\r\n\tencodeSpeed?: number;\r\n\tmethod?: EncoderMethod;\r\n\tquantizationBits?: { [key: string]: number };\r\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\r\n}\r\n\r\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\r\n\tdecodeSpeed: 5,\r\n\tencodeSpeed: 5,\r\n\tmethod: EncoderMethod.EDGEBREAKER,\r\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\r\n\tquantizationVolume: 'mesh',\r\n};\r\n\r\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\r\n\tencoderModule = _encoderModule;\r\n}\r\n\r\n/**\r\n * References:\r\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\r\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\r\n */\r\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\r\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\r\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\r\n\r\n\tconst encoder = new encoderModule.Encoder();\r\n\tconst builder = new encoderModule.MeshBuilder();\r\n\tconst mesh = new encoderModule.Mesh();\r\n\r\n\tconst attributeIDs: { [key: string]: number } = {};\r\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\r\n\r\n\tfor (const semantic of prim.listSemantics()) {\r\n\t\tconst attribute = prim.getAttribute(semantic)!;\r\n\t\tconst attributeEnum = getAttributeEnum(semantic);\r\n\t\tconst attributeID: number = addAttribute(\r\n\t\t\tbuilder,\r\n\t\t\tattribute.getComponentType(),\r\n\t\t\tmesh,\r\n\t\t\tencoderModule[attributeEnum],\r\n\t\t\tattribute.getCount(),\r\n\t\t\tattribute.getElementSize(),\r\n\t\t\tattribute.getArray()!\r\n\t\t);\r\n\r\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\r\n\r\n\t\tattributeIDs[semantic] = attributeID;\r\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\r\n\t\t\tencoder.SetAttributeQuantization(encoderModule[attributeEnum], options.quantizationBits[attributeEnum]);\r\n\t\t} else if (typeof options.quantizationVolume === 'object') {\r\n\t\t\tconst { quantizationVolume } = options;\r\n\t\t\tconst range = Math.max(\r\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\r\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\r\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2]\r\n\t\t\t);\r\n\t\t\tencoder.SetAttributeExplicitQuantization(\r\n\t\t\t\tencoderModule[attributeEnum],\r\n\t\t\t\toptions.quantizationBits[attributeEnum],\r\n\t\t\t\tattribute.getElementSize(),\r\n\t\t\t\tquantizationVolume.min,\r\n\t\t\t\trange\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid quantization volume state.');\r\n\t\t}\r\n\t}\r\n\r\n\tconst indices = prim.getIndices();\r\n\tif (!indices) throw new Error('Primitive must have indices.');\r\n\r\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\r\n\r\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\r\n\tencoder.SetTrackEncodedProperties(true);\r\n\r\n\t// Preserve vertex order for primitives with morph targets.\r\n\tif (options.method === EncoderMethod.SEQUENTIAL || prim.listTargets().length > 0) {\r\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\r\n\t} else {\r\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\r\n\t}\r\n\r\n\tconst byteLength = encoder.EncodeMeshToDracoBuffer(mesh, dracoBuffer);\r\n\tif (byteLength <= 0) throw new Error('Error applying Draco compression.');\r\n\r\n\tconst data = new Uint8Array(byteLength);\r\n\tfor (let i = 0; i < byteLength; ++i) {\r\n\t\tdata[i] = dracoBuffer.GetValue(i);\r\n\t}\r\n\r\n\tconst prevNumVertices = prim.getAttribute('POSITION')!.getCount();\r\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\r\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\r\n\r\n\tif (prim.listTargets().length > 0 && numVertices !== prevNumVertices) {\r\n\t\tthrow new Error(\r\n\t\t\t'Compression reduced vertex count unexpectedly, corrupting morph targets.' +\r\n\t\t\t\t' Applying the \"weld\" function before compression may resolve the issue.'\r\n\t\t);\r\n\t}\r\n\r\n\tencoderModule.destroy(dracoBuffer);\r\n\tencoderModule.destroy(mesh);\r\n\tencoderModule.destroy(builder);\r\n\tencoderModule.destroy(encoder);\r\n\r\n\treturn { numVertices, numIndices, data, attributeIDs };\r\n}\r\n\r\nfunction getAttributeEnum(semantic: string): AttributeEnum {\r\n\tif (semantic === 'POSITION') {\r\n\t\treturn AttributeEnum.POSITION;\r\n\t} else if (semantic === 'NORMAL') {\r\n\t\treturn AttributeEnum.NORMAL;\r\n\t} else if (semantic.startsWith('COLOR_')) {\r\n\t\treturn AttributeEnum.COLOR;\r\n\t} else if (semantic.startsWith('TEXCOORD_')) {\r\n\t\treturn AttributeEnum.TEX_COORD;\r\n\t}\r\n\treturn AttributeEnum.GENERIC;\r\n}\r\n\r\nfunction addAttribute(\r\n\tbuilder: MeshBuilder,\r\n\tcomponentType: GLTF.AccessorComponentType,\r\n\tmesh: Mesh,\r\n\tattribute: number,\r\n\tcount: number,\r\n\titemSize: number,\r\n\tarray: TypedArray\r\n): number {\r\n\tswitch (componentType) {\r\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\r\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.BYTE:\r\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\r\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.SHORT:\r\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\r\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.FLOAT:\r\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\r\n\t}\r\n}\r\n","import {\r\n\tAccessor,\r\n\tbbox,\r\n\tbounds,\r\n\tBufferUtils,\r\n\tDocument,\r\n\tExtension,\r\n\tGLB_BUFFER,\r\n\tPrimitive,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder';\r\nimport { EncodedPrimitive, encodeGeometry, EncoderMethod, EncoderOptions, initEncoderModule } from './encoder';\r\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\r\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\r\n\r\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\r\n\r\ninterface DracoPrimitiveExtension {\r\n\tbufferView: number;\r\n\tattributes: {\r\n\t\t[name: string]: number;\r\n\t};\r\n}\r\n\r\ninterface DracoWriterContext {\r\n\tprimitiveHashMap: Map<Primitive, string>;\r\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\r\n}\r\n\r\n/**\r\n * # DracoMeshCompression\r\n *\r\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\r\n * provides advanced compression for mesh geometry.\r\n *\r\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\r\n * in many cases. When animation or textures are large, other complementary compression methods\r\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\r\n * size savings.\r\n *\r\n * Be aware that decompression happens before uploading to the GPU  this will add some latency to\r\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\r\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\r\n * or draw calls  not just compress it. Finally, be aware that Draco compression is lossy:\r\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\r\n * compression should generally be the last stage of an art workflow, and uncompressed original\r\n * files should be kept.\r\n *\r\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\r\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\r\n * and must be provided by the application.\r\n *\r\n * ### Encoding options\r\n *\r\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\r\n * edgebreaker method will give higher compression in general, but changes the\r\n * order of the model's vertices. To preserve index order, use sequential\r\n * compression. When a mesh uses morph targets, or a high decoding speed is\r\n * selected, sequential compression will automatically be chosen.\r\n *\r\n * Both speed options affect the encoder's choice of algorithms. For example, a\r\n * requirement for fast decoding may prevent the encoder from using the best\r\n * compression methods even if the encoding speed is set to 0. In general, the\r\n * faster of the two options limits the choice of features that can be used by the\r\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\r\n * the encoder to choose the optimal method out of the available features for the\r\n * given --decodeSpeed.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { NodeIO } from '@gltf-transform/core';\r\n * import { DracoMeshCompression } from '@gltf-transform/extensions';\r\n *\r\n * import draco3d from 'draco3dgltf';\r\n *\r\n * // ...\r\n *\r\n * const io = new NodeIO()\r\n *\t.registerExtensions([DracoMeshCompression])\r\n *\t.registerDependencies({\r\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\r\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\r\n *\t});\r\n *\r\n * // Read and decode.\r\n * const document = await io.read('compressed.glb');\r\n *\r\n * // Write and encode.\r\n * document.createExtension(DracoMeshCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({\r\n * \t\tmethod: DracoMeshCompression.EncoderMethod.EDGEBREAKER,\r\n * \t\tencodeSpeed: 5,\r\n * \t\tdecodeSpeed: 5,\r\n * \t});\r\n * await io.write('compressed.glb', document);\r\n * ```\r\n */\r\nexport class DracoMeshCompression extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\r\n\t/** @hidden */\r\n\tpublic readonly readDependencies = ['draco3d.decoder'];\r\n\t/** @hidden */\r\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\r\n\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/**\r\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\r\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\r\n\t */\r\n\tpublic static readonly EncoderMethod = EncoderMethod;\r\n\r\n\tprivate _decoderModule: DecoderModule | null = null;\r\n\tprivate _encoderModule: EncoderModule | null = null;\r\n\tprivate _encoderOptions: EncoderOptions = {};\r\n\r\n\t/** @hidden */\r\n\tpublic install(key: string, dependency: unknown): this {\r\n\t\tif (key === 'draco3d.decoder') {\r\n\t\t\tthis._decoderModule = dependency as DecoderModule;\r\n\t\t\tinitDecoderModule(this._decoderModule);\r\n\t\t}\r\n\t\tif (key === 'draco3d.encoder') {\r\n\t\t\tthis._encoderModule = dependency as EncoderModule;\r\n\t\t\tinitEncoderModule(this._encoderModule);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets Draco compression options. Compression does not take effect until the Document is\r\n\t * written with an I/O class.\r\n\t *\r\n\t * Defaults:\r\n\t * ```\r\n\t * decodeSpeed?: number = 5;\r\n\t * encodeSpeed?: number = 5;\r\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\r\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\r\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\r\n\t * ```\r\n\t */\r\n\tpublic setEncoderOptions(options: EncoderOptions): this {\r\n\t\tthis._encoderOptions = options;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tif (!this._decoderModule) {\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\r\n\t\t}\r\n\r\n\t\tconst logger = this.document.getLogger();\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\r\n\r\n\t\ttry {\r\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\r\n\t\t\tfor (const meshDef of meshDefs) {\r\n\t\t\t\tfor (const primDef of meshDef.primitives) {\r\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\r\n\r\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\r\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\r\n\r\n\t\t\t\t\tif (!dracoMesh || !decoder) {\r\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\r\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\r\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\r\n\t\t\t\t\t\tconst resource = bufferDef.uri\r\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\r\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\r\n\r\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\r\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\r\n\r\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\r\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\r\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\r\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Attributes.\r\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\r\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\r\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\r\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\r\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\r\n\t\t\t\t\tif (primDef.indices !== undefined) {\r\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\r\n\t\t\t\tthis._decoderModule.destroy(decoder);\r\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(_context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\r\n\t\tif (!this._encoderModule) {\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\r\n\t\t}\r\n\r\n\t\tconst logger = this.document.getLogger();\r\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\r\n\r\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\r\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\r\n\r\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\r\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\r\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\r\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\r\n\t\t\t} else {\r\n\t\t\t\tquantizationVolume = bounds(this.document.getRoot().listScenes().pop()!);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\r\n\t\t\tconst primHash = primitiveHashMap.get(prim);\r\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\r\n\r\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\r\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\r\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\r\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\r\n\r\n\t\t\t// Create a new EncodedPrimitive.\r\n\t\t\tconst encodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\r\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\r\n\r\n\t\t\t// Create indices definition, update count.\r\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\r\n\t\t\tindicesDef.count = encodedPrim.numIndices;\r\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\r\n\t\t\taccessorDefs.push(indicesDef);\r\n\r\n\t\t\t// Create attribute definitions, update count.\r\n\t\t\tfor (const semantic of prim.listSemantics()) {\r\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\r\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\r\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\r\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\r\n\t\t\t\taccessorDefs.push(attributeDef);\r\n\t\t\t}\r\n\r\n\t\t\t// Map compressed buffer view to a Buffer.\r\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\r\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\r\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\r\n\t\t}\r\n\r\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\r\n\r\n\t\tcontext.extensionData[NAME] = {\r\n\t\t\tprimitiveHashMap,\r\n\t\t\tprimitiveEncodingMap,\r\n\t\t} as DracoWriterContext;\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\r\n\r\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\r\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\r\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\r\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\r\n\t\t\t\tconst primDef = meshDef.primitives[i];\r\n\r\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\r\n\t\t\t\tif (!primHash) continue;\r\n\r\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\r\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\r\n\t\t\t\tprimDef.extensions[NAME] = {\r\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\r\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Omit the extension if nothing was compressed.\r\n\t\tif (!dracoContext.primitiveHashMap.size) {\r\n\t\t\tconst json = context.jsonDoc.json;\r\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\r\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\r\n * fail, and would break assumptions required for compression, this function will throw an error.\r\n */\r\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\r\n\tconst logger = doc.getLogger();\r\n\tconst included = new Set<Primitive>();\r\n\tconst excluded = new Set<Primitive>();\r\n\r\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\r\n\tfor (const mesh of doc.getRoot().listMeshes()) {\r\n\t\tfor (const prim of mesh.listPrimitives()) {\r\n\t\t\tif (!prim.getIndices()) {\r\n\t\t\t\texcluded.add(prim);\r\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-indexed primitive.`);\r\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\r\n\t\t\t\texcluded.add(prim);\r\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-TRIANGLES primitive.`);\r\n\t\t\t} else {\r\n\t\t\t\tincluded.add(prim);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Create an Accessor->index mapping.\r\n\tconst accessors = doc.getRoot().listAccessors();\r\n\tconst accessorIndices = new Map<Accessor, number>();\r\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\r\n\r\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\r\n\t// compressed Primitive and Accessor to this hash key.\r\n\tconst includedAccessors = new Map<Accessor, string>();\r\n\tconst includedHashKeys = new Set<string>();\r\n\tconst primToHashKey = new Map<Primitive, string>();\r\n\tfor (const prim of Array.from(included)) {\r\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\r\n\r\n\t\t// If accessors of an identical primitive have already been checked, we're done.\r\n\t\tif (includedHashKeys.has(hashKey)) {\r\n\t\t\tprimToHashKey.set(prim, hashKey);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\r\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\r\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\r\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\r\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\r\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\t\tconst dstIndices = indices.clone();\r\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\r\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\r\n\t\t}\r\n\t\tfor (const attribute of prim.listAttributes()) {\r\n\t\t\tif (includedAccessors.has(attribute)) {\r\n\t\t\t\tconst dstAttribute = attribute.clone();\r\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\r\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// With conflicts resolved, compute the hash key again.\r\n\t\thashKey = createHashKey(prim, accessorIndices);\r\n\r\n\t\t// Commit the primitive and its accessors to the hash key.\r\n\t\tincludedHashKeys.add(hashKey);\r\n\t\tprimToHashKey.set(prim, hashKey);\r\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\r\n\t\tfor (const attribute of prim.listAttributes()) {\r\n\t\t\tincludedAccessors.set(attribute, hashKey);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\r\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\r\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\r\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\r\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\r\n\tfor (const prim of Array.from(included)) {\r\n\t\tconst hashKey = primToHashKey.get(prim);\r\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\tif (\r\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\r\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\r\n\t\t) {\r\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\r\n\tfor (const prim of Array.from(excluded)) {\r\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\r\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\r\n\t\t}\r\n\t}\r\n\r\n\treturn primToHashKey;\r\n}\r\n\r\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\r\n\tconst hashElements = [];\r\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\r\n\thashElements.push(indexMap.get(indices));\r\n\tfor (const attribute of prim.listAttributes()) {\r\n\t\thashElements.push(indexMap.get(attribute));\r\n\t}\r\n\r\n\treturn hashElements.sort().join('|');\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\r\nimport { ColorUtils } from '@gltf-transform/core';\r\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\r\n\r\ninterface ILight extends IProperty {\r\n\tcolor: vec3;\r\n\tintensity: number;\r\n\ttype: PunctualLightType;\r\n\trange: number | null;\r\n\tinnerConeAngle: number;\r\n\touterConeAngle: number;\r\n}\r\n\r\ntype PunctualLightType = 'point' | 'spot' | 'directional';\r\n\r\n/**\r\n * # Light\r\n *\r\n * Defines a light attached to a {@link Node}. See {@link LightsPunctual}.\r\n */\r\nexport class Light extends ExtensionProperty<ILight> {\r\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\r\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\r\n\tpublic declare propertyType: 'Light';\r\n\tpublic declare parentTypes: [PropertyType.NODE];\r\n\r\n\t/**********************************************************************************************\r\n\t * CONSTANTS.\r\n\t */\r\n\r\n\tpublic static Type: Record<string, PunctualLightType> = {\r\n\t\tPOINT: 'point',\r\n\t\tSPOT: 'spot',\r\n\t\tDIRECTIONAL: 'directional',\r\n\t};\r\n\r\n\t/**********************************************************************************************\r\n\t * INSTANCE.\r\n\t */\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\r\n\t\tthis.propertyType = 'Light';\r\n\t\tthis.parentTypes = [PropertyType.NODE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ILight> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tcolor: [1, 1, 1] as vec3,\r\n\t\t\tintensity: 1,\r\n\t\t\ttype: Light.Type.POINT,\r\n\t\t\trange: null,\r\n\t\t\tinnerConeAngle: 0,\r\n\t\t\touterConeAngle: Math.PI / 4,\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * COLOR.\r\n\t */\r\n\r\n\t/** Light color; Linear-sRGB components. */\r\n\tpublic getColor(): vec3 {\r\n\t\treturn this.get('color');\r\n\t}\r\n\r\n\t/** Light color; Linear-sRGB components. */\r\n\tpublic setColor(color: vec3): this {\r\n\t\treturn this.set('color', color);\r\n\t}\r\n\r\n\t/** Light color; sRGB hexadecimal color. */\r\n\tpublic getColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getColor());\r\n\t}\r\n\r\n\t/** Light color; sRGB hexadecimal color. */\r\n\tpublic setColorHex(hex: number): this {\r\n\t\tconst color = this.getColor().slice() as vec3;\r\n\t\tColorUtils.hexToFactor(hex, color);\r\n\t\treturn this.setColor(color);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * INTENSITY.\r\n\t */\r\n\r\n\t/**\r\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\r\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\r\n\t */\r\n\tpublic getIntensity(): number {\r\n\t\treturn this.get('intensity');\r\n\t}\r\n\r\n\t/**\r\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\r\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\r\n\t */\r\n\tpublic setIntensity(intensity: number): this {\r\n\t\treturn this.set('intensity', intensity);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * TYPE.\r\n\t */\r\n\r\n\t/** Type. */\r\n\tpublic getType(): PunctualLightType {\r\n\t\treturn this.get('type');\r\n\t}\r\n\r\n\t/** Type. */\r\n\tpublic setType(type: PunctualLightType): this {\r\n\t\treturn this.set('type', type);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * RANGE.\r\n\t */\r\n\r\n\t/**\r\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\r\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\r\n\t * is assumed to be infinite.\r\n\t */\r\n\tpublic getRange(): number | null {\r\n\t\treturn this.get('range');\r\n\t}\r\n\r\n\t/**\r\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\r\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\r\n\t * is assumed to be infinite.\r\n\t */\r\n\tpublic setRange(range: number | null): this {\r\n\t\treturn this.set('range', range);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * SPOT LIGHT PROPERTIES\r\n\t */\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\r\n\t * < outerConeAngle.\r\n\t */\r\n\tpublic getInnerConeAngle(): number {\r\n\t\treturn this.get('innerConeAngle');\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\r\n\t * < outerConeAngle.\r\n\t */\r\n\tpublic setInnerConeAngle(angle: number): this {\r\n\t\treturn this.set('innerConeAngle', angle);\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\r\n\t *  PI / 2.0.\r\n\t */\r\n\tpublic getOuterConeAngle(): number {\r\n\t\treturn this.get('outerConeAngle');\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\r\n\t *  PI / 2.0.\r\n\t */\r\n\tpublic setOuterConeAngle(angle: number): this {\r\n\t\treturn this.set('outerConeAngle', angle);\r\n\t}\r\n}\r\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\r\nimport { Light } from './light';\r\n\r\nconst NAME = KHR_LIGHTS_PUNCTUAL;\r\n\r\ninterface LightsPunctualRootDef {\r\n\tlights?: LightDef[];\r\n}\r\n\r\ninterface LightsPunctualNodeDef {\r\n\tlight: number;\r\n}\r\n\r\ninterface LightDef {\r\n\tname?: string;\r\n\tcolor?: vec3;\r\n\tintensity?: number;\r\n\trange?: number;\r\n\ttype: 'spot' | 'point' | 'directional';\r\n\tspot?: {\r\n\t\tinnerConeAngle?: number;\r\n\t\touterConeAngle?: number;\r\n\t};\r\n}\r\n\r\n/**\r\n * # LightsPunctual\r\n *\r\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\r\n * spot.\r\n *\r\n * Punctual lights are parameterized, infinitely small points that emit light in\r\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\r\n * of that node.\r\n *\r\n * Properties:\r\n * - {@link Light}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { LightsPunctual, Light, LightType } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const lightsExtension = document.createExtension(LightsPunctual);\r\n *\r\n * // Create a Light property.\r\n * const light = lightsExtension.createLight()\r\n *\t.setType(LightType.POINT)\r\n *\t.setIntensity(2.0)\r\n *\t.setColor([1.0, 0.0, 0.0]);\r\n *\r\n * // Attach the property to a Material.\r\n * node.setExtension('KHR_lights_punctual', light);\r\n * ```\r\n */\r\nexport class LightsPunctual extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\r\n\tpublic createLight(name = ''): Light {\r\n\t\treturn new Light(this.document.getGraph(), name);\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\r\n\r\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\r\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\r\n\t\tconst lights = lightDefs.map((lightDef) => {\r\n\t\t\tconst light = this.createLight()\r\n\t\t\t\t.setName(lightDef.name || '')\r\n\t\t\t\t.setType(lightDef.type);\r\n\r\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\r\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\r\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\r\n\r\n\t\t\tif (lightDef.spot?.innerConeAngle !== undefined) {\r\n\t\t\t\tlight.setInnerConeAngle(lightDef.spot.innerConeAngle);\r\n\t\t\t}\r\n\t\t\tif (lightDef.spot?.outerConeAngle !== undefined) {\r\n\t\t\t\tlight.setOuterConeAngle(lightDef.spot.outerConeAngle);\r\n\t\t\t}\r\n\r\n\t\t\treturn light;\r\n\t\t});\r\n\r\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\r\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\r\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\r\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (this.properties.size === 0) return this;\r\n\r\n\t\tconst lightDefs = [];\r\n\t\tconst lightIndexMap = new Map<Light, number>();\r\n\r\n\t\tfor (const property of this.properties) {\r\n\t\t\tconst light = property as Light;\r\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\r\n\r\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\r\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\r\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\r\n\r\n\t\t\tif (light.getName()) lightDef.name = light.getName();\r\n\r\n\t\t\tif (light.getType() === Light.Type.SPOT) {\r\n\t\t\t\tlightDef.spot = {\r\n\t\t\t\t\tinnerConeAngle: light.getInnerConeAngle(),\r\n\t\t\t\t\touterConeAngle: light.getOuterConeAngle(),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlightDefs.push(lightDef);\r\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\r\n\t\t}\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listNodes()\r\n\t\t\t.forEach((node) => {\r\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\r\n\t\t\t\tif (light) {\r\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\r\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\r\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\r\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n  vec3\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_ANISOTROPY } from '../constants';\r\n\r\n\r\ninterface IAnisotropy extends IProperty {\r\n\tanisotropy: number;\r\n\tanisotropyTexture: Texture;\r\n\tanisotropyTextureInfo: TextureInfo;\r\n\r\n\tanisotropyDirection: vec3;\r\n\tanisotropyDirectionTexture: Texture;\r\n\tanisotropyDirectionTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B } = TextureChannel;\r\n\r\n/**\r\n * # Anisotropy\r\n *\r\n * Defines anisotropy for a PBR material. See {@link MaterialsAnisotropy}.\r\n */\r\nexport class Anisotropy extends ExtensionProperty<IAnisotropy> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_ANISOTROPY;\r\n\tpublic declare propertyType: 'Anisotropy';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n  protected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_ANISOTROPY;\r\n\t\tthis.propertyType = 'Anisotropy';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n  protected getDefaults(): Nullable<IAnisotropy> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tanisotropy: 0,\r\n\t\t\tanisotropyTexture: null,\r\n\t\t\tanisotropyTextureInfo: new TextureInfo(this.graph, 'anisotropyTextureInfo'),\r\n\r\n\t\t\tanisotropyDirection: [1.0, 0.0, 0.0] as vec3,\r\n\t\t\tanisotropyDirectionTexture: null,\r\n\t\t\tanisotropyDirectionTextureInfo: new TextureInfo(this.graph, 'anisotropyDirectionTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Anisotropy.\r\n\t */\r\n\r\n\t/** Anisotropy; See {@link getAnisotropyTexture. */\r\n\tpublic getAnisotropy(): number {\r\n    return this.get('anisotropy');\r\n  }\r\n\r\n\t/** Anisotropy; See {@link setAnisotropyTexture.}. */\r\n\tpublic setAnisotropy(val: number): this {\r\n    return this.set('anisotropy', val);\r\n\t}\r\n\r\n\t/**\r\n\t * Anisotropy texture.\r\n\t */\r\n\tpublic getAnisotropyTexture(): Texture | null {\r\n\t\treturn this.getRef('anisotropyTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its anisotropy texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getAnisotropyTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('anisotropyTexture') ? this.getRef('anisotropyTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets anisotropy texture. See {@link getAnisotropyTexture}. */\r\n\tpublic setAnisotropyTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('anisotropyTexture', texture, { channels: R });\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Anisotropy direction.\r\n\t */\r\n\r\n\t/** Anisotropy direction; See {@link getAnisotropyDirectionTexture}. */\r\n\tpublic getAnisotropyDirection(): vec3 {\r\n\t\treturn this.get('anisotropyDirection');\r\n  }\r\n\r\n\t/** Anisotropy direction; See {@link setAnisotropyDirectionTexture}. */\r\n\tpublic setAnisotropyDirection(direction: vec3): this {\r\n\t\treturn this.set('anisotropyDirection', direction);\r\n\t}\r\n\r\n\t/**\r\n\t * Anisotropy direction texture.\r\n\t */\r\n\tpublic getAnisotropyDirectionTexture(): Texture | null {\r\n\t\treturn this.getRef('anisotropyDirectionTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its anisotropy direction texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getAnisotropyDirectionTextureInfo(): TextureInfo | null {\r\n    return this.getRef('anisotropyDirectionTexture') ? this.getRef('anisotropyDirectionTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets anisotropy direction texture. See {@link getAnisotropyDirectionTexture}. */\r\n\tpublic setAnisotropyDirectionTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('anisotropyDirectionTexture', texture, { channels: G });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_ANISOTROPY} from '../constants';\r\nimport { Anisotropy } from './anisotropy';\r\n\r\nconst NAME = KHR_MATERIALS_ANISOTROPY;\r\n\r\ninterface AnisotropyDef {\r\n\tanisotropy?: number;\r\n\tanisotropyDirection?: vec3;\r\n\tanisotropyTexture?: GLTF.ITextureInfo;\r\n\tanisotropyDirectionTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsAnisotropy\r\n */\r\nexport class MaterialsAnisotropy extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\tpublic createAnisotropy(): Anisotropy {\r\n\t\treturn new Anisotropy(this.document.getGraph());\r\n\t}\r\n\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst anisotropy = this.createAnisotropy();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, anisotropy);\r\n\r\n\t\t\t\tconst anisotropyDef = materialDef.extensions[NAME] as AnisotropyDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (anisotropyDef.anisotropy !== undefined) {\r\n\t\t\t\t\tanisotropy.setAnisotropy(anisotropyDef.anisotropy);\r\n\t\t\t\t}\r\n\t\t\t\tif (anisotropyDef.anisotropyDirection !== undefined) {\r\n\t\t\t\t\tanisotropy.setAnisotropyDirection(\r\n\t\t\t\t\t\tanisotropyDef.anisotropyDirection\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (anisotropyDef.anisotropyTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = anisotropyDef.anisotropyTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tanisotropy.setAnisotropyTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(anisotropy.getAnisotropyTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (anisotropyDef.anisotropyDirectionTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = anisotropyDef.anisotropyDirectionTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tanisotropy.setAnisotropyDirectionTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(\r\n\t\t\t\t\t\tanisotropy.getAnisotropyDirectionTextureInfo()!,\r\n\t\t\t\t\t\ttextureInfoDef\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst anisotropy = material.getExtension<Anisotropy>(NAME);\r\n\t\t\t\tif (anisotropy) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst anisotropyDef = materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tanisotropy: anisotropy.getAnisotropy(),\r\n\t\t\t\t\t\tanisotropyDirection: anisotropy.getAnisotropyDirection(),\r\n\t\t\t\t\t} as AnisotropyDef;\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (anisotropy.getAnisotropyTexture()) {\r\n\t\t\t\t\t\tconst texture = anisotropy.getAnisotropyTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = anisotropy.getAnisotropyTextureInfo()!;\r\n\t\t\t\t\t\tanisotropyDef.anisotropyTexture\r\n\t\t\t\t\t\t\t= context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (anisotropy.getAnisotropyDirectionTexture()) {\r\n\t\t\t\t\t\tconst texture = anisotropy.getAnisotropyDirectionTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = anisotropy.getAnisotropyDirectionTextureInfo()!;\r\n\t\t\t\t\t\tanisotropyDef.anisotropyDirectionTexture\r\n\t\t\t\t\t\t\t= context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\r\n\r\ninterface IClearcoat extends IProperty {\r\n\tclearcoatFactor: number;\r\n\tclearcoatTexture: Texture;\r\n\tclearcoatTextureInfo: TextureInfo;\r\n\r\n\tclearcoatRoughnessFactor: number;\r\n\tclearcoatRoughnessTexture: Texture;\r\n\tclearcoatRoughnessTextureInfo: TextureInfo;\r\n\r\n\tclearcoatNormalScale: number;\r\n\tclearcoatNormalTexture: Texture;\r\n\tclearcoatNormalTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B } = TextureChannel;\r\n\r\n/**\r\n * # Clearcoat\r\n *\r\n * Defines clear coat for a PBR material. See {@link MaterialsClearcoat}.\r\n */\r\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\r\n\tpublic declare propertyType: 'Clearcoat';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\r\n\t\tthis.propertyType = 'Clearcoat';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IClearcoat> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tclearcoatFactor: 0,\r\n\t\t\tclearcoatTexture: null,\r\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\r\n\r\n\t\t\tclearcoatRoughnessFactor: 0,\r\n\t\t\tclearcoatRoughnessTexture: null,\r\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\r\n\r\n\t\t\tclearcoatNormalScale: 1,\r\n\t\t\tclearcoatNormalTexture: null,\r\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat.\r\n\t */\r\n\r\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\r\n\tpublic getClearcoatFactor(): number {\r\n\t\treturn this.get('clearcoatFactor');\r\n\t}\r\n\r\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\r\n\tpublic setClearcoatFactor(factor: number): this {\r\n\t\treturn this.set('clearcoatFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\r\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\r\n\t * normal map properties.\r\n\t */\r\n\tpublic getClearcoatTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat texture. See {@link getClearcoatTexture}. */\r\n\tpublic setClearcoatTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat roughness.\r\n\t */\r\n\r\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic getClearcoatRoughnessFactor(): number {\r\n\t\treturn this.get('clearcoatRoughnessFactor');\r\n\t}\r\n\r\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\r\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatRoughnessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat roughness texture. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat normals.\r\n\t */\r\n\r\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\r\n\tpublic getClearcoatNormalScale(): number {\r\n\t\treturn this.get('clearcoatNormalScale');\r\n\t}\r\n\r\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\r\n\tpublic setClearcoatNormalScale(scale: number): this {\r\n\t\treturn this.set('clearcoatNormalScale', scale);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat normal map. Independent of the material base layer normal map.\r\n\t */\r\n\tpublic getClearcoatNormalTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatNormalTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat normal texture. See {@link getClearcoatNormalTexture}. */\r\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\r\nimport { Clearcoat } from './clearcoat';\r\n\r\nconst NAME = KHR_MATERIALS_CLEARCOAT;\r\n\r\ninterface ClearcoatDef {\r\n\tclearcoatFactor?: number;\r\n\tclearcoatRoughnessFactor?: number;\r\n\tclearcoatTexture?: GLTF.ITextureInfo;\r\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\r\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsClearcoat\r\n *\r\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)\r\n * defines a clear coating on a glTF PBR material.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\r\n *\r\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\r\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\r\n *\r\n * A clear coat is a common technique used in Physically-Based\r\n * Rendering for a protective layer applied to a base material.\r\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\r\n *\r\n * Properties:\r\n * - {@link Clearcoat}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const clearcoatExtension = document.createExtension(MaterialsClearcoat);\r\n *\r\n * // Create Clearcoat property.\r\n * const clearcoat = clearcoatExtension.createClearcoat()\r\n *\t.setClearcoatFactor(1.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\r\n * ```\r\n */\r\nexport class MaterialsClearcoat extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\r\n\tpublic createClearcoat(): Clearcoat {\r\n\t\treturn new Clearcoat(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst clearcoat = this.createClearcoat();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\r\n\r\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\r\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\r\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\r\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\r\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\r\n\t\t\t\tif (clearcoat) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\r\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\r\n\t\t\t\t\t} as ClearcoatDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\r\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\r\n\r\ninterface IEmissiveStrength extends IProperty {\r\n\temissiveStrength: number;\r\n}\r\n\r\n/**\r\n * # EmissiveStrength\r\n *\r\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\r\n * (HDR) emissive materials. See {@link MaterialsEmissiveStrength}.\r\n */\r\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\tpublic declare propertyType: 'EmissiveStrength';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\t\tthis.propertyType = 'EmissiveStrength';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * EmissiveStrength.\r\n\t */\r\n\r\n\t/** EmissiveStrength. */\r\n\tpublic getEmissiveStrength(): number {\r\n\t\treturn this.get('emissiveStrength');\r\n\t}\r\n\r\n\t/** EmissiveStrength. */\r\n\tpublic setEmissiveStrength(strength: number): this {\r\n\t\treturn this.set('emissiveStrength', strength);\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\r\nimport { EmissiveStrength } from './emissive-strength';\r\n\r\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\r\ninterface EmissiveStrengthDef {\r\n\temissiveStrength?: number;\r\n}\r\n\r\n/**\r\n * # MaterialsEmissiveStrength\r\n *\r\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\r\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\r\n *\r\n * [[include:UNRATIFIED_EXTENSIONS_NOTE.md]]\r\n *\r\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\r\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\r\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\r\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\r\n *\r\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\r\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\r\n * given arbitrarily high values.\r\n *\r\n * For implementations where a physical light unit is needed, the units for the multiplicative\r\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\r\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\r\n * emissive factor of 1.0 results in a fully exposed pixel.\r\n *\r\n * Properties:\r\n * - {@link EmissiveStrength}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const emissiveStrengthExtension = document.createExtension(MaterialsEmissiveStrength);\r\n *\r\n * // Create EmissiveStrength property.\r\n * const emissiveStrength = emissiveStrengthExtension\r\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\r\n * ```\r\n */\r\nexport class MaterialsEmissiveStrength extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\r\n\tpublic createEmissiveStrength(): EmissiveStrength {\r\n\t\treturn new EmissiveStrength(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\r\n\r\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\r\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\r\n\t\t\t\tif (emissiveStrength) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\r\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\r\n\t\t\t\t\t} as EmissiveStrengthDef;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IOR } from '../constants';\r\n\r\ninterface IIOR extends IProperty {\r\n\tior: number;\r\n}\r\n\r\n/**\r\n * # IOR\r\n *\r\n * Defines index of refraction for a PBR {@link Material}. See {@link MaterialsIOR}.\r\n */\r\nexport class IOR extends ExtensionProperty<IIOR> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\r\n\tpublic declare propertyType: 'IOR';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\r\n\t\tthis.propertyType = 'IOR';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IIOR> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 0 });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * IOR.\r\n\t */\r\n\r\n\t/** IOR. */\r\n\tpublic getIOR(): number {\r\n\t\treturn this.get('ior');\r\n\t}\r\n\r\n\t/** IOR. */\r\n\tpublic setIOR(ior: number): this {\r\n\t\treturn this.set('ior', ior);\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IOR } from '../constants';\r\nimport { IOR } from './ior';\r\n\r\nconst NAME = KHR_MATERIALS_IOR;\r\n\r\ninterface IORDef {\r\n\tior?: number;\r\n}\r\n\r\n/**\r\n * # MaterialsIOR\r\n *\r\n * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)\r\n * defines index of refraction on a glTF PBR material.\r\n *\r\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\r\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\r\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\r\n * refraction to a certain value.\r\n *\r\n * Properties:\r\n * - {@link IOR}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsIOR, IOR } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const iorExtension = document.createExtension(MaterialsIOR);\r\n *\r\n * // Create IOR property.\r\n * const ior = iorExtension.createIOR().setIOR(1.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_ior', ior);\r\n * ```\r\n */\r\nexport class MaterialsIOR extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new IOR property for use on a {@link Material}. */\r\n\tpublic createIOR(): IOR {\r\n\t\treturn new IOR(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst ior = this.createIOR();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\r\n\r\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (iorDef.ior !== undefined) {\r\n\t\t\t\t\tior.setIOR(iorDef.ior);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\r\n\t\t\t\tif (ior) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tior: ior.getIOR(),\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\r\n\r\ninterface IIridescence extends IProperty {\r\n\tiridescenceFactor: number;\r\n\tiridescenceTexture: Texture;\r\n\tiridescenceTextureInfo: TextureInfo;\r\n\tiridescenceIOR: number;\r\n\tiridescenceThicknessMinimum: number;\r\n\tiridescenceThicknessMaximum: number;\r\n\tiridescenceThicknessTexture: Texture;\r\n\tiridescenceThicknessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G } = TextureChannel;\r\n\r\n/**\r\n * # Iridescence\r\n *\r\n * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link MaterialsIridescence}.\r\n */\r\nexport class Iridescence extends ExtensionProperty<IIridescence> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_IRIDESCENCE;\r\n\tpublic declare propertyType: 'Iridescence';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_IRIDESCENCE;\r\n\t\tthis.propertyType = 'Iridescence';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IIridescence> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tiridescenceFactor: 0.0,\r\n\t\t\tiridescenceTexture: null,\r\n\t\t\tiridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),\r\n\t\t\tiridescenceIOR: 1.3,\r\n\t\t\tiridescenceThicknessMinimum: 100,\r\n\t\t\tiridescenceThicknessMaximum: 400,\r\n\t\t\tiridescenceThicknessTexture: null,\r\n\t\t\tiridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence.\r\n\t */\r\n\r\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\r\n\tpublic getIridescenceFactor(): number {\r\n\t\treturn this.get('iridescenceFactor');\r\n\t}\r\n\r\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\r\n\tpublic setIridescenceFactor(factor: number): this {\r\n\t\treturn this.set('iridescenceFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Iridescence intensity.\r\n\t *\r\n\t * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\r\n\t * be packed with additional data in the other channels.\r\n\t */\r\n\tpublic getIridescenceTexture(): Texture | null {\r\n\t\treturn this.getRef('iridescenceTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its iridescence texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getIridescenceTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Iridescence intensity. See {@link getIridescenceTexture}. */\r\n\tpublic setIridescenceTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('iridescenceTexture', texture, { channels: R });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence IOR.\r\n\t */\r\n\r\n\t/** Index of refraction of the dielectric thin-film layer. */\r\n\tpublic getIridescenceIOR(): number {\r\n\t\treturn this.get('iridescenceIOR');\r\n\t}\r\n\r\n\t/** Index of refraction of the dielectric thin-film layer. */\r\n\tpublic setIridescenceIOR(ior: number): this {\r\n\t\treturn this.set('iridescenceIOR', ior);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence thickness.\r\n\t */\r\n\r\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic getIridescenceThicknessMinimum(): number {\r\n\t\treturn this.get('iridescenceThicknessMinimum');\r\n\t}\r\n\r\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic setIridescenceThicknessMinimum(thickness: number): this {\r\n\t\treturn this.set('iridescenceThicknessMinimum', thickness);\r\n\t}\r\n\r\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic getIridescenceThicknessMaximum(): number {\r\n\t\treturn this.get('iridescenceThicknessMaximum');\r\n\t}\r\n\r\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic setIridescenceThicknessMaximum(thickness: number): this {\r\n\t\treturn this.set('iridescenceThicknessMaximum', thickness);\r\n\t}\r\n\r\n\t/**\r\n\t * The green channel of this texture defines the thickness of the\r\n\t * thin-film layer by blending between the minimum and maximum thickness.\r\n\t */\r\n\tpublic getIridescenceThicknessTexture(): Texture | null {\r\n\t\treturn this.getRef('iridescenceThicknessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its iridescence thickness texture.\r\n\t * If no texture is attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getIridescenceThicknessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets iridescence thickness texture. See {@link getIridescenceThicknessTexture}. */\r\n\tpublic setIridescenceThicknessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('iridescenceThicknessTexture', texture, { channels: G });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\r\nimport { Iridescence } from './iridescence';\r\n\r\nconst NAME = KHR_MATERIALS_IRIDESCENCE;\r\n\r\ninterface IridescenceDef {\r\n\tiridescenceFactor: number;\r\n\tiridescenceTexture: GLTF.ITextureInfo;\r\n\tiridescenceIor: number;\r\n\tiridescenceThicknessMinimum: number;\r\n\tiridescenceThicknessMaximum: number;\r\n\tiridescenceThicknessTexture: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsIridescence\r\n *\r\n * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)\r\n * defines iridescence (thin film interference) on a PBR material.\r\n *\r\n * Iridescence describes an effect where hue varies depending on the viewing\r\n * angle and illumination angle: A thin-film of a semi-transparent layer\r\n * results in inter-reflections and due to thin-film interference, certain\r\n * wavelengths get absorbed or amplified. Iridescence can be seen on soap\r\n * bubbles, oil films, or on the wings of many insects. With this extension,\r\n * thickness and index of refraction (IOR) of the thin-film can be specified,\r\n * enabling iridescent materials.\r\n *\r\n * Properties:\r\n * - {@link Iridescence}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsIridescence, Iridescence } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const iridescenceExtension = document.createExtension(MaterialsIridescence);\r\n *\r\n * // Create an Iridescence property.\r\n * const iridescence = iridescenceExtension.createIridescence()\r\n * \t.setIridescenceFactor(1.0)\r\n * \t.setIridescenceIOR(1.8);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_iridescence', iridescence);\r\n * ```\r\n */\r\nexport class MaterialsIridescence extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Iridescence property for use on a {@link Material}. */\r\n\tpublic createIridescence(): Iridescence {\r\n\t\treturn new Iridescence(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst iridescence = this.createIridescence();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, iridescence);\r\n\r\n\t\t\t\tconst iridescenceDef = materialDef.extensions[NAME] as IridescenceDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (iridescenceDef.iridescenceFactor !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceIor !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMinimum !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMaximum !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (iridescenceDef.iridescenceTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tiridescence.setIridescenceTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tiridescence.setIridescenceThicknessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst iridescence = material.getExtension<Iridescence>(NAME);\r\n\t\t\t\tif (iridescence) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst iridescenceDef = (materialDef.extensions[NAME] = {} as IridescenceDef);\r\n\r\n\t\t\t\t\tif (iridescence.getIridescenceFactor() > 0) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceIOR() !== 1.3) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMinimum() !== 100) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMaximum() !== 400) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (iridescence.getIridescenceTexture()) {\r\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceTextureInfo()!;\r\n\t\t\t\t\t\tiridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessTexture()) {\r\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceThicknessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceThicknessTextureInfo()!;\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n\tvec4,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\r\n\r\ninterface IPBRSpecularGlossiness extends IProperty {\r\n\tdiffuseFactor: vec4;\r\n\tdiffuseTexture: Texture;\r\n\tdiffuseTextureInfo: TextureInfo;\r\n\tspecularFactor: vec3;\r\n\tglossinessFactor: number;\r\n\tspecularGlossinessTexture: Texture;\r\n\tspecularGlossinessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # PBRSpecularGlossiness\r\n *\r\n * Converts a {@link Material} to a spec/gloss workflow. See {@link MaterialsPBRSpecularGlossiness}.\r\n */\r\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\r\n\t\t\tdiffuseTexture: null,\r\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\r\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\tglossinessFactor: 1.0,\r\n\t\t\tspecularGlossinessTexture: null,\r\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Diffuse.\r\n\t */\r\n\r\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\r\n\tpublic getDiffuseFactor(): vec4 {\r\n\t\treturn this.get('diffuseFactor');\r\n\t}\r\n\r\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\r\n\tpublic setDiffuseFactor(factor: vec4): this {\r\n\t\treturn this.set('diffuseFactor', factor);\r\n\t}\r\n\r\n\t/** Diffuse; sRGB hexadecimal color. */\r\n\tpublic getDiffuseHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getDiffuseFactor());\r\n\t}\r\n\r\n\t/** Diffuse; sRGB hexadecimal color. */\r\n\tpublic setDiffuseHex(hex: number): this {\r\n\t\tconst factor = this.getDiffuseFactor().slice() as vec4;\r\n\t\treturn this.setDiffuseFactor(ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\r\n\t * spec/gloss PBR workflow.\r\n\t */\r\n\tpublic getDiffuseTexture(): Texture | null {\r\n\t\treturn this.getRef('diffuseTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets diffuse texture. See {@link getDiffuseTexture}. */\r\n\tpublic setDiffuseTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular.\r\n\t */\r\n\r\n\t/** Specular; linear multiplier. */\r\n\tpublic getSpecularFactor(): vec3 {\r\n\t\treturn this.get('specularFactor');\r\n\t}\r\n\r\n\t/** Specular; linear multiplier. */\r\n\tpublic setSpecularFactor(factor: vec3): this {\r\n\t\treturn this.set('specularFactor', factor);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Glossiness.\r\n\t */\r\n\r\n\t/** Glossiness; linear multiplier. */\r\n\tpublic getGlossinessFactor(): number {\r\n\t\treturn this.get('glossinessFactor');\r\n\t}\r\n\r\n\t/** Glossiness; linear multiplier. */\r\n\tpublic setGlossinessFactor(factor: number): this {\r\n\t\treturn this.set('glossinessFactor', factor);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular/Glossiness.\r\n\t */\r\n\r\n\t/** Spec/gloss texture; linear multiplier. */\r\n\tpublic getSpecularGlossinessTexture(): Texture | null {\r\n\t\treturn this.getRef('specularGlossinessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Spec/gloss texture; linear multiplier. */\r\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\r\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness';\r\n\r\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\r\ninterface SpecularGlossinessDef {\r\n\tdiffuseFactor?: vec4;\r\n\tspecularFactor: vec3;\r\n\tglossinessFactor: number;\r\n\tdiffuseTexture?: GLTF.ITextureInfo;\r\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsPBRSpecularGlossiness\r\n *\r\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\r\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\r\n *\r\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\r\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\r\n * > {@link MaterialsSpecular} extension instead, which provides specular data within a metal/rough\r\n * > workflow._\r\n *\r\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\r\n *\r\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\r\n *\r\n * Properties:\r\n * - {@link PBRSpecularGlossiness}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const specGlossExtension = document.createExtension(MaterialsPBRSpecularGlossiness);\r\n *\r\n * // Create a PBRSpecularGlossiness property.\r\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\r\n * \t.setSpecularFactor(1.0);\r\n *\r\n * // // Assign to a Material.\r\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\r\n * ```\r\n */\r\nexport class MaterialsPBRSpecularGlossiness extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\r\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\r\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\r\n\r\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\r\n\t\t\t\tif (specGloss) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\r\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\r\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\r\n\t\t\t\t\t} as SpecularGlossinessDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\r\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\r\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\r\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\r\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SHEEN } from '../constants';\r\n\r\ninterface ISheen extends IProperty {\r\n\tsheenColorFactor: vec3;\r\n\tsheenColorTexture: Texture;\r\n\tsheenColorTextureInfo: TextureInfo;\r\n\tsheenRoughnessFactor: number;\r\n\tsheenRoughnessTexture: Texture;\r\n\tsheenRoughnessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # Sheen\r\n *\r\n * Defines sheen on a PBR {@link Material}. See {@link MaterialsSheen}.\r\n */\r\nexport class Sheen extends ExtensionProperty<ISheen> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\r\n\tpublic declare propertyType: 'Sheen';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\r\n\t\tthis.propertyType = 'Sheen';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ISheen> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\r\n\t\t\tsheenColorTexture: null,\r\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\r\n\t\t\tsheenRoughnessFactor: 0.0,\r\n\t\t\tsheenRoughnessTexture: null,\r\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Sheen color.\r\n\t */\r\n\r\n\t/** Sheen; linear multiplier. */\r\n\tpublic getSheenColorFactor(): vec3 {\r\n\t\treturn this.get('sheenColorFactor');\r\n\t}\r\n\r\n\t/** Sheen; hex color in sRGB colorspace. */\r\n\tpublic getSheenColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getSheenColorFactor());\r\n\t}\r\n\r\n\t/** Sheen; linear multiplier. */\r\n\tpublic setSheenColorFactor(factor: vec3): this {\r\n\t\treturn this.set('sheenColorFactor', factor);\r\n\t}\r\n\r\n\t/** Sheen; hex color in sRGB colorspace. */\r\n\tpublic setSheenColorHex(hex: number): this {\r\n\t\tconst factor = this.getSheenColorFactor().slice() as vec3;\r\n\t\treturn this.set('sheenColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Sheen color texture, in sRGB colorspace.\r\n\t */\r\n\tpublic getSheenColorTexture(): Texture | null {\r\n\t\treturn this.getRef('sheenColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets sheen color texture. See {@link getSheenColorTexture}. */\r\n\tpublic setSheenColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Sheen roughness.\r\n\t */\r\n\r\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\r\n\tpublic getSheenRoughnessFactor(): number {\r\n\t\treturn this.get('sheenRoughnessFactor');\r\n\t}\r\n\r\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\r\n\tpublic setSheenRoughnessFactor(factor: number): this {\r\n\t\treturn this.set('sheenRoughnessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic getSheenRoughnessTexture(): Texture | null {\r\n\t\treturn this.getRef('sheenRoughnessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SHEEN } from '../constants';\r\nimport { Sheen } from './sheen';\r\n\r\nconst NAME = KHR_MATERIALS_SHEEN;\r\n\r\ninterface SheenDef {\r\n\tsheenColorFactor?: vec3;\r\n\tsheenRoughnessFactor?: number;\r\n\tsheenColorTexture?: GLTF.ITextureInfo;\r\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsSheen\r\n *\r\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\r\n * defines a velvet-like sheen layered on a glTF PBR material.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\r\n *\r\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\r\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\r\n * > Group._\r\n *\r\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\r\n * cloth and fabric materials.\r\n *\r\n * Properties:\r\n * - {@link Sheen}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsSheen, Sheen } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const sheenExtension = document.createExtension(MaterialsSheen);\r\n *\r\n * // Create a Sheen property.\r\n * const sheen = sheenExtension.createSheen()\r\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_sheen', sheen);\r\n * ```\r\n */\r\nexport class MaterialsSheen extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Sheen property for use on a {@link Material}. */\r\n\tpublic createSheen(): Sheen {\r\n\t\treturn new Sheen(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst sheen = this.createSheen();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\r\n\r\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\r\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\r\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\r\n\t\t\t\tif (sheen) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\r\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\r\n\t\t\t\t\t} as SheenDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\r\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\r\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\r\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\r\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\r\n\r\ninterface ISpecular extends IProperty {\r\n\tspecularFactor: number;\r\n\tspecularTexture: Texture;\r\n\tspecularTextureInfo: TextureInfo;\r\n\tspecularColorFactor: vec3;\r\n\tspecularColorTexture: Texture;\r\n\tspecularColorTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # Specular\r\n *\r\n * Defines specular reflectivity on a PBR {@link Material}. See {@link MaterialsSpecular}.\r\n */\r\nexport class Specular extends ExtensionProperty<ISpecular> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\r\n\tpublic declare propertyType: 'Specular';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\r\n\t\tthis.propertyType = 'Specular';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ISpecular> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tspecularFactor: 1.0,\r\n\t\t\tspecularTexture: null,\r\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\r\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\tspecularColorTexture: null,\r\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular.\r\n\t */\r\n\r\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\r\n\tpublic getSpecularFactor(): number {\r\n\t\treturn this.get('specularFactor');\r\n\t}\r\n\r\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularFactor(factor: number): this {\r\n\t\treturn this.set('specularFactor', factor);\r\n\t}\r\n\r\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\r\n\tpublic getSpecularColorFactor(): vec3 {\r\n\t\treturn this.get('specularColorFactor');\r\n\t}\r\n\r\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularColorFactor(factor: vec3): this {\r\n\t\treturn this.set('specularColorFactor', factor);\r\n\t}\r\n\r\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\r\n\tpublic getSpecularColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getSpecularColorFactor());\r\n\t}\r\n\r\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\r\n\tpublic setSpecularColorHex(hex: number): this {\r\n\t\tconst factor = this.getSpecularColorFactor().slice() as vec3;\r\n\t\treturn this.set('specularColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\r\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\r\n\t * diffuse material.\r\n\t *\r\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\r\n\t * be packed with specular color (RGB) into a single texture.\r\n\t */\r\n\tpublic getSpecularTexture(): Texture | null {\r\n\t\treturn this.getRef('specularTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets specular texture. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\r\n\t}\r\n\r\n\t/**\r\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\r\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\r\n\t *\r\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\r\n\t * factor (A) into a single texture.\r\n\t */\r\n\tpublic getSpecularColorTexture(): Texture | null {\r\n\t\treturn this.getRef('specularColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its specular color texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets specular color texture. See {@link getSpecularColorTexture}. */\r\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\r\nimport { Specular } from './specular';\r\n\r\nconst NAME = KHR_MATERIALS_SPECULAR;\r\n\r\ninterface SpecularDef {\r\n\tspecularFactor?: number;\r\n\tspecularColorFactor?: vec3;\r\n\tspecularTexture?: GLTF.ITextureInfo;\r\n\tspecularColorTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsSpecular\r\n *\r\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)\r\n * adjusts the strength of the specular reflection in the dielectric BRDF.\r\n *\r\n * MaterialsSpecular is a better alternative to the older\r\n * {@link MaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\r\n * provides specular information while remaining within a metal/rough PBR workflow. A\r\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\r\n *\r\n * Properties:\r\n * - {@link Specular}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsSpecular, Specular } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const specularExtension = document.createExtension(MaterialsSpecular);\r\n *\r\n * // Create a Specular property.\r\n * const specular = specularExtension.createSpecular()\r\n * \t.setSpecularFactor(1.0);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_specular', specular);\r\n * ```\r\n */\r\nexport class MaterialsSpecular extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Specular property for use on a {@link Material}. */\r\n\tpublic createSpecular(): Specular {\r\n\t\treturn new Specular(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst specular = this.createSpecular();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\r\n\r\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\r\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\r\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecular.setSpecularTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\r\n\t\t\t\tif (specular) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\r\n\r\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\r\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\r\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (specular.getSpecularTexture()) {\r\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\r\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\r\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\r\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSLUCENCY } from '../constants';\r\n\r\ninterface ITranslucency extends IProperty {\r\n\ttranslucencyFactor: number;\r\n\ttranslucencyTexture: Texture;\r\n\ttranslucencyTextureInfo: TextureInfo;\r\n\ttranslucencyColorFactor: vec3;\r\n\ttranslucencyColorTexture: Texture;\r\n\ttranslucencyColorTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # translucency\r\n *\r\n * Defines translucency reflectivity on a PBR {@link Material}. See {@link Materialstranslucency}.\r\n */\r\nexport class Translucency extends ExtensionProperty<ITranslucency> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSLUCENCY;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSLUCENCY;\r\n\tpublic declare propertyType: 'Translucency';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_TRANSLUCENCY;\r\n\t\tthis.propertyType = 'Translucency';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITranslucency> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\ttranslucencyFactor: 1.0,\r\n\t\t\ttranslucencyTexture: null,\r\n\t\t\ttranslucencyTextureInfo: new TextureInfo(this.graph, 'translucencyTextureInfo'),\r\n\t\t\ttranslucencyColorFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\ttranslucencyColorTexture: null,\r\n\t\t\ttranslucencyColorTextureInfo: new TextureInfo(this.graph, 'translucencyColorTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * translucency.\r\n\t */\r\n\r\n\t/** translucency; linear multiplier. See {@link getTranslucencyTexture}. */\r\n\tpublic getTranslucencyFactor(): number {\r\n\t\treturn this.get('translucencyFactor');\r\n\t}\r\n\r\n\t/** translucency; linear multiplier. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyFactor(factor: number): this {\r\n\t\treturn this.set('translucencyFactor', factor);\r\n\t}\r\n\r\n\t/** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */\r\n\tpublic getTranslucencyColorFactor(): vec3 {\r\n\t\treturn this.get('translucencyColorFactor');\r\n\t}\r\n\r\n\t/** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyColorFactor(factor: vec3): this {\r\n\t\treturn this.set('translucencyColorFactor', factor);\r\n\t}\r\n\r\n\t/** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */\r\n\tpublic getTranslucencyColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getTranslucencyColorFactor());\r\n\t}\r\n\r\n\t/** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */\r\n\tpublic setTranslucencyColorHex(hex: number): this {\r\n\t\tconst factor = this.getTranslucencyColorFactor().slice() as vec3;\r\n\t\treturn this.set('translucencyColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * translucency texture; linear multiplier. Configures the strength of the translucency reflection in\r\n\t * the dielectric BRDF. A value of zero disables the translucency reflection, resulting in a pure\r\n\t * diffuse material.\r\n\t *\r\n\t * Only the alpha (A) channel is used for translucency strength, but this texture may optionally\r\n\t * be packed with translucency color (RGB) into a single texture.\r\n\t */\r\n\tpublic getTranslucencyTexture(): Texture | null {\r\n\t\treturn this.getRef('translucencyTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its translucency texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTranslucencyTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('translucencyTexture') ? this.getRef('translucencyTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets translucency texture. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('translucencyTexture', texture, { channels: A });\r\n\t}\r\n\r\n\t/**\r\n\t * translucency color texture; linear multiplier. Defines the F0 color of the translucency reflection\r\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\r\n\t *\r\n\t * Only RGB channels are used here, but this texture may optionally be packed with a translucency\r\n\t * factor (A) into a single texture.\r\n\t */\r\n\tpublic getTranslucencyColorTexture(): Texture | null {\r\n\t\treturn this.getRef('translucencyColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its translucency color texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTranslucencyColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('translucencyColorTexture') ? this.getRef('translucencyColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets translucency color texture. See {@link getTranslucencyColorTexture}. */\r\n\tpublic setTranslucencyColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('translucencyColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSLUCENCY } from '../constants';\r\nimport { Translucency } from './translucency';\r\n\r\nconst NAME = KHR_MATERIALS_TRANSLUCENCY;\r\n\r\ninterface TranslucencyDef {\r\n\ttranslucencyFactor?: number;\r\n\ttranslucencyColorFactor?: vec3;\r\n\ttranslucencyTexture?: GLTF.ITextureInfo;\r\n\ttranslucencyColorTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsTranslucency\r\n */\r\nexport class MaterialsTranslucency extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Translucency property for use on a {@link Material}. */\r\n\tpublic createTranslucency(): Translucency {\r\n\t\treturn new Translucency(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst translucency = this.createTranslucency();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, translucency);\r\n\r\n\t\t\t\tconst translucencyDef = materialDef.extensions[NAME] as TranslucencyDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (translucencyDef.translucencyFactor !== undefined) {\r\n\t\t\t\t\ttranslucency.setTranslucencyFactor(translucencyDef.translucencyFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (translucencyDef.translucencyColorFactor !== undefined) {\r\n\t\t\t\t\ttranslucency.setTranslucencyColorFactor(translucencyDef.translucencyColorFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (translucencyDef.translucencyTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = translucencyDef.translucencyTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttranslucency.setTranslucencyTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(translucency.getTranslucencyTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (translucencyDef.translucencyColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = translucencyDef.translucencyColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttranslucency.setTranslucencyColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(translucency.getTranslucencyColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst translucency = material.getExtension<Translucency>(NAME);\r\n\t\t\t\tif (translucency) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst translucencyDef = (materialDef.extensions[NAME] = {} as TranslucencyDef);\r\n\r\n\t\t\t\t\tif (translucency.getTranslucencyFactor() !== 1) {\r\n\t\t\t\t\t\ttranslucencyDef.translucencyFactor = translucency.getTranslucencyFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(translucency.getTranslucencyColorFactor(), [1, 1, 1])) {\r\n\t\t\t\t\t\ttranslucencyDef.translucencyColorFactor = translucency.getTranslucencyColorFactor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (translucency.getTranslucencyTexture()) {\r\n\t\t\t\t\t\tconst texture = translucency.getTranslucencyTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = translucency.getTranslucencyTextureInfo()!;\r\n\t\t\t\t\t\ttranslucencyDef.translucencyTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (translucency.getTranslucencyColorTexture()) {\r\n\t\t\t\t\t\tconst texture = translucency.getTranslucencyColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = translucency.getTranslucencyColorTextureInfo()!;\r\n\t\t\t\t\t\ttranslucencyDef.translucencyColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\r\n\r\ninterface ITransmission extends IProperty {\r\n\ttransmissionFactor: number;\r\n\ttransmissionTexture: Texture;\r\n\ttransmissionTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R } = TextureChannel;\r\n\r\n/**\r\n * # Transmission\r\n *\r\n * Defines optical transmission on a PBR {@link Material}. See {@link MaterialsTransmission}.\r\n */\r\nexport class Transmission extends ExtensionProperty<ITransmission> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\r\n\tpublic declare propertyType: 'Transmission';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\r\n\t\tthis.propertyType = 'Transmission';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITransmission> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\ttransmissionFactor: 0.0,\r\n\t\t\ttransmissionTexture: null,\r\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Transmission.\r\n\t */\r\n\r\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\r\n\tpublic getTransmissionFactor(): number {\r\n\t\treturn this.get('transmissionFactor');\r\n\t}\r\n\r\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\r\n\tpublic setTransmissionFactor(factor: number): this {\r\n\t\treturn this.set('transmissionFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\r\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\r\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\r\n\t * addition of the `KHR_materials_volume` extension.\r\n\t */\r\n\tpublic getTransmissionTexture(): Texture | null {\r\n\t\treturn this.getRef('transmissionTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets transmission texture. See {@link getTransmissionTexture}. */\r\n\tpublic setTransmissionTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\r\nimport { Transmission } from './transmission';\r\n\r\nconst NAME = KHR_MATERIALS_TRANSMISSION;\r\n\r\ninterface TransmissionDef {\r\n\ttransmissionFactor?: number;\r\n\ttransmissionTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsTransmission\r\n *\r\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)\r\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\r\n * scattering, or dispersion.\r\n *\r\n * While default PBR materials using alpha blending become invisible as their opacity approaches\r\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\r\n * transmission values. When combined with {@link MaterialsVolume}, transmission may be used for\r\n * thicker materials and refractive effects.\r\n *\r\n * Properties:\r\n * - {@link Transmission}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsTransmission` class provides a single {@link ExtensionProperty} type,\r\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsTransmission, Transmission } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const transmissionExtension = document.createExtension(MaterialsTransmission);\r\n *\r\n * // Create a Transmission property.\r\n * const transmission = transmissionExtension.createTransmission()\r\n * \t.setTransmissionFactor(1.0);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_transmission', transmission);\r\n * ```\r\n */\r\nexport class MaterialsTransmission extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Transmission property for use on a {@link Material}. */\r\n\tpublic createTransmission(): Transmission {\r\n\t\treturn new Transmission(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst transmission = this.createTransmission();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\r\n\r\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\r\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\r\n\t\t\t\tif (transmission) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\r\n\t\t\t\t\t} as TransmissionDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\r\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\r\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty } from '@gltf-transform/core';\r\nimport { PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_UNLIT } from '../constants';\r\n\r\n/**\r\n * # Unlit\r\n *\r\n * Converts a PBR {@link Material} to an unlit shading model. See {@link MaterialsUnlit}.\r\n */\r\nexport class Unlit extends ExtensionProperty {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\r\n\tpublic declare propertyType: 'Unlit';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\r\n\t\tthis.propertyType = 'Unlit';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_UNLIT } from '../constants';\r\nimport { Unlit } from './unlit';\r\n\r\nconst NAME = KHR_MATERIALS_UNLIT;\r\n\r\n/**\r\n * # MaterialsUnlit\r\n *\r\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)\r\n * defines an unlit shading model for use in glTF 2.0 materials.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\r\n *\r\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\r\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\r\n *\r\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\r\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\r\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\r\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\r\n * effects like hand painted illustrative styles or baked toon shaders.\r\n *\r\n * Properties:\r\n * - {@link Unlit}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\r\n * be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsUnlit, Unlit } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const unlitExtension = document.createExtension(MaterialsUnlit);\r\n *\r\n * // Create an Unlit property.\r\n * const unlit = unlitExtension.createUnlit();\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_unlit', unlit);\r\n * ```\r\n */\r\nexport class MaterialsUnlit extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Unlit property for use on a {@link Material}. */\r\n\tpublic createUnlit(): Unlit {\r\n\t\treturn new Unlit(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Material, Nullable } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport type { Variant } from './variant';\r\n\r\ninterface IMapping extends IProperty {\r\n\tmaterial: Material;\r\n\tvariants: Variant[];\r\n}\r\n\r\n/**\r\n * # Mapping\r\n *\r\n * Maps {@link Variant}s to {@link Material}s. See {@link MaterialsVariants}.\r\n */\r\nexport class Mapping extends ExtensionProperty<IMapping> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'Mapping';\r\n\tpublic declare parentTypes: ['MappingList'];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'Mapping';\r\n\t\tthis.parentTypes = ['MappingList'];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IMapping> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: [] });\r\n\t}\r\n\r\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\r\n\tpublic getMaterial(): Material | null {\r\n\t\treturn this.getRef('material');\r\n\t}\r\n\r\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\r\n\tpublic setMaterial(material: Material | null): this {\r\n\t\treturn this.setRef('material', material);\r\n\t}\r\n\r\n\t/** Adds a {@link Variant} to this mapping. */\r\n\tpublic addVariant(variant: Variant): this {\r\n\t\treturn this.addRef('variants', variant);\r\n\t}\r\n\r\n\t/** Removes a {@link Variant} from this mapping. */\r\n\tpublic removeVariant(variant: Variant): this {\r\n\t\treturn this.removeRef('variants', variant);\r\n\t}\r\n\r\n\t/** Lists {@link Variant}s in this mapping. */\r\n\tpublic listVariants(): Variant[] {\r\n\t\treturn this.listRefs('variants');\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport type { Mapping } from './mapping';\r\n\r\ninterface IMappingList extends IProperty {\r\n\tmappings: Mapping[];\r\n}\r\n\r\n/**\r\n * # MappingList\r\n *\r\n * List of material variant {@link Mapping}s. See {@link MaterialsVariants}.\r\n */\r\nexport class MappingList extends ExtensionProperty<IMappingList> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'MappingList';\r\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'MappingList';\r\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IMappingList> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: [] });\r\n\t}\r\n\r\n\t/** Adds a {@link Mapping} to this mapping. */\r\n\tpublic addMapping(mapping: Mapping): this {\r\n\t\treturn this.addRef('mappings', mapping);\r\n\t}\r\n\r\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\r\n\tpublic removeMapping(mapping: Mapping): this {\r\n\t\treturn this.removeRef('mappings', mapping);\r\n\t}\r\n\r\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\r\n\tpublic listMappings(): Mapping[] {\r\n\t\treturn this.listRefs('mappings');\r\n\t}\r\n}\r\n","import { ExtensionProperty } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\n\r\n/**\r\n * # Variant\r\n *\r\n * Defines a variant of a {@link Material}. See {@link MaterialsVariants}.\r\n */\r\nexport class Variant extends ExtensionProperty {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'Variant';\r\n\tpublic declare parentTypes: ['MappingList'];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'Variant';\r\n\t\tthis.parentTypes = ['MappingList'];\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport { Mapping } from './mapping';\r\nimport { MappingList } from './mapping-list';\r\nimport { Variant } from './variant';\r\n\r\nconst NAME = KHR_MATERIALS_VARIANTS;\r\n\r\ninterface VariantsRootDef {\r\n\tvariants: VariantDef[];\r\n}\r\n\r\ninterface VariantDef {\r\n\tname?: string;\r\n}\r\n\r\ninterface VariantPrimDef {\r\n\tmappings: VariantMappingDef[];\r\n}\r\n\r\ninterface VariantMappingDef {\r\n\tmaterial: number;\r\n\tvariants: number[];\r\n}\r\n\r\n/**\r\n * # MaterialsVariants\r\n *\r\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\r\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-variants.png)\r\n *\r\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\r\n *\r\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\r\n * `MaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\r\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\r\n * defining the variants available to an application. Triggering a variant is out of scope of this\r\n * extension, but could be handled in the application with a UI dropdown, particular game states,\r\n * and so on.\r\n *\r\n * Mesh geometry cannot be changed by this extension, although another extension\r\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\r\n *\r\n * Properties:\r\n * - {@link Variant}\r\n * - {@link Mapping}\r\n * - {@link MappingList}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsVariants } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const variantExtension = document.createExtension(MaterialsVariants);\r\n *\r\n * // Create some Variant states.\r\n * const healthyVariant = variantExtension.createVariant('Healthy');\r\n * const damagedVariant = variantExtension.createVariant('Damaged');\r\n *\r\n * // Create mappings from a Variant state to a Material.\r\n * const healthyMapping = variantExtension.createMapping()\r\n * \t.addVariant(healthyVariant)\r\n * \t.setMaterial(healthyMat);\r\n * const damagedMapping = variantExtension.createMapping()\r\n * \t.addVariant(damagedVariant)\r\n * \t.setMaterial(damagedMat);\r\n *\r\n * // Attach the mappings to a Primitive.\r\n * primitive.setExtension(\r\n * \t'KHR_materials_variants',\r\n * \tvariantExtension.createMappingList()\r\n * \t\t.addMapping(healthyMapping)\r\n * \t\t.addMapping(damagedMapping)\r\n * );\r\n * ```\r\n *\r\n * A few notes about this extension:\r\n *\r\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\r\n * \t instead, so assign that material accordingly. This material can be  but doesn't have to be \r\n * \t associated with one of the available variants.\r\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\r\n * \t Variant will be chosen by the viewer.\r\n * 3. Variant names are how these states are identified, so choose informative names.\r\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\r\n * \t the option of downloading only textures associated with the default state, and lazy-loading\r\n * \t any textures for inactive Variants only when they are needed.\r\n */\r\nexport class MaterialsVariants extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new MappingList property. */\r\n\tpublic createMappingList(): MappingList {\r\n\t\treturn new MappingList(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Creates a new Variant property. */\r\n\tpublic createVariant(name = ''): Variant {\r\n\t\treturn new Variant(this.document.getGraph(), name);\r\n\t}\r\n\r\n\t/** Creates a new Mapping property. */\r\n\tpublic createMapping(): Mapping {\r\n\t\treturn new Mapping(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Lists all Variants on the current Document. */\r\n\tpublic listVariants(): Variant[] {\r\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\r\n\r\n\t\t// Read all top-level variant names.\r\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\r\n\t\tconst variantDefs = variantsRootDef.variants || [];\r\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\r\n\r\n\t\t// For each mesh primitive, read its material/variant mappings.\r\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\r\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\r\n\t\t\tconst mesh = context.meshes[meshIndex];\r\n\t\t\tconst primDefs = meshDef.primitives || [];\r\n\r\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\r\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst mappingList = this.createMappingList();\r\n\r\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\r\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\r\n\t\t\t\t\tconst mapping = this.createMapping();\r\n\r\n\t\t\t\t\tif (mappingDef.material !== undefined) {\r\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\r\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmappingList.addMapping(mapping);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst variants = this.listVariants();\r\n\t\tif (!variants.length) return this;\r\n\r\n\t\t// Write all top-level variant names.\r\n\t\tconst variantDefs = [];\r\n\t\tconst variantIndexMap = new Map<Variant, number>();\r\n\t\tfor (const variant of variants) {\r\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\r\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\r\n\t\t}\r\n\r\n\t\t// For each mesh primitive, write its material/variant mappings.\r\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\r\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\r\n\r\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\r\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\r\n\t\t\t\tif (!mappingList) return;\r\n\r\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\r\n\r\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\r\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\r\n\r\n\t\t\t\t\tconst material = mapping.getMaterial();\r\n\t\t\t\t\tif (material) {\r\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\r\n\r\n\t\t\t\t\treturn mappingDef;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\r\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\r\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VOLUME } from '../constants';\r\n\r\ninterface IVolume extends IProperty {\r\n\tthicknessFactor: number;\r\n\tthicknessTexture: Texture;\r\n\tthicknessTextureInfo: TextureInfo;\r\n\tattenuationDistance: number;\r\n\tattenuationColor: vec3;\r\n}\r\n\r\nconst { G } = TextureChannel;\r\n\r\n/**\r\n * # Volume\r\n *\r\n * Defines volume on a PBR {@link Material}. See {@link MaterialsVolume}.\r\n */\r\nexport class Volume extends ExtensionProperty<IVolume> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\r\n\tpublic declare propertyType: 'Volume';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\r\n\t\tthis.propertyType = 'Volume';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IVolume> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tthicknessFactor: 0.0,\r\n\t\t\tthicknessTexture: null,\r\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\r\n\t\t\tattenuationDistance: Infinity,\r\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Thickness.\r\n\t */\r\n\r\n\t/**\r\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\r\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\r\n\t * boundary. The doubleSided property has no effect on volume boundaries.\r\n\t */\r\n\tpublic getThicknessFactor(): number {\r\n\t\treturn this.get('thicknessFactor');\r\n\t}\r\n\r\n\t/**\r\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\r\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\r\n\t * boundary. The doubleSided property has no effect on volume boundaries.\r\n\t */\r\n\tpublic setThicknessFactor(factor: number): this {\r\n\t\treturn this.set('thicknessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\r\n\t * thicknessFactor.\r\n\t */\r\n\tpublic getThicknessTexture(): Texture | null {\r\n\t\treturn this.getRef('thicknessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\r\n\t * thicknessFactor.\r\n\t */\r\n\tpublic setThicknessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Attenuation.\r\n\t */\r\n\r\n\t/**\r\n\t * Density of the medium given as the average distance in meters that light travels in the\r\n\t * medium before interacting with a particle.\r\n\t */\r\n\tpublic getAttenuationDistance(): number {\r\n\t\treturn this.get('attenuationDistance');\r\n\t}\r\n\r\n\t/**\r\n\t * Density of the medium given as the average distance in meters that light travels in the\r\n\t * medium before interacting with a particle.\r\n\t */\r\n\tpublic setAttenuationDistance(distance: number): this {\r\n\t\treturn this.set('attenuationDistance', distance);\r\n\t}\r\n\r\n\t/**\r\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic getAttenuationColor(): vec3 {\r\n\t\treturn this.get('attenuationColor');\r\n\t}\r\n\r\n\t/**\r\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic setAttenuationColor(color: vec3): this {\r\n\t\treturn this.set('attenuationColor', color);\r\n\t}\r\n\r\n\t/**\r\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic getAttenuationColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getAttenuationColor());\r\n\t}\r\n\r\n\t/**\r\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic setAttenuationColorHex(hex: number): this {\r\n\t\tconst factor = this.getAttenuationColor().slice() as vec3;\r\n\t\treturn this.set('attenuationColor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VOLUME } from '../constants';\r\nimport { Volume } from './volume';\r\n\r\nconst NAME = KHR_MATERIALS_VOLUME;\r\n\r\ninterface VolumeDef {\r\n\tthicknessFactor?: number;\r\n\tthicknessTexture?: GLTF.ITextureInfo;\r\n\tattenuationDistance?: number;\r\n\tattenuationColor?: vec3;\r\n}\r\n\r\n/**\r\n * # MaterialsVolume\r\n *\r\n * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)\r\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\r\n * translucency.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-volume.png)\r\n *\r\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\r\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\r\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\r\n * > volume (right). The overall color depends on the distance the light traveled through it; at\r\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\r\n * > large distances. Source: Khronos Group._\r\n *\r\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\r\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\r\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\r\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\r\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\r\n * effects will require future (TBD) extensions.\r\n *\r\n * The volume extension must be combined with {@link MaterialsTransmission} or\r\n * `KHR_materials_translucency` in order to define entry of light into the volume.\r\n *\r\n * Properties:\r\n * - {@link Volume}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\r\n * may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsVolume, Volume } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const volumeExtension = document.createExtension(MaterialsVolume);\r\n *\r\n * // Create a Volume property.\r\n * const volume = volumeExtension.createVolume()\r\n * \t.setThicknessFactor(1.0)\r\n * \t.setThicknessTexture(texture)\r\n * \t.setAttenuationDistance(1.0)\r\n * \t.setAttenuationColorHex(0xFFEEEE);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_volume', volume);\r\n * ```\r\n *\r\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\r\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\r\n */\r\nexport class MaterialsVolume extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Volume property for use on a {@link Material}. */\r\n\tpublic createVolume(): Volume {\r\n\t\treturn new Volume(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst volume = this.createVolume();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\r\n\r\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\r\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\r\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\r\n\t\t\t\t}\r\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\r\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tvolume.setThicknessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\r\n\t\t\t\tif (volume) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\r\n\r\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\r\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\r\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\r\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (volume.getThicknessTexture()) {\r\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\r\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MESH_QUANTIZATION } from '../constants';\r\n\r\nconst NAME = KHR_MESH_QUANTIZATION;\r\n\r\n/**\r\n * # MeshQuantization\r\n *\r\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)\r\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\r\n *\r\n * Quantization provides a memory/precision tradeoff  depending on the application needs, 16-bit or\r\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\r\n * mesh might be written to a uint16 {@link Accessor}, with values `065536`, normalized to be\r\n * interpreted as `01`. With an additional 10x scale on any node {@link Node} instantiating the\r\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\r\n * up to 50% file size reduction.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing more flexible use of\r\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\r\n * types would yield an invalid glTF document, under the stricter core glTF specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MeshQuantization } from '@gltf-transform/extensions';\r\n * import { quantize } from '@gltf-transform/functions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const quantizationExtension = document.createExtension(MeshQuantization).setRequired(true);\r\n *\r\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\r\n * // or apply the provided quantize() function to compute quantized accessors automatically:\r\n * await document.transform(quantize({\r\n * \tquantizePosition: 16,\r\n * \tquantizeNormal: 12,\r\n * \tquantizeTexcoord: 14\r\n * }));\r\n * ```\r\n *\r\n * For more documentation about automatic quantization, see the {@link quantize} function.\r\n */\r\nexport class MeshQuantization extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tread(_: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\twrite(_: WriterContext): this {\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { KTX2Model, read as readKTX } from 'ktx-parse';\r\nimport {\r\n\tExtension,\r\n\tImageUtils,\r\n\tImageUtilsFormat,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n\tvec2,\r\n} from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_BASISU } from '../constants';\r\n\r\nconst NAME = KHR_TEXTURE_BASISU;\r\n\r\ninterface BasisuDef {\r\n\tsource: number;\r\n}\r\n\r\nclass KTX2ImageUtils implements ImageUtilsFormat {\r\n\tmatch(array: Uint8Array): boolean {\r\n\t\treturn (\r\n\t\t\tarray[0] === 0xab &&\r\n\t\t\tarray[1] === 0x4b &&\r\n\t\t\tarray[2] === 0x54 &&\r\n\t\t\tarray[3] === 0x58 &&\r\n\t\t\tarray[4] === 0x20 &&\r\n\t\t\tarray[5] === 0x32 &&\r\n\t\t\tarray[6] === 0x30 &&\r\n\t\t\tarray[7] === 0xbb &&\r\n\t\t\tarray[8] === 0x0d &&\r\n\t\t\tarray[9] === 0x0a &&\r\n\t\t\tarray[10] === 0x1a &&\r\n\t\t\tarray[11] === 0x0a\r\n\t\t);\r\n\t}\r\n\tgetSize(array: Uint8Array): vec2 {\r\n\t\tconst container = readKTX(array);\r\n\t\treturn [container.pixelWidth, container.pixelHeight];\r\n\t}\r\n\tgetChannels(array: Uint8Array): number {\r\n\t\tconst container = readKTX(array);\r\n\t\tconst dfd = container.dataFormatDescriptor[0];\r\n\t\tif (dfd.colorModel === KTX2Model.ETC1S) {\r\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === 15 ? 4 : 3;\r\n\t\t} else if (dfd.colorModel === KTX2Model.UASTC) {\r\n\t\t\treturn (dfd.samples[0].channelID & 0xf) === 3 ? 4 : 3;\r\n\t\t}\r\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\r\n\t}\r\n\tgetGPUByteLength(array: Uint8Array): number {\r\n\t\tconst container = readKTX(array);\r\n\t\tconst hasAlpha = this.getChannels(array) > 3;\r\n\r\n\t\tlet uncompressedBytes = 0;\r\n\t\tfor (let i = 0; i < container.levels.length; i++) {\r\n\t\t\tconst level = container.levels[i];\r\n\r\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\r\n\t\t\tif (level.uncompressedByteLength) {\r\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\r\n\t\t\t} else {\r\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\r\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\r\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\r\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn uncompressedBytes;\r\n\t}\r\n}\r\n\r\n/**\r\n * # TextureBasisu\r\n *\r\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\r\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\r\n *\r\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\r\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\r\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\r\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\r\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\r\n * framerate while uploading images, or where GPU memory is limited.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\r\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\r\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\r\n * specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TextureBasisu } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const basisuExtension = document.createExtension(TextureBasisu)\r\n * \t.setRequired(true);\r\n * document.createTexture('MyCompressedTexture')\r\n * \t.setMimeType('image/ktx2')\r\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\r\n * ```\r\n *\r\n * Compression is not done automatically when adding the extension as shown above  you must\r\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\r\n * [glTF-Transform CLI](/cli.html) has functions to help with this, or any similar KTX2-capable\r\n * utility will work.\r\n *\r\n * When the `KHR_texture_basisu` extension is added to a file by glTF-Transform, the extension\r\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\r\n * PNG or JPEG image data.\r\n *\r\n * > _**NOTICE:** Compressing some textures  particularly 3-component (RGB) normal maps, and\r\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\r\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\r\n * > texture before compressing it.\r\n * >\r\n * > For best results when authoring new textures, use\r\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\r\n * > prominent UV seams._\r\n */\r\nexport class TextureBasisu extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tpublic static register(): void {\r\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\r\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\r\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\r\n\t\t\t\ttextureDef.source = basisuDef.source;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tpublic read(context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listTextures()\r\n\t\t\t.forEach((texture) => {\r\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\r\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\r\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\r\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\r\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\r\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\r\n\t\t\t\t\t\t\tdelete textureDef.source;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\r\nimport { PropertyType } from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\r\n\r\ninterface ITransform extends IProperty {\r\n\toffset: vec2;\r\n\trotation: number;\r\n\tscale: vec2;\r\n\ttexCoord: number | null; // null  do not override TextureInfo.\r\n}\r\n\r\n/**\r\n * # Transform\r\n *\r\n * Defines UV transform for a {@link TextureInfo}. See {@link TextureTransform}.\r\n */\r\nexport class Transform extends ExtensionProperty<ITransform> {\r\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\r\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\r\n\tpublic declare propertyType: 'Transform';\r\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\r\n\t\tthis.propertyType = 'Transform';\r\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITransform> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\toffset: [0.0, 0.0] as vec2,\r\n\t\t\trotation: 0,\r\n\t\t\tscale: [1.0, 1.0] as vec2,\r\n\t\t\ttexCoord: null,\r\n\t\t});\r\n\t}\r\n\r\n\tpublic getOffset(): vec2 {\r\n\t\treturn this.get('offset');\r\n\t}\r\n\tpublic setOffset(offset: vec2): this {\r\n\t\treturn this.set('offset', offset);\r\n\t}\r\n\r\n\tpublic getRotation(): number {\r\n\t\treturn this.get('rotation');\r\n\t}\r\n\tpublic setRotation(rotation: number): this {\r\n\t\treturn this.set('rotation', rotation);\r\n\t}\r\n\r\n\tpublic getScale(): vec2 {\r\n\t\treturn this.get('scale');\r\n\t}\r\n\tpublic setScale(scale: vec2): this {\r\n\t\treturn this.set('scale', scale);\r\n\t}\r\n\r\n\tpublic getTexCoord(): number | null {\r\n\t\treturn this.get('texCoord');\r\n\t}\r\n\tpublic setTexCoord(texCoord: number | null): this {\r\n\t\treturn this.set('texCoord', texCoord);\r\n\t}\r\n}\r\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\r\nimport { Transform } from './transform';\r\n\r\nconst NAME = KHR_TEXTURE_TRANSFORM;\r\n\r\ninterface TransformDef {\r\n\toffset?: vec2;\r\n\trotation?: number;\r\n\tscale?: vec2;\r\n\ttexCoord?: number;\r\n}\r\n\r\n/**\r\n * # TextureTransform\r\n *\r\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)\r\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\r\n *\r\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\r\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\r\n * this time.\r\n *\r\n * Properties:\r\n * - {@link Transform}\r\n *\r\n * ### Example\r\n *\r\n * The `TextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\r\n * may be attached to any {@link TextureInfo} instance. For example:\r\n *\r\n * ```typescript\r\n * import { TextureTransform } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const transformExtension = document.createExtension(TextureTransform)\r\n * \t.setRequired(true);\r\n *\r\n * // Create a reusable Transform.\r\n * const transform = transformExtension.createTransform()\r\n * \t.setScale([100, 100]);\r\n *\r\n * // Apply the Transform to a Material's baseColorTexture.\r\n * document.createMaterial()\r\n * \t.setBaseColorTexture(myTexture)\r\n * \t.getBaseColorTextureInfo()\r\n * \t.setExtension('KHR_texture_transform', transform);\r\n * ```\r\n */\r\nexport class TextureTransform extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\r\n\tpublic createTransform(): Transform {\r\n\t\treturn new Transform(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\r\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\r\n\r\n\t\t\tconst transform = this.createTransform();\r\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\r\n\r\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\r\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\r\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\r\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\r\n\r\n\t\t\ttextureInfo.setExtension(NAME, transform);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\r\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\r\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\r\n\t\t\tif (!transform) continue;\r\n\r\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\r\n\t\t\tconst transformDef = {} as TransformDef;\r\n\r\n\t\t\tconst eq = MathUtils.eq;\r\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\r\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\r\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\r\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\r\n\r\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Nullable, PropertyType, ExtensionProperty, IProperty } from '@gltf-transform/core';\r\nimport { KHR_XMP_JSON_LD } from '../constants';\r\n\r\ntype Term = string;\r\ntype TermDefinition = string | Record<string, string>;\r\n\r\ntype Value = string | number | boolean;\r\n\r\nconst PARENT_TYPES = [\r\n\tPropertyType.ROOT,\r\n\tPropertyType.SCENE,\r\n\tPropertyType.NODE,\r\n\tPropertyType.MESH,\r\n\tPropertyType.MATERIAL,\r\n\tPropertyType.TEXTURE,\r\n\tPropertyType.ANIMATION,\r\n];\r\n\r\ninterface IPacket extends IProperty {\r\n\t// https://json-ld.org/spec/latest/json-ld/#the-context\r\n\tcontext: Record<Term, TermDefinition>;\r\n\tproperties: Record<string, Value | Record<string, unknown>>;\r\n}\r\n\r\n/**\r\n * # Packet\r\n *\r\n * Defines an XMP packet associated with a Document or Property. See {@link XMP}.\r\n */\r\nexport class Packet extends ExtensionProperty<IPacket> {\r\n\tpublic declare propertyType: 'Packet';\r\n\tpublic declare parentTypes: typeof PARENT_TYPES;\r\n\tpublic declare extensionName: typeof KHR_XMP_JSON_LD;\r\n\tpublic static EXTENSION_NAME = KHR_XMP_JSON_LD;\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_XMP_JSON_LD;\r\n\t\tthis.propertyType = 'Packet';\r\n\t\tthis.parentTypes = PARENT_TYPES;\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IPacket> {\r\n\t\treturn Object.assign(super.getDefaults(), { context: {}, properties: {} });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Context.\r\n\t */\r\n\r\n\t/**\r\n\t * Returns the XMP context definition URL for the given term.\r\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\r\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\r\n\t */\r\n\tpublic getContext(): Record<Term, TermDefinition> {\r\n\t\treturn this.get('context');\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the XMP context definition URL for the given term.\r\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.setContext({\r\n\t *   dc: 'http://purl.org/dc/elements/1.1/',\r\n\t *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\r\n\t * @param definition URI for XMP namespace.\r\n\t */\r\n\tpublic setContext(context: Record<Term, TermDefinition>): this {\r\n\t\treturn this.set('context', { ...context });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Properties.\r\n\t */\r\n\r\n\t/**\r\n\t * Lists properties defined in this packet.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.listProperties(); //  ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\r\n\t * ```\r\n\t */\r\n\tpublic listProperties(): string[] {\r\n\t\treturn Object.keys(this.get('properties'));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of a property, as a literal or JSONLD object.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.getProperty('dc:Creator'); //  {\"@list\": [\"Acme, Inc.\"]}\r\n\t * packet.getProperty('dc:Title'); //  {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\r\n\t * packet.getProperty('xmp:CreateDate'); //  \"2022-01-01\"\r\n\t * ```\r\n\t */\r\n\tpublic getProperty(name: string): Value | Record<string, unknown> | null {\r\n\t\tconst properties = this.get('properties');\r\n\t\treturn name in properties ? properties[name] : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of a property, as a literal or JSONLD object.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\r\n\t * packet.setProperty('dc:Title', {\r\n\t * \t'@type': 'rdf:Alt',\r\n\t * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\r\n\t * });\r\n\t * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\r\n\t * ```\r\n\t */\r\n\tpublic setProperty(name: string, value: Value | Record<string, unknown>): this {\r\n\t\tthis._assertContext(name);\r\n\r\n\t\tconst properties = { ...this.get('properties') };\r\n\t\tif (value) {\r\n\t\t\tproperties[name] = value;\r\n\t\t} else {\r\n\t\t\tdelete properties[name];\r\n\t\t}\r\n\t\treturn this.set('properties', properties);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Serialize / Deserialize.\r\n\t */\r\n\r\n\t/**\r\n\t * Serializes the packet context and properties to a JSONLD object.\r\n\t */\r\n\tpublic toJSONLD(): Record<string, unknown> {\r\n\t\tconst context = copyJSON(this.get('context'));\r\n\t\tconst properties = copyJSON(this.get('properties'));\r\n\t\treturn { '@context': context, ...properties };\r\n\t}\r\n\r\n\t/**\r\n\t * Deserializes a JSONLD packet, then overwrites existing context and properties with\r\n\t * the new values.\r\n\t */\r\n\tpublic fromJSONLD(jsonld: Record<string, unknown>): this {\r\n\t\tjsonld = copyJSON(jsonld);\r\n\r\n\t\t// Context.\r\n\t\tconst context = jsonld['@context'] as Record<Term, TermDefinition>;\r\n\t\tif (context) this.set('context', context);\r\n\t\tdelete jsonld['@context'];\r\n\r\n\t\t// Properties.\r\n\t\treturn this.set('properties', jsonld as Record<string, string | Record<string, unknown>>);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Validation.\r\n\t */\r\n\r\n\t/** @hidden */\r\n\tprivate _assertContext(name: string) {\r\n\t\tconst prefix = name.split(':')[0];\r\n\t\tif (!(prefix in this.get('context'))) {\r\n\t\t\tthrow new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction copyJSON<T>(object: T): T {\r\n\treturn JSON.parse(JSON.stringify(object));\r\n}\r\n","import {\r\n\tAnimation,\r\n\tExtension,\r\n\tGLTF,\r\n\tMaterial,\r\n\tMesh,\r\n\tNode,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tScene,\r\n\tTexture,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { KHR_XMP_JSON_LD } from '../constants';\r\nimport { Packet } from './packet';\r\n\r\nconst NAME = KHR_XMP_JSON_LD;\r\n\r\ntype XMPPacketDef = Record<string, unknown>;\r\n\r\ntype XMPParentDef =\r\n\t| GLTF.IAsset\r\n\t| GLTF.IScene\r\n\t| GLTF.INode\r\n\t| GLTF.IMesh\r\n\t| GLTF.IMaterial\r\n\t| GLTF.ITexture\r\n\t| GLTF.IAnimation;\r\n\r\ninterface XMPPropertyDef {\r\n\tpacket: number;\r\n}\r\n\r\ninterface XMPRootDef {\r\n\tpackets?: XMPPacketDef[];\r\n}\r\n\r\n/**\r\n * # XMP\r\n *\r\n * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)\r\n * defines XMP metadata associated with a glTF asset.\r\n *\r\n * XMP metadata provides standardized fields describing the content, provenance, usage\r\n * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the\r\n * parsing or runtime behavior of the content  for that, use custom extensions, custom vertex\r\n * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred\r\n * for binary content like mesh data, animations, or textures.\r\n *\r\n * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}\r\n * to the document {@link Root}. In less common cases where metadata must be associated with\r\n * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},\r\n * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.\r\n *\r\n * Within each packet, XMP properties become available when an\r\n * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered\r\n * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not\r\n * registered as context. While not all XMP namespaces are relevant to 3D assets, some common\r\n * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`\r\n * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)\r\n * orientation data.\r\n *\r\n * Common XMP contexts for 3D models include:\r\n *\r\n * | Prefix      | URI                                         | Name                           |\r\n * |:------------|:--------------------------------------------|:-------------------------------|\r\n * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |\r\n * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |\r\n * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |\r\n * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |\r\n * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |\r\n *\r\n * Only the XMP contexts required for a packet should be assigned, and different packets\r\n * in the same asset may use different contexts.\r\n *\r\n * Properties:\r\n * - {@link Packet}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { XMP, Packet } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const xmpExtension = document.createExtension(XMP);\r\n *\r\n * // Create Packet property.\r\n * const packet = xmpExtension.createPacket()\r\n * \t.setContext({\r\n * \t\tdc: 'http://purl.org/dc/elements/1.1/',\r\n * \t})\r\n *\t.setProperty('dc:Creator', {\"@list\": [\"Acme, Inc.\"]});\r\n *\r\n * // Option 1: Assign to Document Root.\r\n * document.getRoot().setExtension('KHR_xmp_json_ld', packet);\r\n *\r\n * // Option 2: Assign to a specific Property.\r\n * texture.setExtension('KHR_xmp_json_ld', packet);\r\n * ```\r\n */\r\nexport class XMP extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\r\n\tpublic createPacket(): Packet {\r\n\t\treturn new Packet(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Lists XMP packets currently defined in a {@link Document}. */\r\n\tpublic listPackets(): Packet[] {\r\n\t\treturn Array.from(this.properties) as Packet[];\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst extensionDef = context.jsonDoc.json.extensions?.[NAME] as XMPRootDef | undefined;\r\n\t\tif (!extensionDef || !extensionDef.packets) return this;\r\n\r\n\t\t// Deserialize packets.\r\n\t\tconst json = context.jsonDoc.json;\r\n\t\tconst root = this.document.getRoot();\r\n\t\tconst packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\r\n\r\n\t\tconst defLists = [\r\n\t\t\t[json.asset],\r\n\t\t\tjson.scenes,\r\n\t\t\tjson.nodes,\r\n\t\t\tjson.meshes,\r\n\t\t\tjson.materials,\r\n\t\t\tjson.images,\r\n\t\t\tjson.animations,\r\n\t\t];\r\n\r\n\t\tconst propertyLists = [\r\n\t\t\t[root],\r\n\t\t\troot.listScenes(),\r\n\t\t\troot.listNodes(),\r\n\t\t\troot.listMeshes(),\r\n\t\t\troot.listMaterials(),\r\n\t\t\troot.listTextures(),\r\n\t\t\troot.listAnimations(),\r\n\t\t];\r\n\r\n\t\t// Assign packets.\r\n\t\tfor (let i = 0; i < defLists.length; i++) {\r\n\t\t\tconst defs = defLists[i] || [];\r\n\t\t\tfor (let j = 0; j < defs.length; j++) {\r\n\t\t\t\tconst def = defs[j];\r\n\t\t\t\tif (def.extensions && def.extensions[NAME]) {\r\n\t\t\t\t\tconst xmpDef = def.extensions[NAME] as XMPPropertyDef;\r\n\t\t\t\t\tpropertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst { json } = context.jsonDoc;\r\n\r\n\t\tconst packetDefs = [];\r\n\r\n\t\tfor (const packet of this.properties as Set<Packet>) {\r\n\t\t\t// Serialize packets.\r\n\t\t\tpacketDefs.push(packet.toJSONLD());\r\n\r\n\t\t\t// Assign packets.\r\n\r\n\t\t\tfor (const parent of packet.listParents()) {\r\n\t\t\t\tlet parentDef: XMPParentDef | null;\r\n\r\n\t\t\t\tswitch (parent.propertyType) {\r\n\t\t\t\t\tcase PropertyType.ROOT:\r\n\t\t\t\t\t\tparentDef = json.asset;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.SCENE:\r\n\t\t\t\t\t\tparentDef = json.scenes![context.sceneIndexMap.get(parent as Scene)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.NODE:\r\n\t\t\t\t\t\tparentDef = json.nodes![context.nodeIndexMap.get(parent as Node)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.MESH:\r\n\t\t\t\t\t\tparentDef = json.meshes![context.meshIndexMap.get(parent as Mesh)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.MATERIAL:\r\n\t\t\t\t\t\tparentDef = json.materials![context.materialIndexMap.get(parent as Material)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.TEXTURE:\r\n\t\t\t\t\t\tparentDef = json.images![context.imageIndexMap.get(parent as Texture)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.ANIMATION:\r\n\t\t\t\t\t\tparentDef = json.animations![context.animationIndexMap.get(parent as Animation)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tparentDef = null;\r\n\t\t\t\t\t\tthis.document\r\n\t\t\t\t\t\t\t.getLogger()\r\n\t\t\t\t\t\t\t.warn(`[${NAME}]: Unsupported parent property, \"${parent.propertyType}\"`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!parentDef) continue;\r\n\r\n\t\t\t\tparentDef.extensions = parentDef.extensions || {};\r\n\t\t\t\tparentDef.extensions[NAME] = { packet: packetDefs.length - 1 };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (packetDefs.length > 0) {\r\n\t\t\tjson.extensions = json.extensions || {};\r\n\t\t\tjson.extensions[NAME] = { packets: packetDefs };\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","/** @module extensions */\r\n\r\nimport { MeshGPUInstancing } from './ext-mesh-gpu-instancing';\r\nimport { MeshoptCompression } from './ext-meshopt-compression';\r\nimport { TextureWebP } from './ext-texture-webp';\r\nimport { DracoMeshCompression } from './khr-draco-mesh-compression';\r\nimport { LightsPunctual } from './khr-lights-punctual';\r\nimport { MaterialsAnisotropy } from './khr-materials-anisotropy';\r\nimport { MaterialsClearcoat } from './khr-materials-clearcoat';\r\nimport { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';\r\nimport { MaterialsIOR } from './khr-materials-ior';\r\nimport { MaterialsIridescence } from './khr-materials-iridescence';\r\nimport { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';\r\nimport { MaterialsSheen } from './khr-materials-sheen';\r\nimport { MaterialsSpecular } from './khr-materials-specular';\r\nimport { MaterialsTranslucency } from './khr-materials-translucency';\r\nimport { MaterialsTransmission } from './khr-materials-transmission';\r\nimport { MaterialsUnlit } from './khr-materials-unlit';\r\nimport { MaterialsVariants } from './khr-materials-variants';\r\nimport { MaterialsVolume } from './khr-materials-volume';\r\nimport { MeshQuantization } from './khr-mesh-quantization';\r\nimport { TextureBasisu } from './khr-texture-basisu';\r\nimport { TextureTransform } from './khr-texture-transform';\r\nimport { XMP } from './khr-xmp-json-ld';\r\n\r\nexport const KHRONOS_EXTENSIONS = [\r\n\tDracoMeshCompression,\r\n\tLightsPunctual,\r\n  MaterialsAnisotropy,\r\n\tMaterialsClearcoat,\r\n\tMaterialsEmissiveStrength,\r\n\tMaterialsIOR,\r\n\tMaterialsIridescence,\r\n\tMaterialsPBRSpecularGlossiness,\r\n\tMaterialsSpecular,\r\n\tMaterialsSheen,\r\n  MaterialsTranslucency,\r\n\tMaterialsTransmission,\r\n\tMaterialsUnlit,\r\n\tMaterialsVariants,\r\n\tMaterialsVolume,\r\n\tMeshQuantization,\r\n\tTextureBasisu,\r\n\tTextureTransform,\r\n\tXMP,\r\n];\r\n\r\nexport const ALL_EXTENSIONS = [MeshGPUInstancing, MeshoptCompression, TextureWebP, ...KHRONOS_EXTENSIONS];\r\n\r\nexport * from './ext-mesh-gpu-instancing';\r\nexport * from './ext-meshopt-compression';\r\nexport * from './ext-texture-webp';\r\nexport * from './khr-draco-mesh-compression';\r\nexport * from './khr-lights-punctual';\r\nexport * from './khr-materials-anisotropy';\r\nexport * from './khr-materials-clearcoat';\r\nexport * from './khr-materials-emissive-strength';\r\nexport * from './khr-materials-ior';\r\nexport * from './khr-materials-iridescence';\r\nexport * from './khr-materials-sheen';\r\nexport * from './khr-materials-specular';\r\nexport * from './khr-materials-pbr-specular-glossiness';\r\nexport * from './khr-materials-translucency';\r\nexport * from './khr-materials-transmission';\r\nexport * from './khr-materials-unlit';\r\nexport * from './khr-materials-variants';\r\nexport * from './khr-materials-volume';\r\nexport * from './khr-mesh-quantization';\r\nexport * from './khr-texture-basisu';\r\nexport * from './khr-texture-transform';\r\nexport * from './khr-xmp-json-ld';\r\n"],"names":["InstancedMesh","ExtensionProperty","init","this","extensionName","propertyType","parentTypes","PropertyType","NODE","getDefaults","Object","assign","super","attributes","getAttribute","semantic","getRefMap","setAttribute","accessor","setRefMap","usage","listAttributes","listRefMapValues","listSemantics","listRefMapKeys","EXTENSION_NAME","NAME","MeshGPUInstancing","Extension","provideTypes","prewriteTypes","ACCESSOR","createInstancedMesh","document","getGraph","read","context","jsonDoc","json","nodes","forEach","nodeDef","nodeIndex","extensions","instancedMeshDef","instancedMesh","accessors","setExtension","prewrite","accessorUsageGroupedByParent","add","prop","properties","attribute","addAccessorToUsageGroup","write","getRoot","listNodes","node","getExtension","nodeIndexMap","get","accessorIndexMap","EncoderMethod","MeshoptMode","MeshoptFilter","BYTE","SHORT","FLOAT","Accessor","ComponentType","normalize","denormalize","MathUtils","prepareAccessor","encoder","mode","filterOptions","filter","bits","result","array","getArray","byteStride","getElementSize","getComponentSize","componentType","getComponentType","normalized","getNormalized","ATTRIBUTES","NONE","srcArray","dstArray","Float32Array","length","i","denormalizeArray","EXPONENTIAL","encodeFilterExp","getCount","OCTAHEDRAL","il","padNormals","encodeFilterOct","QUATERNION","encodeFilterQuat","Error","min","getMin","max","getMax","map","v","elementSize","elementStride","BufferUtils","padNumber","BYTES_PER_ELEMENT","constructor","j","padArrayElements","byteLength","getMeshoptMode","WriterContext","BufferViewUsage","ELEMENT_ARRAY_BUFFER","listParents","some","parent","Primitive","getMode","Mode","TRIANGLES","INDICES","getMeshoptFilter","doc","refs","listParentEdges","edge","getParent","Root","ref","refName","getName","refKey","getAttributes","key","startsWith","targetPath","getTargetPath","sampler","AnimationSampler","channel","AnimationChannel","DEFAULT_ENCODER_OPTIONS","method","QUANTIZE","MeshoptCompression","prereadTypes","BUFFER","PRIMITIVE","readDependencies","writeDependencies","_decoder","_decoderFallbackBufferMap","Map","_encoder","_encoderOptions","_encoderFallbackBuffer","_encoderBufferViews","_encoderBufferViewData","_encoderBufferViewAccessors","install","dependency","setEncoderOptions","options","preread","isRequired","supported","_prereadBuffers","_prereadPrimitives","bufferViews","viewDef","index","meshoptDef","byteOffset","count","stride","Uint8Array","bufferDef","buffers","buffer","source","toView","uri","resources","GLB_BUFFER","decodeGltfBuffer","fallback","set","_context","fallbackBuffer","swap","dispose","_prewriteAccessors","_prewriteBuffers","createBuffer","fallbackBufferIndex","listBuffers","indexOf","listAccessors","getAccessorUsage","FILTER","preparedAccessor","getBuffer","bufferIndex","join","bufferView","bufferViewData","bufferViewAccessors","target","USAGE_TO_TARGET","ARRAY_BUFFER","undefined","[object Object]","accessorDef","createAccessorDef","push","EXT_meshopt_compression","otherBufferViews","concat","encodeGltfBuffer","compressedData","pad","fallbackBufferByteOffset","bufferViewIndex","otherBufferViewsIndexMap","finalBufferViewDef","compressedByteOffset","bufferIndexMap","fallbackBufferDef","WEBPImageUtils","match","getSize","RIFF","decodeText","slice","WEBP","view","DataView","offset","chunkId","getUint8","chunkByteLength","getUint32","getInt16","b0","b1","b2","getChannels","_buffer","TextureWebP","TEXTURE","ImageUtils","registerFormat","textures","textureDef","listTextures","texture","getMimeType","imageIndex","imageIndexMap","decoderModule","COMPONENT_ARRAY","DATA_TYPE","encoderModule","decodeGeometry","decoder","data","DecoderBuffer","Init","GetEncodedGeometryType","TRIANGULAR_MESH","dracoMesh","Mesh","DecodeBufferToMesh","ok","ptr","destroy","decodeIndex","mesh","numIndices","num_faces","indices","num_points","Uint16Array","_malloc","GetTrianglesUInt16Array","HEAPU16","Uint32Array","GetTrianglesUInt32Array","HEAPU32","_free","decodeAttribute","dataType","ArrayCtor","numComponents","num_components","numValues","GetAttributeDataArrayForAllPoints","HEAPF32","AttributeEnum","DEFAULT_QUANTIZATION_BITS","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","decodeSpeed","encodeSpeed","EDGEBREAKER","quantizationBits","quantizationVolume","encodeGeometry","prim","_options","Encoder","builder","MeshBuilder","attributeIDs","dracoBuffer","DracoInt8Array","attributeEnum","getAttributeEnum","attributeID","addAttribute","SetAttributeQuantization","range","Math","SetAttributeExplicitQuantization","getIndices","AddFacesToMesh","SetSpeedOptions","SetTrackEncodedProperties","SEQUENTIAL","listTargets","SetEncodingMethod","MESH_SEQUENTIAL_ENCODING","MESH_EDGEBREAKER_ENCODING","EncodeMeshToDracoBuffer","GetValue","prevNumVertices","numVertices","GetNumberOfEncodedPoints","GetNumberOfEncodedFaces","itemSize","UNSIGNED_BYTE","AddUInt8Attribute","AddInt8Attribute","UNSIGNED_SHORT","AddUInt16Attribute","AddInt16Attribute","UNSIGNED_INT","AddUInt32Attribute","AddFloatAttribute","DracoMeshCompression","_decoderModule","_encoderModule","Int16Array","Int8Array","DT_FLOAT32","DT_UINT32","DT_UINT16","DT_UINT8","DT_INT16","DT_INT8","logger","getLogger","dracoMeshes","meshDefs","meshes","meshDef","primDef","primitives","dracoDef","bufferViewDef","Decoder","debug","dracoAttribute","GetAttributeByUniqueId","attributeArray","setArray","Array","from","values","_propertyType","JSON","stringify","primitiveHashMap","included","Set","excluded","listMeshes","listPrimitives","warn","accessorIndices","includedAccessors","includedHashKeys","primToHashKey","hashKey","createHashKey","has","dstIndices","clone","dstAttribute","keys","size","ROOT","attr","listDracoPrimitives","primitiveEncodingMap","listScenes","bounds","pop","primHash","accessorDefs","encodedPrim","indicesDef","attributeDef","extensionData","dracoContext","meshIndexMap","extensionsUsed","name","extensionsRequired","indexMap","hashElements","sort","Light","color","intensity","type","Type","POINT","innerConeAngle","outerConeAngle","PI","getColor","setColor","getColorHex","ColorUtils","factorToHex","setColorHex","hex","hexToFactor","getIntensity","setIntensity","getType","setType","getRange","setRange","getInnerConeAngle","setInnerConeAngle","angle","getOuterConeAngle","setOuterConeAngle","SPOT","DIRECTIONAL","LightsPunctual","createLight","lights","lightDef","light","setName","spot","lightDefs","lightIndexMap","property","eq","R","G","TextureChannel","Anisotropy","MATERIAL","anisotropy","anisotropyTexture","anisotropyTextureInfo","TextureInfo","graph","anisotropyDirection","anisotropyDirectionTexture","anisotropyDirectionTextureInfo","getAnisotropy","setAnisotropy","val","getAnisotropyTexture","getRef","getAnisotropyTextureInfo","setAnisotropyTexture","setRef","channels","getAnisotropyDirection","setAnisotropyDirection","direction","getAnisotropyDirectionTexture","getAnisotropyDirectionTextureInfo","setAnisotropyDirectionTexture","MaterialsAnisotropy","createAnisotropy","textureDefs","materials","materialDef","materialIndex","anisotropyDef","textureInfoDef","setTextureInfo","listMaterials","material","materialIndexMap","textureInfo","createTextureInfoDef","B","Clearcoat","clearcoatFactor","clearcoatTexture","clearcoatTextureInfo","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatRoughnessTextureInfo","clearcoatNormalScale","clearcoatNormalTexture","clearcoatNormalTextureInfo","getClearcoatFactor","setClearcoatFactor","factor","getClearcoatTexture","getClearcoatTextureInfo","setClearcoatTexture","getClearcoatRoughnessFactor","setClearcoatRoughnessFactor","getClearcoatRoughnessTexture","getClearcoatRoughnessTextureInfo","setClearcoatRoughnessTexture","getClearcoatNormalScale","setClearcoatNormalScale","scale","getClearcoatNormalTexture","getClearcoatNormalTextureInfo","setClearcoatNormalTexture","MaterialsClearcoat","createClearcoat","clearcoat","clearcoatDef","EmissiveStrength","emissiveStrength","getEmissiveStrength","setEmissiveStrength","strength","MaterialsEmissiveStrength","createEmissiveStrength","emissiveStrengthDef","IOR","ior","getIOR","setIOR","MaterialsIOR","createIOR","iorDef","Iridescence","iridescenceFactor","iridescenceTexture","iridescenceTextureInfo","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","iridescenceThicknessTextureInfo","getIridescenceFactor","setIridescenceFactor","getIridescenceTexture","getIridescenceTextureInfo","setIridescenceTexture","getIridescenceIOR","setIridescenceIOR","getIridescenceThicknessMinimum","setIridescenceThicknessMinimum","thickness","getIridescenceThicknessMaximum","setIridescenceThicknessMaximum","getIridescenceThicknessTexture","getIridescenceThicknessTextureInfo","setIridescenceThicknessTexture","MaterialsIridescence","createIridescence","iridescence","iridescenceDef","iridescenceIor","A","PBRSpecularGlossiness","diffuseFactor","diffuseTexture","diffuseTextureInfo","specularFactor","glossinessFactor","specularGlossinessTexture","specularGlossinessTextureInfo","getDiffuseFactor","setDiffuseFactor","getDiffuseHex","setDiffuseHex","getDiffuseTexture","getDiffuseTextureInfo","setDiffuseTexture","getSpecularFactor","setSpecularFactor","getGlossinessFactor","setGlossinessFactor","getSpecularGlossinessTexture","getSpecularGlossinessTextureInfo","setSpecularGlossinessTexture","MaterialsPBRSpecularGlossiness","createPBRSpecularGlossiness","specGloss","specGlossDef","Sheen","sheenColorFactor","sheenColorTexture","sheenColorTextureInfo","sheenRoughnessFactor","sheenRoughnessTexture","sheenRoughnessTextureInfo","getSheenColorFactor","getSheenColorHex","setSheenColorFactor","setSheenColorHex","getSheenColorTexture","getSheenColorTextureInfo","setSheenColorTexture","getSheenRoughnessFactor","setSheenRoughnessFactor","getSheenRoughnessTexture","getSheenRoughnessTextureInfo","setSheenRoughnessTexture","MaterialsSheen","createSheen","sheen","sheenDef","Specular","specularTexture","specularTextureInfo","specularColorFactor","specularColorTexture","specularColorTextureInfo","getSpecularColorFactor","setSpecularColorFactor","getSpecularColorHex","setSpecularColorHex","getSpecularTexture","getSpecularTextureInfo","setSpecularTexture","getSpecularColorTexture","getSpecularColorTextureInfo","setSpecularColorTexture","MaterialsSpecular","createSpecular","specular","specularDef","Translucency","translucencyFactor","translucencyTexture","translucencyTextureInfo","translucencyColorFactor","translucencyColorTexture","translucencyColorTextureInfo","getTranslucencyFactor","setTranslucencyFactor","getTranslucencyColorFactor","setTranslucencyColorFactor","getTranslucencyColorHex","setTranslucencyColorHex","getTranslucencyTexture","getTranslucencyTextureInfo","setTranslucencyTexture","getTranslucencyColorTexture","getTranslucencyColorTextureInfo","setTranslucencyColorTexture","MaterialsTranslucency","createTranslucency","translucency","translucencyDef","Transmission","transmissionFactor","transmissionTexture","transmissionTextureInfo","getTransmissionFactor","setTransmissionFactor","getTransmissionTexture","getTransmissionTextureInfo","setTransmissionTexture","MaterialsTransmission","createTransmission","transmission","transmissionDef","Unlit","MaterialsUnlit","createUnlit","Mapping","variants","getMaterial","setMaterial","addVariant","variant","addRef","removeVariant","removeRef","listVariants","listRefs","MappingList","mappings","addMapping","mapping","removeMapping","listMappings","Variant","MaterialsVariants","createMappingList","createVariant","createMapping","variantDef","meshIndex","primIndex","mappingList","variantPrimDef","mappingDef","variantIndex","variantDefs","variantIndexMap","createPropertyDef","mappingDefs","Volume","thicknessFactor","thicknessTexture","thicknessTextureInfo","attenuationDistance","Infinity","attenuationColor","getThicknessFactor","setThicknessFactor","getThicknessTexture","getThicknessTextureInfo","setThicknessTexture","getAttenuationDistance","setAttenuationDistance","distance","getAttenuationColor","setAttenuationColor","getAttenuationColorHex","setAttenuationColorHex","MaterialsVolume","createVolume","volume","volumeDef","Number","isFinite","MeshQuantization","_","KTX2ImageUtils","container","readKTX","pixelWidth","pixelHeight","dfd","dataFormatDescriptor","colorModel","KTX2Model","ETC1S","samples","channelID","UASTC","getGPUByteLength","hasAlpha","uncompressedBytes","levels","level","uncompressedByteLength","floor","pow","TextureBasisu","Transform","TEXTURE_INFO","rotation","texCoord","getOffset","setOffset","getRotation","setRotation","getScale","setScale","getTexCoord","setTexCoord","TextureTransform","createTransform","textureInfos","entries","transform","transformDef","textureInfoEntries","textureInfoDefMap","PARENT_TYPES","SCENE","MESH","ANIMATION","Packet","getContext","setContext","listProperties","getProperty","setProperty","value","_assertContext","toJSONLD","@context","copyJSON","fromJSONLD","jsonld","split","object","parse","XMP","createPacket","listPackets","extensionDef","packets","root","packetDef","defLists","asset","scenes","images","animations","propertyLists","listAnimations","defs","def","packet","packetDefs","parentDef","sceneIndexMap","animationIndexMap","KHRONOS_EXTENSIONS","ALL_EXTENSIONS"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/extensions.modern.js b/dist/extensions.modern.js
index 56b28c65ed23f297848f20373873beb7371f1230..039922be6e9214229625df31bd67547d238e4b0c 100644
--- a/dist/extensions.modern.js
+++ b/dist/extensions.modern.js
@@ -1,2 +1,2 @@
-import{ExtensionProperty as e,PropertyType as t,Extension as s,BufferUtils as r,WriterContext as n,Primitive as o,Root as i,AnimationSampler as a,AnimationChannel as c,Accessor as u,MathUtils as l,GLB_BUFFER as h,ImageUtils as f,bounds as g,ColorUtils as x,TextureInfo as p,TextureChannel as d}from"@gltf-transform/core";import{read as T,KTX2Model as m}from"ktx-parse";const E="INSTANCE_ATTRIBUTE";class I extends e{init(){this.extensionName="EXT_mesh_gpu_instancing",this.propertyType="InstancedMesh",this.parentTypes=[t.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:"INSTANCE_ATTRIBUTE"})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}I.EXTENSION_NAME="EXT_mesh_gpu_instancing";const R="EXT_mesh_gpu_instancing";class N extends s{constructor(...e){super(...e),this.extensionName=R,this.provideTypes=[t.NODE],this.prewriteTypes=[t.ACCESSOR]}createInstancedMesh(){return new I(this.document.getGraph())}read(e){return(e.jsonDoc.json.nodes||[]).forEach((t,s)=>{if(!t.extensions||!t.extensions[R])return;const r=t.extensions[R],n=this.createInstancedMesh();for(const t in r.attributes)n.setAttribute(t,e.accessors[r.attributes[t]]);e.nodes[s].setExtension(R,n)}),this}prewrite(e){e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");for(const t of this.properties)for(const s of t.listAttributes())e.addAccessorToUsageGroup(s,"INSTANCE_ATTRIBUTE");return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listNodes().forEach(s=>{const r=s.getExtension(R);if(r){const n=e.nodeIndexMap.get(s),o=t.json.nodes[n],i={attributes:{}};r.listSemantics().forEach(t=>{const s=r.getAttribute(t);i.attributes[t]=e.accessorIndexMap.get(s)}),o.extensions=o.extensions||{},o.extensions[R]=i}}),this}}function _(){return(_=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(e[r]=s[r])}return e}).apply(this,arguments)}var S,A,y;N.EXTENSION_NAME=R,function(e){e.QUANTIZE="quantize",e.FILTER="filter"}(S||(S={})),function(e){e.ATTRIBUTES="ATTRIBUTES",e.TRIANGLES="TRIANGLES",e.INDICES="INDICES"}(A||(A={})),function(e){e.NONE="NONE",e.OCTAHEDRAL="OCTAHEDRAL",e.QUATERNION="QUATERNION",e.EXPONENTIAL="EXPONENTIAL"}(y||(y={}));const{BYTE:C,SHORT:O,FLOAT:M}=u.ComponentType,{normalize:D,denormalize:w}=l;function F(e,t,s,n){const{filter:o,bits:i}=n,a={array:e.getArray(),byteStride:e.getElementSize()*e.getComponentSize(),componentType:e.getComponentType(),normalized:e.getNormalized()};if(s!==A.ATTRIBUTES)return a;if(o!==y.NONE){let s=e.getNormalized()?function(e){const t=e.getComponentType(),s=e.getArray(),r=new Float32Array(s.length);for(let e=0;e<s.length;e++)r[e]=w(s[e],t);return r}(e):new Float32Array(a.array);switch(o){case y.EXPONENTIAL:a.byteStride=4*e.getElementSize(),a.componentType=M,a.normalized=!1,a.array=t.encodeFilterExp(s,e.getCount(),a.byteStride,i);break;case y.OCTAHEDRAL:a.byteStride=i>8?8:4,a.componentType=i>8?O:C,a.normalized=!0,s=3===e.getElementSize()?function(e){const t=new Float32Array(4*e.length/3);for(let s=0,r=e.length/3;s<r;s++)t[4*s]=e[3*s],t[4*s+1]=e[3*s+1],t[4*s+2]=e[3*s+2];return t}(s):s,a.array=t.encodeFilterOct(s,e.getCount(),a.byteStride,i);break;case y.QUATERNION:a.byteStride=8,a.componentType=O,a.normalized=!0,a.array=t.encodeFilterQuat(s,e.getCount(),a.byteStride,i);break;default:throw new Error("Invalid filter.")}a.min=e.getMin([]),a.max=e.getMax([]),e.getNormalized()&&(a.min=a.min.map(t=>w(t,e.getComponentType())),a.max=a.max.map(t=>w(t,e.getComponentType()))),a.normalized&&(a.min=a.min.map(e=>D(e,a.componentType)),a.max=a.max.map(e=>D(e,a.componentType)))}else a.byteStride%4&&(a.array=function(e,t){const s=r.padNumber(e.BYTES_PER_ELEMENT*t)/e.BYTES_PER_ELEMENT,n=new e.constructor(e.length/t*s);for(let r=0;r*t<e.length;r++)for(let o=0;o<t;o++)n[r*s+o]=e[r*t+o];return n}(a.array,e.getElementSize()),a.byteStride=a.array.byteLength/e.getCount());return a}function b(e,t){return t===n.BufferViewUsage.ELEMENT_ARRAY_BUFFER?e.listParents().some(e=>e instanceof o&&e.getMode()===o.Mode.TRIANGLES)?A.TRIANGLES:A.INDICES:A.ATTRIBUTES}function j(e,t){const s=t.getGraph().listParentEdges(e).filter(e=>!(e.getParent()instanceof i));for(const t of s){const s=t.getName(),r=t.getAttributes().key||"";if("indices"===s)return{filter:y.NONE};if("attributes"===s){if("POSITION"===r)return{filter:y.NONE};if("TEXCOORD_0"===r)return{filter:y.NONE};if("NORMAL"===r)return{filter:y.OCTAHEDRAL,bits:8};if("TANGENT"===r)return{filter:y.OCTAHEDRAL,bits:8};if(r.startsWith("JOINTS_"))return{filter:y.NONE};if(r.startsWith("WEIGHTS_"))return{filter:y.NONE}}if("output"===s){const t=v(e);return"rotation"===t?{filter:y.QUATERNION,bits:16}:"translation"===t||"scale"===t?{filter:y.EXPONENTIAL,bits:12}:{filter:y.NONE}}if("input"===s)return{filter:y.NONE};if("inverseBindMatrices"===s)return{filter:y.NONE}}return{filter:y.NONE}}function v(e){for(const t of e.listParents())if(t instanceof a)for(const e of t.listParents())if(e instanceof c)return e.getTargetPath();return null}const k="EXT_meshopt_compression",B={method:S.QUANTIZE};class G extends s{constructor(...e){super(...e),this.extensionName=k,this.prereadTypes=[t.BUFFER,t.PRIMITIVE],this.prewriteTypes=[t.BUFFER,t.ACCESSOR],this.readDependencies=["meshopt.decoder"],this.writeDependencies=["meshopt.encoder"],this._decoder=null,this._decoderFallbackBufferMap=new Map,this._encoder=null,this._encoderOptions=B,this._encoderFallbackBuffer=null,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={}}install(e,t){return"meshopt.decoder"===e&&(this._decoder=t),"meshopt.encoder"===e&&(this._encoder=t),this}setEncoderOptions(e){return this._encoderOptions=_({},B,e),this}preread(e,s){if(!this._decoder){if(!this.isRequired())return this;throw new Error(`[${k}] Please install extension dependency, "meshopt.decoder".`)}if(!this._decoder.supported){if(!this.isRequired())return this;throw new Error(`[${k}]: Missing WASM support.`)}return s===t.BUFFER?this._prereadBuffers(e):s===t.PRIMITIVE&&this._prereadPrimitives(e),this}_prereadBuffers(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach((s,n)=>{if(!s.extensions||!s.extensions[k])return;const o=s.extensions[k],i=o.byteOffset||0,a=o.byteLength||0,c=o.count,u=o.byteStride,l=new Uint8Array(c*u),f=t.json.buffers[s.buffer],g=r.toView(f.uri?t.resources[f.uri]:t.resources[h],i,a);this._decoder.decodeGltfBuffer(l,c,u,g,o.mode,o.filter),e.bufferViews[n]=l})}_prereadPrimitives(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach(s=>{var r;s.extensions&&s.extensions[k]&&(r=t.json.buffers[s.buffer]).extensions&&r.extensions.EXT_meshopt_compression&&r.extensions.EXT_meshopt_compression.fallback&&this._decoderFallbackBufferMap.set(e.buffers[s.buffer],e.buffers[s.extensions[k].buffer])})}read(e){if(!this.isRequired())return this;for(const[e,t]of this._decoderFallbackBufferMap){for(const s of e.listParents())s instanceof u&&s.swap(e,t);e.dispose()}return this}prewrite(e,s){return s===t.ACCESSOR?this._prewriteAccessors(e):s===t.BUFFER&&this._prewriteBuffers(e),this}_prewriteAccessors(e){const t=e.jsonDoc.json,s=this._encoder,r=this._encoderOptions,o=this.document.createBuffer(),i=this.document.getRoot().listBuffers().indexOf(o);this._encoderFallbackBuffer=o,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={};for(const o of this.document.getRoot().listAccessors()){if("weights"===v(o))continue;const a=e.getAccessorUsage(o),c=b(o,a),u=r.method===S.FILTER?j(o,this.document):{filter:y.NONE},l=F(o,s,c,u),{array:h,byteStride:f}=l,g=o.getBuffer();if(!g)throw new Error(`${k}: Missing buffer for accessor.`);const x=this.document.getRoot().listBuffers().indexOf(g),p=[a,c,u.filter,f,x].join(":");let d=this._encoderBufferViews[p],T=this._encoderBufferViewData[p],m=this._encoderBufferViewAccessors[p];d&&T||(m=this._encoderBufferViewAccessors[p]=[],T=this._encoderBufferViewData[p]=[],d=this._encoderBufferViews[p]={buffer:i,target:n.USAGE_TO_TARGET[a],byteOffset:0,byteLength:0,byteStride:a===n.BufferViewUsage.ARRAY_BUFFER?f:void 0,extensions:{[k]:{buffer:x,byteOffset:0,byteLength:0,mode:c,filter:u.filter!==y.NONE?u.filter:void 0,byteStride:f,count:0}}});const E=e.createAccessorDef(o);E.componentType=l.componentType,E.normalized=l.normalized,E.byteOffset=d.byteLength,E.min&&l.min&&(E.min=l.min),E.max&&l.max&&(E.max=l.max),e.accessorIndexMap.set(o,t.accessors.length),t.accessors.push(E),m.push(E),T.push(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),d.byteLength+=h.byteLength,d.extensions.EXT_meshopt_compression.count+=o.getCount()}}_prewriteBuffers(e){const t=this._encoder;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=this._encoderBufferViewData[s],i=this.document.getRoot().listBuffers()[n.extensions[k].buffer],a=e.otherBufferViews.get(i)||[],{count:c,byteStride:u,mode:l}=n.extensions[k],h=r.concat(o),f=t.encodeGltfBuffer(h,c,u,l),g=r.pad(f);n.extensions[k].byteLength=f.byteLength,o.length=0,o.push(g),a.push(g),e.otherBufferViews.set(i,a)}}write(e){let t=0;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[s][0]),i=this._encoderBufferViewAccessors[s];for(const e of i)e.bufferView=o;const a=e.jsonDoc.json.bufferViews[o],c=a.byteOffset||0;Object.assign(a,n),a.byteOffset=t,a.extensions[k].byteOffset=c,t+=r.padNumber(n.byteLength)}const s=this._encoderFallbackBuffer,n=e.bufferIndexMap.get(s),o=e.jsonDoc.json.buffers[n];return o.byteLength=t,o.extensions={[k]:{fallback:!0}},s.dispose(),this}}G.EXTENSION_NAME=k,G.EncoderMethod=S;const H="EXT_texture_webp";class L{match(e){return e.length>=12&&87===e[8]&&69===e[9]&&66===e[10]&&80===e[11]}getSize(e){const t=r.decodeText(e.slice(0,4)),s=r.decodeText(e.slice(8,12));if("RIFF"!==t||"WEBP"!==s)return null;const n=new DataView(e.buffer,e.byteOffset);let o=12;for(;o<n.byteLength;){const e=r.decodeText(new Uint8Array([n.getUint8(o),n.getUint8(o+1),n.getUint8(o+2),n.getUint8(o+3)])),t=n.getUint32(o+4,!0);if("VP8 "===e)return[16383&n.getInt16(o+14,!0),16383&n.getInt16(o+16,!0)];if("VP8L"===e){const e=n.getUint8(o+9),t=n.getUint8(o+10),s=n.getUint8(o+11);return[1+((63&t)<<8|e),1+((15&n.getUint8(o+12))<<10|s<<2|(192&t)>>6)]}o+=8+t+t%2}return null}getChannels(e){return 4}}class U extends s{constructor(...e){super(...e),this.extensionName=H,this.prereadTypes=[t.TEXTURE]}static register(){f.registerFormat("image/webp",new L)}preread(e){return(e.jsonDoc.json.textures||[]).forEach(e=>{e.extensions&&e.extensions[H]&&(e.source=e.extensions[H].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/webp"===s.getMimeType()){const r=e.imageIndexMap.get(s);(t.json.textures||[]).forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[H]={source:e.source},delete e.source)})}}),this}}U.EXTENSION_NAME=H;const P="KHR_draco_mesh_compression";let V,X,K,z;function q(e,t){const s=new V.DecoderBuffer;try{if(s.Init(t,t.length),e.GetEncodedGeometryType(s)!==V.TRIANGULAR_MESH)throw new Error(`[${P}] Unknown geometry type.`);const r=new V.Mesh;if(!e.DecodeBufferToMesh(s,r).ok()||0===r.ptr)throw new Error(`[${P}] Decoding failure.`);return r}finally{V.destroy(s)}}function $(e,t){const s=3*t.num_faces();let r,n;if(t.num_points()<=65534){const o=s*Uint16Array.BYTES_PER_ELEMENT;r=V._malloc(o),e.GetTrianglesUInt16Array(t,o,r),n=new Uint16Array(V.HEAPU16.buffer,r,s).slice()}else{const o=s*Uint32Array.BYTES_PER_ELEMENT;r=V._malloc(o),e.GetTrianglesUInt32Array(t,o,r),n=new Uint32Array(V.HEAPU32.buffer,r,s).slice()}return V._free(r),n}function Y(e,t,s,r){const n=K[r.componentType],o=X[r.componentType],i=s.num_components(),a=t.num_points()*i,c=a*o.BYTES_PER_ELEMENT,u=V._malloc(c);e.GetAttributeDataArrayForAllPoints(t,s,n,c,u);const l=new o(V.HEAPF32.buffer,u,a).slice();return V._free(u),l}var Q,W;!function(e){e[e.EDGEBREAKER=1]="EDGEBREAKER",e[e.SEQUENTIAL=0]="SEQUENTIAL"}(Q||(Q={})),function(e){e.POSITION="POSITION",e.NORMAL="NORMAL",e.COLOR="COLOR",e.TEX_COORD="TEX_COORD",e.GENERIC="GENERIC"}(W||(W={}));const J={[W.POSITION]:14,[W.NORMAL]:10,[W.COLOR]:8,[W.TEX_COORD]:12,[W.GENERIC]:12},Z={decodeSpeed:5,encodeSpeed:5,method:Q.EDGEBREAKER,quantizationBits:J,quantizationVolume:"mesh"};function ee(e,t=Z){const s=_({},Z,t);s.quantizationBits=_({},J,t.quantizationBits);const r=new z.Encoder,n=new z.MeshBuilder,o=new z.Mesh,i={},a=new z.DracoInt8Array;for(const t of e.listSemantics()){const a=e.getAttribute(t),c=te(t),u=se(n,a.getComponentType(),o,z[c],a.getCount(),a.getElementSize(),a.getArray());if(-1===u)throw new Error(`Error compressing "${t}" attribute.`);if(i[t]=u,"mesh"===s.quantizationVolume||"POSITION"!==t)r.SetAttributeQuantization(z[c],s.quantizationBits[c]);else{if("object"!=typeof s.quantizationVolume)throw new Error("Invalid quantization volume state.");{const{quantizationVolume:e}=s,t=Math.max(e.max[0]-e.min[0],e.max[1]-e.min[1],e.max[2]-e.min[2]);r.SetAttributeExplicitQuantization(z[c],s.quantizationBits[c],a.getElementSize(),e.min,t)}}}const c=e.getIndices();if(!c)throw new Error("Primitive must have indices.");n.AddFacesToMesh(o,c.getCount()/3,c.getArray()),r.SetSpeedOptions(s.encodeSpeed,s.decodeSpeed),r.SetTrackEncodedProperties(!0),s.method===Q.SEQUENTIAL||e.listTargets().length>0?r.SetEncodingMethod(z.MESH_SEQUENTIAL_ENCODING):r.SetEncodingMethod(z.MESH_EDGEBREAKER_ENCODING);const u=r.EncodeMeshToDracoBuffer(o,a);if(u<=0)throw new Error("Error applying Draco compression.");const l=new Uint8Array(u);for(let e=0;e<u;++e)l[e]=a.GetValue(e);const h=e.getAttribute("POSITION").getCount(),f=r.GetNumberOfEncodedPoints(),g=3*r.GetNumberOfEncodedFaces();if(e.listTargets().length>0&&f!==h)throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');return z.destroy(a),z.destroy(o),z.destroy(n),z.destroy(r),{numVertices:f,numIndices:g,data:l,attributeIDs:i}}function te(e){return"POSITION"===e?W.POSITION:"NORMAL"===e?W.NORMAL:e.startsWith("COLOR_")?W.COLOR:e.startsWith("TEXCOORD_")?W.TEX_COORD:W.GENERIC}function se(e,t,s,r,n,o,i){switch(t){case u.ComponentType.UNSIGNED_BYTE:return e.AddUInt8Attribute(s,r,n,o,i);case u.ComponentType.BYTE:return e.AddInt8Attribute(s,r,n,o,i);case u.ComponentType.UNSIGNED_SHORT:return e.AddUInt16Attribute(s,r,n,o,i);case u.ComponentType.SHORT:return e.AddInt16Attribute(s,r,n,o,i);case u.ComponentType.UNSIGNED_INT:return e.AddUInt32Attribute(s,r,n,o,i);case u.ComponentType.FLOAT:return e.AddFloatAttribute(s,r,n,o,i);default:throw new Error(`Unexpected component type, "${t}".`)}}const re="KHR_draco_mesh_compression";class ne extends s{constructor(...e){super(...e),this.extensionName=re,this.prereadTypes=[t.PRIMITIVE],this.prewriteTypes=[t.ACCESSOR],this.readDependencies=["draco3d.decoder"],this.writeDependencies=["draco3d.encoder"],this._decoderModule=null,this._encoderModule=null,this._encoderOptions={}}install(e,t){return"draco3d.decoder"===e&&(this._decoderModule=t,V=this._decoderModule,X={[u.ComponentType.FLOAT]:Float32Array,[u.ComponentType.UNSIGNED_INT]:Uint32Array,[u.ComponentType.UNSIGNED_SHORT]:Uint16Array,[u.ComponentType.UNSIGNED_BYTE]:Uint8Array,[u.ComponentType.SHORT]:Int16Array,[u.ComponentType.BYTE]:Int8Array},K={[u.ComponentType.FLOAT]:V.DT_FLOAT32,[u.ComponentType.UNSIGNED_INT]:V.DT_UINT32,[u.ComponentType.UNSIGNED_SHORT]:V.DT_UINT16,[u.ComponentType.UNSIGNED_BYTE]:V.DT_UINT8,[u.ComponentType.SHORT]:V.DT_INT16,[u.ComponentType.BYTE]:V.DT_INT8}),"draco3d.encoder"===e&&(this._encoderModule=t,z=this._encoderModule),this}setEncoderOptions(e){return this._encoderOptions=e,this}preread(e){if(!this._decoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.decoder".`);const t=this.document.getLogger(),s=e.jsonDoc,n=new Map;try{const o=s.json.meshes||[];for(const i of o)for(const o of i.primitives){if(!o.extensions||!o.extensions[re])continue;const i=o.extensions[re];let[a,c]=n.get(i.bufferView)||[];if(!c||!a){const e=s.json.bufferViews[i.bufferView],o=s.json.buffers[e.buffer],u=r.toView(o.uri?s.resources[o.uri]:s.resources[h],e.byteOffset||0,e.byteLength);a=new this._decoderModule.Decoder,c=q(a,u),n.set(i.bufferView,[a,c]),t.debug(`[${re}] Decompressed ${u.byteLength} bytes.`)}for(const t in o.attributes){const s=e.jsonDoc.json.accessors[o.attributes[t]],r=a.GetAttributeByUniqueId(c,i.attributes[t]),n=Y(a,c,r,s);e.accessors[o.attributes[t]].setArray(n)}void 0!==o.indices&&e.accessors[o.indices].setArray($(a,c))}}finally{for(const[e,t]of Array.from(n.values()))this._decoderModule.destroy(e),this._decoderModule.destroy(t)}return this}read(e){return this}prewrite(e,s){if(!this._encoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.encoder".`);const r=this.document.getLogger();r.debug(`[${re}] Compression options: ${JSON.stringify(this._encoderOptions)}`);const n=function(e){const s=e.getLogger(),r=new Set,n=new Set;for(const t of e.getRoot().listMeshes())for(const e of t.listPrimitives())e.getIndices()?e.getMode()!==o.Mode.TRIANGLES?(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-TRIANGLES primitive.`)):r.add(e):(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-indexed primitive.`));const i=e.getRoot().listAccessors(),a=new Map;for(let e=0;e<i.length;e++)a.set(i[e],e);const c=new Map,u=new Set,l=new Map;for(const t of Array.from(r)){let s=oe(t,a);if(u.has(s))l.set(t,s);else{if(c.has(t.getIndices())){const s=t.getIndices(),r=s.clone();a.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}for(const s of t.listAttributes())if(c.has(s)){const r=s.clone();a.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}s=oe(t,a),u.add(s),l.set(t,s),c.set(t.getIndices(),s);for(const e of t.listAttributes())c.set(e,s)}}for(const e of Array.from(c.keys())){const s=new Set(e.listParents().map(e=>e.propertyType));if(2!==s.size||!s.has(t.PRIMITIVE)||!s.has(t.ROOT))throw new Error(`[${re}] Compressed accessors must only be used as indices or vertex attributes.`)}for(const e of Array.from(r)){const t=l.get(e),s=e.getIndices();if(c.get(s)!==t||e.listAttributes().some(e=>c.get(e)!==t))throw new Error(`[${re}] Draco primitives must share all, or no, accessors.`)}for(const e of Array.from(n)){const t=e.getIndices();if(c.has(t)||e.listAttributes().some(e=>c.has(e)))throw new Error(`[${re}] Accessor cannot be shared by compressed and uncompressed primitives.`)}return l}(this.document),i=new Map;let a="mesh";"scene"===this._encoderOptions.quantizationVolume&&(1!==this.document.getRoot().listScenes().length?r.warn(`[${re}]: quantizationVolume=scene requires exactly 1 scene.`):a=g(this.document.getRoot().listScenes().pop()));for(const t of Array.from(n.keys())){const s=n.get(t);if(!s)throw new Error("Unexpected primitive.");if(i.has(s)){i.set(s,i.get(s));continue}const r=t.getIndices(),o=e.jsonDoc.json.accessors,c=ee(t,_({},this._encoderOptions,{quantizationVolume:a}));i.set(s,c);const u=e.createAccessorDef(r);u.count=c.numIndices,e.accessorIndexMap.set(r,o.length),o.push(u);for(const s of t.listSemantics()){const r=t.getAttribute(s),n=e.createAccessorDef(r);n.count=c.numVertices,e.accessorIndexMap.set(r,o.length),o.push(n)}const l=t.getAttribute("POSITION").getBuffer()||this.document.getRoot().listBuffers()[0];e.otherBufferViews.has(l)||e.otherBufferViews.set(l,[]),e.otherBufferViews.get(l).push(c.data)}return r.debug(`[${re}] Compressed ${n.size} primitives.`),e.extensionData[re]={primitiveHashMap:n,primitiveEncodingMap:i},this}write(e){const t=e.extensionData[re];for(const s of this.document.getRoot().listMeshes()){const r=e.jsonDoc.json.meshes[e.meshIndexMap.get(s)];for(let n=0;n<s.listPrimitives().length;n++){const o=s.listPrimitives()[n],i=r.primitives[n],a=t.primitiveHashMap.get(o);if(!a)continue;const c=t.primitiveEncodingMap.get(a);i.extensions=i.extensions||{},i.extensions[re]={bufferView:e.otherBufferViewsIndexMap.get(c.data),attributes:c.attributeIDs}}}if(!t.primitiveHashMap.size){const t=e.jsonDoc.json;t.extensionsUsed=(t.extensionsUsed||[]).filter(e=>e!==re),t.extensionsRequired=(t.extensionsRequired||[]).filter(e=>e!==re)}return this}}function oe(e,t){const s=[],r=e.getIndices();s.push(t.get(r));for(const r of e.listAttributes())s.push(t.get(r));return s.sort().join("|")}ne.EXTENSION_NAME=re,ne.EncoderMethod=Q;class ie extends e{init(){this.extensionName="KHR_lights_punctual",this.propertyType="Light",this.parentTypes=[t.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{color:[1,1,1],intensity:1,type:ie.Type.POINT,range:null,innerConeAngle:0,outerConeAngle:Math.PI/4})}getColor(){return this.get("color")}setColor(e){return this.set("color",e)}getColorHex(){return x.factorToHex(this.getColor())}setColorHex(e){const t=this.getColor().slice();return x.hexToFactor(e,t),this.setColor(t)}getIntensity(){return this.get("intensity")}setIntensity(e){return this.set("intensity",e)}getType(){return this.get("type")}setType(e){return this.set("type",e)}getRange(){return this.get("range")}setRange(e){return this.set("range",e)}getInnerConeAngle(){return this.get("innerConeAngle")}setInnerConeAngle(e){return this.set("innerConeAngle",e)}getOuterConeAngle(){return this.get("outerConeAngle")}setOuterConeAngle(e){return this.set("outerConeAngle",e)}}ie.EXTENSION_NAME="KHR_lights_punctual",ie.Type={POINT:"point",SPOT:"spot",DIRECTIONAL:"directional"};const ae="KHR_lights_punctual";class ce extends s{constructor(...e){super(...e),this.extensionName=ae}createLight(e=""){return new ie(this.document.getGraph(),e)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[ae])return this;const s=(t.json.extensions[ae].lights||[]).map(e=>{var t,s;const r=this.createLight().setName(e.name||"").setType(e.type);return void 0!==e.color&&r.setColor(e.color),void 0!==e.intensity&&r.setIntensity(e.intensity),void 0!==e.range&&r.setRange(e.range),void 0!==(null==(t=e.spot)?void 0:t.innerConeAngle)&&r.setInnerConeAngle(e.spot.innerConeAngle),void 0!==(null==(s=e.spot)?void 0:s.outerConeAngle)&&r.setOuterConeAngle(e.spot.outerConeAngle),r});return t.json.nodes.forEach((t,r)=>{t.extensions&&t.extensions[ae]&&e.nodes[r].setExtension(ae,s[t.extensions[ae].light])}),this}write(e){const t=e.jsonDoc;if(0===this.properties.size)return this;const s=[],r=new Map;for(const e of this.properties){const t=e,n={type:t.getType()};l.eq(t.getColor(),[1,1,1])||(n.color=t.getColor()),1!==t.getIntensity()&&(n.intensity=t.getIntensity()),null!=t.getRange()&&(n.range=t.getRange()),t.getName()&&(n.name=t.getName()),t.getType()===ie.Type.SPOT&&(n.spot={innerConeAngle:t.getInnerConeAngle(),outerConeAngle:t.getOuterConeAngle()}),s.push(n),r.set(t,s.length-1)}return this.document.getRoot().listNodes().forEach(s=>{const n=s.getExtension(ae);if(n){const o=e.nodeIndexMap.get(s),i=t.json.nodes[o];i.extensions=i.extensions||{},i.extensions[ae]={light:r.get(n)}}}),t.json.extensions=t.json.extensions||{},t.json.extensions[ae]={lights:s},this}}ce.EXTENSION_NAME=ae;const{R:ue,G:le,B:he}=d;class fe extends e{init(){this.extensionName="KHR_materials_clearcoat",this.propertyType="Clearcoat",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{clearcoatFactor:0,clearcoatTexture:null,clearcoatTextureInfo:new p(this.graph,"clearcoatTextureInfo"),clearcoatRoughnessFactor:0,clearcoatRoughnessTexture:null,clearcoatRoughnessTextureInfo:new p(this.graph,"clearcoatRoughnessTextureInfo"),clearcoatNormalScale:1,clearcoatNormalTexture:null,clearcoatNormalTextureInfo:new p(this.graph,"clearcoatNormalTextureInfo")})}getClearcoatFactor(){return this.get("clearcoatFactor")}setClearcoatFactor(e){return this.set("clearcoatFactor",e)}getClearcoatTexture(){return this.getRef("clearcoatTexture")}getClearcoatTextureInfo(){return this.getRef("clearcoatTexture")?this.getRef("clearcoatTextureInfo"):null}setClearcoatTexture(e){return this.setRef("clearcoatTexture",e,{channels:ue})}getClearcoatRoughnessFactor(){return this.get("clearcoatRoughnessFactor")}setClearcoatRoughnessFactor(e){return this.set("clearcoatRoughnessFactor",e)}getClearcoatRoughnessTexture(){return this.getRef("clearcoatRoughnessTexture")}getClearcoatRoughnessTextureInfo(){return this.getRef("clearcoatRoughnessTexture")?this.getRef("clearcoatRoughnessTextureInfo"):null}setClearcoatRoughnessTexture(e){return this.setRef("clearcoatRoughnessTexture",e,{channels:le})}getClearcoatNormalScale(){return this.get("clearcoatNormalScale")}setClearcoatNormalScale(e){return this.set("clearcoatNormalScale",e)}getClearcoatNormalTexture(){return this.getRef("clearcoatNormalTexture")}getClearcoatNormalTextureInfo(){return this.getRef("clearcoatNormalTexture")?this.getRef("clearcoatNormalTextureInfo"):null}setClearcoatNormalTexture(e){return this.setRef("clearcoatNormalTexture",e,{channels:ue|le|he})}}fe.EXTENSION_NAME="KHR_materials_clearcoat";const ge="KHR_materials_clearcoat";class xe extends s{constructor(...e){super(...e),this.extensionName=ge}createClearcoat(){return new fe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[ge]){const n=this.createClearcoat();e.materials[r].setExtension(ge,n);const o=t.extensions[ge];if(void 0!==o.clearcoatFactor&&n.setClearcoatFactor(o.clearcoatFactor),void 0!==o.clearcoatRoughnessFactor&&n.setClearcoatRoughnessFactor(o.clearcoatRoughnessFactor),void 0!==o.clearcoatTexture){const t=o.clearcoatTexture;n.setClearcoatTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatTextureInfo(),t)}if(void 0!==o.clearcoatRoughnessTexture){const t=o.clearcoatRoughnessTexture;n.setClearcoatRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatRoughnessTextureInfo(),t)}if(void 0!==o.clearcoatNormalTexture){const t=o.clearcoatNormalTexture;n.setClearcoatNormalTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatNormalTextureInfo(),t),void 0!==t.scale&&n.setClearcoatNormalScale(t.scale)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ge);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[ge]={clearcoatFactor:r.getClearcoatFactor(),clearcoatRoughnessFactor:r.getClearcoatRoughnessFactor()};if(r.getClearcoatTexture()){const t=r.getClearcoatTexture(),s=r.getClearcoatTextureInfo();i.clearcoatTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatRoughnessTexture()){const t=r.getClearcoatRoughnessTexture(),s=r.getClearcoatRoughnessTextureInfo();i.clearcoatRoughnessTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatNormalTexture()){const t=r.getClearcoatNormalTexture(),s=r.getClearcoatNormalTextureInfo();i.clearcoatNormalTexture=e.createTextureInfoDef(t,s),1!==r.getClearcoatNormalScale()&&(i.clearcoatNormalTexture.scale=r.getClearcoatNormalScale())}}}),this}}xe.EXTENSION_NAME=ge;class pe extends e{init(){this.extensionName="KHR_materials_emissive_strength",this.propertyType="EmissiveStrength",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{emissiveStrength:1})}getEmissiveStrength(){return this.get("emissiveStrength")}setEmissiveStrength(e){return this.set("emissiveStrength",e)}}pe.EXTENSION_NAME="KHR_materials_emissive_strength";const de="KHR_materials_emissive_strength";class Te extends s{constructor(...e){super(...e),this.extensionName=de}createEmissiveStrength(){return new pe(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[de]){const r=this.createEmissiveStrength();e.materials[s].setExtension(de,r);const n=t.extensions[de];void 0!==n.emissiveStrength&&r.setEmissiveStrength(n.emissiveStrength)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(de);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[de]={emissiveStrength:r.getEmissiveStrength()}}}),this}}Te.EXTENSION_NAME=de;class me extends e{init(){this.extensionName="KHR_materials_ior",this.propertyType="IOR",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{ior:0})}getIOR(){return this.get("ior")}setIOR(e){return this.set("ior",e)}}me.EXTENSION_NAME="KHR_materials_ior";const Ee="KHR_materials_ior";class Ie extends s{constructor(...e){super(...e),this.extensionName=Ee}createIOR(){return new me(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[Ee]){const r=this.createIOR();e.materials[s].setExtension(Ee,r);const n=t.extensions[Ee];void 0!==n.ior&&r.setIOR(n.ior)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ee);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[Ee]={ior:r.getIOR()}}}),this}}Ie.EXTENSION_NAME=Ee;const{R:Re,G:Ne}=d;class _e extends e{init(){this.extensionName="KHR_materials_iridescence",this.propertyType="Iridescence",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{iridescenceFactor:0,iridescenceTexture:null,iridescenceTextureInfo:new p(this.graph,"iridescenceTextureInfo"),iridescenceIOR:1.3,iridescenceThicknessMinimum:100,iridescenceThicknessMaximum:400,iridescenceThicknessTexture:null,iridescenceThicknessTextureInfo:new p(this.graph,"iridescenceThicknessTextureInfo")})}getIridescenceFactor(){return this.get("iridescenceFactor")}setIridescenceFactor(e){return this.set("iridescenceFactor",e)}getIridescenceTexture(){return this.getRef("iridescenceTexture")}getIridescenceTextureInfo(){return this.getRef("iridescenceTexture")?this.getRef("iridescenceTextureInfo"):null}setIridescenceTexture(e){return this.setRef("iridescenceTexture",e,{channels:Re})}getIridescenceIOR(){return this.get("iridescenceIOR")}setIridescenceIOR(e){return this.set("iridescenceIOR",e)}getIridescenceThicknessMinimum(){return this.get("iridescenceThicknessMinimum")}setIridescenceThicknessMinimum(e){return this.set("iridescenceThicknessMinimum",e)}getIridescenceThicknessMaximum(){return this.get("iridescenceThicknessMaximum")}setIridescenceThicknessMaximum(e){return this.set("iridescenceThicknessMaximum",e)}getIridescenceThicknessTexture(){return this.getRef("iridescenceThicknessTexture")}getIridescenceThicknessTextureInfo(){return this.getRef("iridescenceThicknessTexture")?this.getRef("iridescenceThicknessTextureInfo"):null}setIridescenceThicknessTexture(e){return this.setRef("iridescenceThicknessTexture",e,{channels:Ne})}}_e.EXTENSION_NAME="KHR_materials_iridescence";const Se="KHR_materials_iridescence";class Ae extends s{constructor(...e){super(...e),this.extensionName=Se}createIridescence(){return new _e(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Se]){const n=this.createIridescence();e.materials[r].setExtension(Se,n);const o=t.extensions[Se];if(void 0!==o.iridescenceFactor&&n.setIridescenceFactor(o.iridescenceFactor),void 0!==o.iridescenceIOR&&n.setIridescenceIOR(o.iridescenceIOR),void 0!==o.iridescenceThicknessMinimum&&n.setIridescenceThicknessMinimum(o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&n.setIridescenceThicknessMaximum(o.iridescenceThicknessMaximum),void 0!==o.iridescenceTexture){const t=o.iridescenceTexture;n.setIridescenceTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceTextureInfo(),t)}if(void 0!==o.iridescenceThicknessTexture){const t=o.iridescenceThicknessTexture;n.setIridescenceThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Se);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Se]={};if(r.getIridescenceFactor()>0&&(i.iridescenceFactor=r.getIridescenceFactor()),1.3!==r.getIridescenceIOR()&&(i.iridescenceIOR=r.getIridescenceIOR()),100!==r.getIridescenceThicknessMinimum()&&(i.iridescenceThicknessMinimum=r.getIridescenceThicknessMinimum()),400!==r.getIridescenceThicknessMaximum()&&(i.iridescenceThicknessMaximum=r.getIridescenceThicknessMaximum()),r.getIridescenceTexture()){const t=r.getIridescenceTexture(),s=r.getIridescenceTextureInfo();i.iridescenceTexture=e.createTextureInfoDef(t,s)}if(r.getIridescenceThicknessTexture()){const t=r.getIridescenceThicknessTexture(),s=r.getIridescenceThicknessTextureInfo();i.iridescenceThicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}Ae.EXTENSION_NAME=Se;const{R:ye,G:Ce,B:Oe,A:Me}=d;class De extends e{init(){this.extensionName="KHR_materials_pbrSpecularGlossiness",this.propertyType="PBRSpecularGlossiness",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{diffuseFactor:[1,1,1,1],diffuseTexture:null,diffuseTextureInfo:new p(this.graph,"diffuseTextureInfo"),specularFactor:[1,1,1],glossinessFactor:1,specularGlossinessTexture:null,specularGlossinessTextureInfo:new p(this.graph,"specularGlossinessTextureInfo")})}getDiffuseFactor(){return this.get("diffuseFactor")}setDiffuseFactor(e){return this.set("diffuseFactor",e)}getDiffuseHex(){return x.factorToHex(this.getDiffuseFactor())}setDiffuseHex(e){const t=this.getDiffuseFactor().slice();return this.setDiffuseFactor(x.hexToFactor(e,t))}getDiffuseTexture(){return this.getRef("diffuseTexture")}getDiffuseTextureInfo(){return this.getRef("diffuseTexture")?this.getRef("diffuseTextureInfo"):null}setDiffuseTexture(e){return this.setRef("diffuseTexture",e,{channels:ye|Ce|Oe|Me})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getGlossinessFactor(){return this.get("glossinessFactor")}setGlossinessFactor(e){return this.set("glossinessFactor",e)}getSpecularGlossinessTexture(){return this.getRef("specularGlossinessTexture")}getSpecularGlossinessTextureInfo(){return this.getRef("specularGlossinessTexture")?this.getRef("specularGlossinessTextureInfo"):null}setSpecularGlossinessTexture(e){return this.setRef("specularGlossinessTexture",e,{channels:ye|Ce|Oe|Me})}}De.EXTENSION_NAME="KHR_materials_pbrSpecularGlossiness";const we="KHR_materials_pbrSpecularGlossiness";class Fe extends s{constructor(...e){super(...e),this.extensionName=we}createPBRSpecularGlossiness(){return new De(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[we]){const n=this.createPBRSpecularGlossiness();e.materials[r].setExtension(we,n);const o=t.extensions[we];if(void 0!==o.diffuseFactor&&n.setDiffuseFactor(o.diffuseFactor),void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.glossinessFactor&&n.setGlossinessFactor(o.glossinessFactor),void 0!==o.diffuseTexture){const t=o.diffuseTexture;n.setDiffuseTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getDiffuseTextureInfo(),t)}if(void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;n.setSpecularGlossinessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularGlossinessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(we);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[we]={diffuseFactor:r.getDiffuseFactor(),specularFactor:r.getSpecularFactor(),glossinessFactor:r.getGlossinessFactor()};if(r.getDiffuseTexture()){const t=r.getDiffuseTexture(),s=r.getDiffuseTextureInfo();i.diffuseTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularGlossinessTexture()){const t=r.getSpecularGlossinessTexture(),s=r.getSpecularGlossinessTextureInfo();i.specularGlossinessTexture=e.createTextureInfoDef(t,s)}}}),this}}Fe.EXTENSION_NAME=we;const{R:be,G:je,B:ve,A:ke}=d;class Be extends e{init(){this.extensionName="KHR_materials_sheen",this.propertyType="Sheen",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{sheenColorFactor:[0,0,0],sheenColorTexture:null,sheenColorTextureInfo:new p(this.graph,"sheenColorTextureInfo"),sheenRoughnessFactor:0,sheenRoughnessTexture:null,sheenRoughnessTextureInfo:new p(this.graph,"sheenRoughnessTextureInfo")})}getSheenColorFactor(){return this.get("sheenColorFactor")}getSheenColorHex(){return x.factorToHex(this.getSheenColorFactor())}setSheenColorFactor(e){return this.set("sheenColorFactor",e)}setSheenColorHex(e){const t=this.getSheenColorFactor().slice();return this.set("sheenColorFactor",x.hexToFactor(e,t))}getSheenColorTexture(){return this.getRef("sheenColorTexture")}getSheenColorTextureInfo(){return this.getRef("sheenColorTexture")?this.getRef("sheenColorTextureInfo"):null}setSheenColorTexture(e){return this.setRef("sheenColorTexture",e,{channels:be|je|ve})}getSheenRoughnessFactor(){return this.get("sheenRoughnessFactor")}setSheenRoughnessFactor(e){return this.set("sheenRoughnessFactor",e)}getSheenRoughnessTexture(){return this.getRef("sheenRoughnessTexture")}getSheenRoughnessTextureInfo(){return this.getRef("sheenRoughnessTexture")?this.getRef("sheenRoughnessTextureInfo"):null}setSheenRoughnessTexture(e){return this.setRef("sheenRoughnessTexture",e,{channels:ke})}}Be.EXTENSION_NAME="KHR_materials_sheen";const Ge="KHR_materials_sheen";class He extends s{constructor(...e){super(...e),this.extensionName=Ge}createSheen(){return new Be(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ge]){const n=this.createSheen();e.materials[r].setExtension(Ge,n);const o=t.extensions[Ge];if(void 0!==o.sheenColorFactor&&n.setSheenColorFactor(o.sheenColorFactor),void 0!==o.sheenRoughnessFactor&&n.setSheenRoughnessFactor(o.sheenRoughnessFactor),void 0!==o.sheenColorTexture){const t=o.sheenColorTexture;n.setSheenColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenColorTextureInfo(),t)}if(void 0!==o.sheenRoughnessTexture){const t=o.sheenRoughnessTexture;n.setSheenRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenRoughnessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ge);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ge]={sheenColorFactor:r.getSheenColorFactor(),sheenRoughnessFactor:r.getSheenRoughnessFactor()};if(r.getSheenColorTexture()){const t=r.getSheenColorTexture(),s=r.getSheenColorTextureInfo();i.sheenColorTexture=e.createTextureInfoDef(t,s)}if(r.getSheenRoughnessTexture()){const t=r.getSheenRoughnessTexture(),s=r.getSheenRoughnessTextureInfo();i.sheenRoughnessTexture=e.createTextureInfoDef(t,s)}}}),this}}He.EXTENSION_NAME=Ge;const{R:Le,G:Ue,B:Pe,A:Ve}=d;class Xe extends e{init(){this.extensionName="KHR_materials_specular",this.propertyType="Specular",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{specularFactor:1,specularTexture:null,specularTextureInfo:new p(this.graph,"specularTextureInfo"),specularColorFactor:[1,1,1],specularColorTexture:null,specularColorTextureInfo:new p(this.graph,"specularColorTextureInfo")})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getSpecularColorFactor(){return this.get("specularColorFactor")}setSpecularColorFactor(e){return this.set("specularColorFactor",e)}getSpecularColorHex(){return x.factorToHex(this.getSpecularColorFactor())}setSpecularColorHex(e){const t=this.getSpecularColorFactor().slice();return this.set("specularColorFactor",x.hexToFactor(e,t))}getSpecularTexture(){return this.getRef("specularTexture")}getSpecularTextureInfo(){return this.getRef("specularTexture")?this.getRef("specularTextureInfo"):null}setSpecularTexture(e){return this.setRef("specularTexture",e,{channels:Ve})}getSpecularColorTexture(){return this.getRef("specularColorTexture")}getSpecularColorTextureInfo(){return this.getRef("specularColorTexture")?this.getRef("specularColorTextureInfo"):null}setSpecularColorTexture(e){return this.setRef("specularColorTexture",e,{channels:Le|Ue|Pe})}}Xe.EXTENSION_NAME="KHR_materials_specular";const Ke="KHR_materials_specular";class ze extends s{constructor(...e){super(...e),this.extensionName=Ke}createSpecular(){return new Xe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ke]){const n=this.createSpecular();e.materials[r].setExtension(Ke,n);const o=t.extensions[Ke];if(void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.specularColorFactor&&n.setSpecularColorFactor(o.specularColorFactor),void 0!==o.specularTexture){const t=o.specularTexture;n.setSpecularTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularTextureInfo(),t)}if(void 0!==o.specularColorTexture){const t=o.specularColorTexture;n.setSpecularColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularColorTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ke);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ke]={};if(1!==r.getSpecularFactor()&&(i.specularFactor=r.getSpecularFactor()),l.eq(r.getSpecularColorFactor(),[1,1,1])||(i.specularColorFactor=r.getSpecularColorFactor()),r.getSpecularTexture()){const t=r.getSpecularTexture(),s=r.getSpecularTextureInfo();i.specularTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularColorTexture()){const t=r.getSpecularColorTexture(),s=r.getSpecularColorTextureInfo();i.specularColorTexture=e.createTextureInfoDef(t,s)}}}),this}}ze.EXTENSION_NAME=Ke;const{R:qe}=d;class $e extends e{init(){this.extensionName="KHR_materials_transmission",this.propertyType="Transmission",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{transmissionFactor:0,transmissionTexture:null,transmissionTextureInfo:new p(this.graph,"transmissionTextureInfo")})}getTransmissionFactor(){return this.get("transmissionFactor")}setTransmissionFactor(e){return this.set("transmissionFactor",e)}getTransmissionTexture(){return this.getRef("transmissionTexture")}getTransmissionTextureInfo(){return this.getRef("transmissionTexture")?this.getRef("transmissionTextureInfo"):null}setTransmissionTexture(e){return this.setRef("transmissionTexture",e,{channels:qe})}}$e.EXTENSION_NAME="KHR_materials_transmission";const Ye="KHR_materials_transmission";class Qe extends s{constructor(...e){super(...e),this.extensionName=Ye}createTransmission(){return new $e(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ye]){const n=this.createTransmission();e.materials[r].setExtension(Ye,n);const o=t.extensions[Ye];if(void 0!==o.transmissionFactor&&n.setTransmissionFactor(o.transmissionFactor),void 0!==o.transmissionTexture){const t=o.transmissionTexture;n.setTransmissionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTransmissionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ye);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ye]={transmissionFactor:r.getTransmissionFactor()};if(r.getTransmissionTexture()){const t=r.getTransmissionTexture(),s=r.getTransmissionTextureInfo();i.transmissionTexture=e.createTextureInfoDef(t,s)}}}),this}}Qe.EXTENSION_NAME=Ye;class We extends e{init(){this.extensionName="KHR_materials_unlit",this.propertyType="Unlit",this.parentTypes=[t.MATERIAL]}}We.EXTENSION_NAME="KHR_materials_unlit";const Je="KHR_materials_unlit";class Ze extends s{constructor(...e){super(...e),this.extensionName=Je}createUnlit(){return new We(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{t.extensions&&t.extensions[Je]&&e.materials[s].setExtension(Je,this.createUnlit())}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{if(s.getExtension(Je)){const r=e.materialIndexMap.get(s),n=t.json.materials[r];n.extensions=n.extensions||{},n.extensions[Je]={}}}),this}}Ze.EXTENSION_NAME=Je;class et extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="Mapping",this.parentTypes=["MappingList"]}getDefaults(){return Object.assign(super.getDefaults(),{material:null,variants:[]})}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}addVariant(e){return this.addRef("variants",e)}removeVariant(e){return this.removeRef("variants",e)}listVariants(){return this.listRefs("variants")}}et.EXTENSION_NAME="KHR_materials_variants";class tt extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="MappingList",this.parentTypes=[t.PRIMITIVE]}getDefaults(){return Object.assign(super.getDefaults(),{mappings:[]})}addMapping(e){return this.addRef("mappings",e)}removeMapping(e){return this.removeRef("mappings",e)}listMappings(){return this.listRefs("mappings")}}tt.EXTENSION_NAME="KHR_materials_variants";class st extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="Variant",this.parentTypes=["MappingList"]}}st.EXTENSION_NAME="KHR_materials_variants";const rt="KHR_materials_variants";class nt extends s{constructor(...e){super(...e),this.extensionName=rt}createMappingList(){return new tt(this.document.getGraph())}createVariant(e=""){return new st(this.document.getGraph(),e)}createMapping(){return new et(this.document.getGraph())}listVariants(){return Array.from(this.properties).filter(e=>e instanceof st)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[rt])return this;const s=(t.json.extensions[rt].variants||[]).map(e=>this.createVariant().setName(e.name||""));return(t.json.meshes||[]).forEach((t,r)=>{const n=e.meshes[r];(t.primitives||[]).forEach((t,r)=>{if(!t.extensions||!t.extensions[rt])return;const o=this.createMappingList(),i=t.extensions[rt];for(const t of i.mappings){const r=this.createMapping();void 0!==t.material&&r.setMaterial(e.materials[t.material]);for(const e of t.variants||[])r.addVariant(s[e]);o.addMapping(r)}n.listPrimitives()[r].setExtension(rt,o)})}),this}write(e){const t=e.jsonDoc,s=this.listVariants();if(!s.length)return this;const r=[],n=new Map;for(const t of s)n.set(t,r.length),r.push(e.createPropertyDef(t));for(const t of this.document.getRoot().listMeshes()){const s=e.meshIndexMap.get(t);t.listPrimitives().forEach((t,r)=>{const o=t.getExtension(rt);if(!o)return;const i=e.jsonDoc.json.meshes[s].primitives[r],a=o.listMappings().map(t=>{const s=e.createPropertyDef(t),r=t.getMaterial();return r&&(s.material=e.materialIndexMap.get(r)),s.variants=t.listVariants().map(e=>n.get(e)),s});i.extensions=i.extensions||{},i.extensions[rt]={mappings:a}})}return t.json.extensions=t.json.extensions||{},t.json.extensions[rt]={variants:r},this}}nt.EXTENSION_NAME=rt;const{G:ot}=d;class it extends e{init(){this.extensionName="KHR_materials_volume",this.propertyType="Volume",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{thicknessFactor:0,thicknessTexture:null,thicknessTextureInfo:new p(this.graph,"thicknessTexture"),attenuationDistance:Infinity,attenuationColor:[1,1,1]})}getThicknessFactor(){return this.get("thicknessFactor")}setThicknessFactor(e){return this.set("thicknessFactor",e)}getThicknessTexture(){return this.getRef("thicknessTexture")}getThicknessTextureInfo(){return this.getRef("thicknessTexture")?this.getRef("thicknessTextureInfo"):null}setThicknessTexture(e){return this.setRef("thicknessTexture",e,{channels:ot})}getAttenuationDistance(){return this.get("attenuationDistance")}setAttenuationDistance(e){return this.set("attenuationDistance",e)}getAttenuationColor(){return this.get("attenuationColor")}setAttenuationColor(e){return this.set("attenuationColor",e)}getAttenuationColorHex(){return x.factorToHex(this.getAttenuationColor())}setAttenuationColorHex(e){const t=this.getAttenuationColor().slice();return this.set("attenuationColor",x.hexToFactor(e,t))}}it.EXTENSION_NAME="KHR_materials_volume";const at="KHR_materials_volume";class ct extends s{constructor(...e){super(...e),this.extensionName=at}createVolume(){return new it(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[at]){const n=this.createVolume();e.materials[r].setExtension(at,n);const o=t.extensions[at];if(void 0!==o.thicknessFactor&&n.setThicknessFactor(o.thicknessFactor),void 0!==o.attenuationDistance&&n.setAttenuationDistance(o.attenuationDistance),void 0!==o.attenuationColor&&n.setAttenuationColor(o.attenuationColor),void 0!==o.thicknessTexture){const t=o.thicknessTexture;n.setThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(at);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[at]={};if(r.getThicknessFactor()>0&&(i.thicknessFactor=r.getThicknessFactor()),Number.isFinite(r.getAttenuationDistance())&&(i.attenuationDistance=r.getAttenuationDistance()),l.eq(r.getAttenuationColor(),[1,1,1])||(i.attenuationColor=r.getAttenuationColor()),r.getThicknessTexture()){const t=r.getThicknessTexture(),s=r.getThicknessTextureInfo();i.thicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}ct.EXTENSION_NAME=at;const ut="KHR_mesh_quantization";class lt extends s{constructor(...e){super(...e),this.extensionName=ut}read(e){return this}write(e){return this}}lt.EXTENSION_NAME=ut;const ht="KHR_texture_basisu";class ft{match(e){return 171===e[0]&&75===e[1]&&84===e[2]&&88===e[3]&&32===e[4]&&50===e[5]&&48===e[6]&&187===e[7]&&13===e[8]&&10===e[9]&&26===e[10]&&10===e[11]}getSize(e){const t=T(e);return[t.pixelWidth,t.pixelHeight]}getChannels(e){const t=T(e).dataFormatDescriptor[0];if(t.colorModel===m.ETC1S)return 2===t.samples.length&&15==(15&t.samples[1].channelID)?4:3;if(t.colorModel===m.UASTC)return 3==(15&t.samples[0].channelID)?4:3;throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`)}getGPUByteLength(e){const t=T(e),s=this.getChannels(e)>3;let r=0;for(let e=0;e<t.levels.length;e++){const n=t.levels[e];r+=n.uncompressedByteLength?n.uncompressedByteLength:Math.max(1,Math.floor(t.pixelWidth/Math.pow(2,e)))/4*(Math.max(1,Math.floor(t.pixelHeight/Math.pow(2,e)))/4)*(s?16:8)}return r}}class gt extends s{constructor(...e){super(...e),this.extensionName=ht,this.prereadTypes=[t.TEXTURE]}static register(){f.registerFormat("image/ktx2",new ft)}preread(e){return e.jsonDoc.json.textures.forEach(e=>{e.extensions&&e.extensions[ht]&&(e.source=e.extensions[ht].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/ktx2"===s.getMimeType()){const r=e.imageIndexMap.get(s);t.json.textures.forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[ht]={source:e.source},delete e.source)})}}),this}}gt.EXTENSION_NAME=ht;class xt extends e{init(){this.extensionName="KHR_texture_transform",this.propertyType="Transform",this.parentTypes=[t.TEXTURE_INFO]}getDefaults(){return Object.assign(super.getDefaults(),{offset:[0,0],rotation:0,scale:[1,1],texCoord:null})}getOffset(){return this.get("offset")}setOffset(e){return this.set("offset",e)}getRotation(){return this.get("rotation")}setRotation(e){return this.set("rotation",e)}getScale(){return this.get("scale")}setScale(e){return this.set("scale",e)}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}}xt.EXTENSION_NAME="KHR_texture_transform";const pt="KHR_texture_transform";class dt extends s{constructor(...e){super(...e),this.extensionName=pt}createTransform(){return new xt(this.document.getGraph())}read(e){for(const[t,s]of Array.from(e.textureInfos.entries())){if(!s.extensions||!s.extensions[pt])continue;const e=this.createTransform(),r=s.extensions[pt];void 0!==r.offset&&e.setOffset(r.offset),void 0!==r.rotation&&e.setRotation(r.rotation),void 0!==r.scale&&e.setScale(r.scale),void 0!==r.texCoord&&e.setTexCoord(r.texCoord),t.setExtension(pt,e)}return this}write(e){const t=Array.from(e.textureInfoDefMap.entries());for(const[e,s]of t){const t=e.getExtension(pt);if(!t)continue;s.extensions=s.extensions||{};const r={},n=l.eq;n(t.getOffset(),[0,0])||(r.offset=t.getOffset()),0!==t.getRotation()&&(r.rotation=t.getRotation()),n(t.getScale(),[1,1])||(r.scale=t.getScale()),null!=t.getTexCoord()&&(r.texCoord=t.getTexCoord()),s.extensions[pt]=r}return this}}dt.EXTENSION_NAME=pt;const Tt=[t.ROOT,t.SCENE,t.NODE,t.MESH,t.MATERIAL,t.TEXTURE,t.ANIMATION];class mt extends e{init(){this.extensionName="KHR_xmp_json_ld",this.propertyType="Packet",this.parentTypes=Tt}getDefaults(){return Object.assign(super.getDefaults(),{context:{},properties:{}})}getContext(){return this.get("context")}setContext(e){return this.set("context",_({},e))}listProperties(){return Object.keys(this.get("properties"))}getProperty(e){const t=this.get("properties");return e in t?t[e]:null}setProperty(e,t){this._assertContext(e);const s=_({},this.get("properties"));return t?s[e]=t:delete s[e],this.set("properties",s)}toJSONLD(){return _({"@context":Et(this.get("context"))},Et(this.get("properties")))}fromJSONLD(e){const t=(e=Et(e))["@context"];return t&&this.set("context",t),delete e["@context"],this.set("properties",e)}_assertContext(e){if(!(e.split(":")[0]in this.get("context")))throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)}}function Et(e){return JSON.parse(JSON.stringify(e))}mt.EXTENSION_NAME="KHR_xmp_json_ld";const It="KHR_xmp_json_ld";class Rt extends s{constructor(...e){super(...e),this.extensionName=It}createPacket(){return new mt(this.document.getGraph())}listPackets(){return Array.from(this.properties)}read(e){var t;const s=null==(t=e.jsonDoc.json.extensions)?void 0:t[It];if(!s||!s.packets)return this;const r=e.jsonDoc.json,n=this.document.getRoot(),o=s.packets.map(e=>this.createPacket().fromJSONLD(e)),i=[[r.asset],r.scenes,r.nodes,r.meshes,r.materials,r.images,r.animations],a=[[n],n.listScenes(),n.listNodes(),n.listMeshes(),n.listMaterials(),n.listTextures(),n.listAnimations()];for(let e=0;e<i.length;e++){const t=i[e]||[];for(let s=0;s<t.length;s++){const r=t[s];r.extensions&&r.extensions[It]&&a[e][s].setExtension(It,o[r.extensions[It].packet])}}return this}write(e){const{json:s}=e.jsonDoc,r=[];for(const n of this.properties){r.push(n.toJSONLD());for(const o of n.listParents()){let n;switch(o.propertyType){case t.ROOT:n=s.asset;break;case t.SCENE:n=s.scenes[e.sceneIndexMap.get(o)];break;case t.NODE:n=s.nodes[e.nodeIndexMap.get(o)];break;case t.MESH:n=s.meshes[e.meshIndexMap.get(o)];break;case t.MATERIAL:n=s.materials[e.materialIndexMap.get(o)];break;case t.TEXTURE:n=s.images[e.imageIndexMap.get(o)];break;case t.ANIMATION:n=s.animations[e.animationIndexMap.get(o)];break;default:n=null,this.document.getLogger().warn(`[${It}]: Unsupported parent property, "${o.propertyType}"`)}n&&(n.extensions=n.extensions||{},n.extensions[It]={packet:r.length-1})}}return r.length>0&&(s.extensions=s.extensions||{},s.extensions[It]={packets:r}),this}}Rt.EXTENSION_NAME=It;const Nt=[ne,ce,xe,Te,Ie,Ae,Fe,ze,He,Qe,Ze,nt,ct,lt,gt,dt,Rt],_t=[N,G,U,...Nt];export{_t as ALL_EXTENSIONS,fe as Clearcoat,ne as DracoMeshCompression,pe as EmissiveStrength,E as INSTANCE_ATTRIBUTE,me as IOR,I as InstancedMesh,_e as Iridescence,Nt as KHRONOS_EXTENSIONS,ie as Light,ce as LightsPunctual,et as Mapping,tt as MappingList,xe as MaterialsClearcoat,Te as MaterialsEmissiveStrength,Ie as MaterialsIOR,Ae as MaterialsIridescence,Fe as MaterialsPBRSpecularGlossiness,He as MaterialsSheen,ze as MaterialsSpecular,Qe as MaterialsTransmission,Ze as MaterialsUnlit,nt as MaterialsVariants,ct as MaterialsVolume,N as MeshGPUInstancing,lt as MeshQuantization,G as MeshoptCompression,De as PBRSpecularGlossiness,mt as Packet,Be as Sheen,Xe as Specular,gt as TextureBasisu,dt as TextureTransform,U as TextureWebP,xt as Transform,$e as Transmission,We as Unlit,st as Variant,it as Volume,Rt as XMP};
+import{ExtensionProperty as e,PropertyType as t,Extension as s,BufferUtils as r,WriterContext as n,Primitive as o,Root as i,AnimationSampler as c,AnimationChannel as a,Accessor as u,MathUtils as l,GLB_BUFFER as h,ImageUtils as f,bounds as g,ColorUtils as x,TextureInfo as T,TextureChannel as p}from"@gltf-transform/core";import{read as d,KTX2Model as m}from"ktx-parse";const E="INSTANCE_ATTRIBUTE";class I extends e{init(){this.extensionName="EXT_mesh_gpu_instancing",this.propertyType="InstancedMesh",this.parentTypes=[t.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:"INSTANCE_ATTRIBUTE"})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}I.EXTENSION_NAME="EXT_mesh_gpu_instancing";const y="EXT_mesh_gpu_instancing";class R extends s{constructor(...e){super(...e),this.extensionName=y,this.provideTypes=[t.NODE],this.prewriteTypes=[t.ACCESSOR]}createInstancedMesh(){return new I(this.document.getGraph())}read(e){return(e.jsonDoc.json.nodes||[]).forEach((t,s)=>{if(!t.extensions||!t.extensions[y])return;const r=t.extensions[y],n=this.createInstancedMesh();for(const t in r.attributes)n.setAttribute(t,e.accessors[r.attributes[t]]);e.nodes[s].setExtension(y,n)}),this}prewrite(e){e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");for(const t of this.properties)for(const s of t.listAttributes())e.addAccessorToUsageGroup(s,"INSTANCE_ATTRIBUTE");return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listNodes().forEach(s=>{const r=s.getExtension(y);if(r){const n=e.nodeIndexMap.get(s),o=t.json.nodes[n],i={attributes:{}};r.listSemantics().forEach(t=>{const s=r.getAttribute(t);i.attributes[t]=e.accessorIndexMap.get(s)}),o.extensions=o.extensions||{},o.extensions[y]=i}}),this}}function N(){return(N=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(e[r]=s[r])}return e}).apply(this,arguments)}var A,_,C;R.EXTENSION_NAME=y,function(e){e.QUANTIZE="quantize",e.FILTER="filter"}(A||(A={})),function(e){e.ATTRIBUTES="ATTRIBUTES",e.TRIANGLES="TRIANGLES",e.INDICES="INDICES"}(_||(_={})),function(e){e.NONE="NONE",e.OCTAHEDRAL="OCTAHEDRAL",e.QUATERNION="QUATERNION",e.EXPONENTIAL="EXPONENTIAL"}(C||(C={}));const{BYTE:S,SHORT:M,FLOAT:D}=u.ComponentType,{normalize:O,denormalize:F}=l;function w(e,t,s,n){const{filter:o,bits:i}=n,c={array:e.getArray(),byteStride:e.getElementSize()*e.getComponentSize(),componentType:e.getComponentType(),normalized:e.getNormalized()};if(s!==_.ATTRIBUTES)return c;if(o!==C.NONE){let s=e.getNormalized()?function(e){const t=e.getComponentType(),s=e.getArray(),r=new Float32Array(s.length);for(let e=0;e<s.length;e++)r[e]=F(s[e],t);return r}(e):new Float32Array(c.array);switch(o){case C.EXPONENTIAL:c.byteStride=4*e.getElementSize(),c.componentType=D,c.normalized=!1,c.array=t.encodeFilterExp(s,e.getCount(),c.byteStride,i);break;case C.OCTAHEDRAL:c.byteStride=i>8?8:4,c.componentType=i>8?M:S,c.normalized=!0,s=3===e.getElementSize()?function(e){const t=new Float32Array(4*e.length/3);for(let s=0,r=e.length/3;s<r;s++)t[4*s]=e[3*s],t[4*s+1]=e[3*s+1],t[4*s+2]=e[3*s+2];return t}(s):s,c.array=t.encodeFilterOct(s,e.getCount(),c.byteStride,i);break;case C.QUATERNION:c.byteStride=8,c.componentType=M,c.normalized=!0,c.array=t.encodeFilterQuat(s,e.getCount(),c.byteStride,i);break;default:throw new Error("Invalid filter.")}c.min=e.getMin([]),c.max=e.getMax([]),e.getNormalized()&&(c.min=c.min.map(t=>F(t,e.getComponentType())),c.max=c.max.map(t=>F(t,e.getComponentType()))),c.normalized&&(c.min=c.min.map(e=>O(e,c.componentType)),c.max=c.max.map(e=>O(e,c.componentType)))}else c.byteStride%4&&(c.array=function(e,t){const s=r.padNumber(e.BYTES_PER_ELEMENT*t)/e.BYTES_PER_ELEMENT,n=new e.constructor(e.length/t*s);for(let r=0;r*t<e.length;r++)for(let o=0;o<t;o++)n[r*s+o]=e[r*t+o];return n}(c.array,e.getElementSize()),c.byteStride=c.array.byteLength/e.getCount());return c}function b(e,t){return t===n.BufferViewUsage.ELEMENT_ARRAY_BUFFER?e.listParents().some(e=>e instanceof o&&e.getMode()===o.Mode.TRIANGLES)?_.TRIANGLES:_.INDICES:_.ATTRIBUTES}function j(e,t){const s=t.getGraph().listParentEdges(e).filter(e=>!(e.getParent()instanceof i));for(const t of s){const s=t.getName(),r=t.getAttributes().key||"";if("indices"===s)return{filter:C.NONE};if("attributes"===s){if("POSITION"===r)return{filter:C.NONE};if("TEXCOORD_0"===r)return{filter:C.NONE};if("NORMAL"===r)return{filter:C.OCTAHEDRAL,bits:8};if("TANGENT"===r)return{filter:C.OCTAHEDRAL,bits:8};if(r.startsWith("JOINTS_"))return{filter:C.NONE};if(r.startsWith("WEIGHTS_"))return{filter:C.NONE}}if("output"===s){const t=v(e);return"rotation"===t?{filter:C.QUATERNION,bits:16}:"translation"===t||"scale"===t?{filter:C.EXPONENTIAL,bits:12}:{filter:C.NONE}}if("input"===s)return{filter:C.NONE};if("inverseBindMatrices"===s)return{filter:C.NONE}}return{filter:C.NONE}}function v(e){for(const t of e.listParents())if(t instanceof c)for(const e of t.listParents())if(e instanceof a)return e.getTargetPath();return null}const k="EXT_meshopt_compression",B={method:A.QUANTIZE};class H extends s{constructor(...e){super(...e),this.extensionName=k,this.prereadTypes=[t.BUFFER,t.PRIMITIVE],this.prewriteTypes=[t.BUFFER,t.ACCESSOR],this.readDependencies=["meshopt.decoder"],this.writeDependencies=["meshopt.encoder"],this._decoder=null,this._decoderFallbackBufferMap=new Map,this._encoder=null,this._encoderOptions=B,this._encoderFallbackBuffer=null,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={}}install(e,t){return"meshopt.decoder"===e&&(this._decoder=t),"meshopt.encoder"===e&&(this._encoder=t),this}setEncoderOptions(e){return this._encoderOptions=N({},B,e),this}preread(e,s){if(!this._decoder){if(!this.isRequired())return this;throw new Error(`[${k}] Please install extension dependency, "meshopt.decoder".`)}if(!this._decoder.supported){if(!this.isRequired())return this;throw new Error(`[${k}]: Missing WASM support.`)}return s===t.BUFFER?this._prereadBuffers(e):s===t.PRIMITIVE&&this._prereadPrimitives(e),this}_prereadBuffers(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach((s,n)=>{if(!s.extensions||!s.extensions[k])return;const o=s.extensions[k],i=o.byteOffset||0,c=o.byteLength||0,a=o.count,u=o.byteStride,l=new Uint8Array(a*u),f=t.json.buffers[s.buffer],g=r.toView(f.uri?t.resources[f.uri]:t.resources[h],i,c);this._decoder.decodeGltfBuffer(l,a,u,g,o.mode,o.filter),e.bufferViews[n]=l})}_prereadPrimitives(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach(s=>{var r;s.extensions&&s.extensions[k]&&(r=t.json.buffers[s.buffer]).extensions&&r.extensions.EXT_meshopt_compression&&r.extensions.EXT_meshopt_compression.fallback&&this._decoderFallbackBufferMap.set(e.buffers[s.buffer],e.buffers[s.extensions[k].buffer])})}read(e){if(!this.isRequired())return this;for(const[e,t]of this._decoderFallbackBufferMap){for(const s of e.listParents())s instanceof u&&s.swap(e,t);e.dispose()}return this}prewrite(e,s){return s===t.ACCESSOR?this._prewriteAccessors(e):s===t.BUFFER&&this._prewriteBuffers(e),this}_prewriteAccessors(e){const t=e.jsonDoc.json,s=this._encoder,r=this._encoderOptions,o=this.document.createBuffer(),i=this.document.getRoot().listBuffers().indexOf(o);this._encoderFallbackBuffer=o,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={};for(const o of this.document.getRoot().listAccessors()){if("weights"===v(o))continue;const c=e.getAccessorUsage(o),a=b(o,c),u=r.method===A.FILTER?j(o,this.document):{filter:C.NONE},l=w(o,s,a,u),{array:h,byteStride:f}=l,g=o.getBuffer();if(!g)throw new Error(`${k}: Missing buffer for accessor.`);const x=this.document.getRoot().listBuffers().indexOf(g),T=[c,a,u.filter,f,x].join(":");let p=this._encoderBufferViews[T],d=this._encoderBufferViewData[T],m=this._encoderBufferViewAccessors[T];p&&d||(m=this._encoderBufferViewAccessors[T]=[],d=this._encoderBufferViewData[T]=[],p=this._encoderBufferViews[T]={buffer:i,target:n.USAGE_TO_TARGET[c],byteOffset:0,byteLength:0,byteStride:c===n.BufferViewUsage.ARRAY_BUFFER?f:void 0,extensions:{[k]:{buffer:x,byteOffset:0,byteLength:0,mode:a,filter:u.filter!==C.NONE?u.filter:void 0,byteStride:f,count:0}}});const E=e.createAccessorDef(o);E.componentType=l.componentType,E.normalized=l.normalized,E.byteOffset=p.byteLength,E.min&&l.min&&(E.min=l.min),E.max&&l.max&&(E.max=l.max),e.accessorIndexMap.set(o,t.accessors.length),t.accessors.push(E),m.push(E),d.push(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),p.byteLength+=h.byteLength,p.extensions.EXT_meshopt_compression.count+=o.getCount()}}_prewriteBuffers(e){const t=this._encoder;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=this._encoderBufferViewData[s],i=this.document.getRoot().listBuffers()[n.extensions[k].buffer],c=e.otherBufferViews.get(i)||[],{count:a,byteStride:u,mode:l}=n.extensions[k],h=r.concat(o),f=t.encodeGltfBuffer(h,a,u,l),g=r.pad(f);n.extensions[k].byteLength=f.byteLength,o.length=0,o.push(g),c.push(g),e.otherBufferViews.set(i,c)}}write(e){let t=0;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[s][0]),i=this._encoderBufferViewAccessors[s];for(const e of i)e.bufferView=o;const c=e.jsonDoc.json.bufferViews[o],a=c.byteOffset||0;Object.assign(c,n),c.byteOffset=t,c.extensions[k].byteOffset=a,t+=r.padNumber(n.byteLength)}const s=this._encoderFallbackBuffer,n=e.bufferIndexMap.get(s),o=e.jsonDoc.json.buffers[n];return o.byteLength=t,o.extensions={[k]:{fallback:!0}},s.dispose(),this}}H.EXTENSION_NAME=k,H.EncoderMethod=A;const G="EXT_texture_webp";class L{match(e){return e.length>=12&&87===e[8]&&69===e[9]&&66===e[10]&&80===e[11]}getSize(e){const t=r.decodeText(e.slice(0,4)),s=r.decodeText(e.slice(8,12));if("RIFF"!==t||"WEBP"!==s)return null;const n=new DataView(e.buffer,e.byteOffset);let o=12;for(;o<n.byteLength;){const e=r.decodeText(new Uint8Array([n.getUint8(o),n.getUint8(o+1),n.getUint8(o+2),n.getUint8(o+3)])),t=n.getUint32(o+4,!0);if("VP8 "===e)return[16383&n.getInt16(o+14,!0),16383&n.getInt16(o+16,!0)];if("VP8L"===e){const e=n.getUint8(o+9),t=n.getUint8(o+10),s=n.getUint8(o+11);return[1+((63&t)<<8|e),1+((15&n.getUint8(o+12))<<10|s<<2|(192&t)>>6)]}o+=8+t+t%2}return null}getChannels(e){return 4}}class U extends s{constructor(...e){super(...e),this.extensionName=G,this.prereadTypes=[t.TEXTURE]}static register(){f.registerFormat("image/webp",new L)}preread(e){return(e.jsonDoc.json.textures||[]).forEach(e=>{e.extensions&&e.extensions[G]&&(e.source=e.extensions[G].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/webp"===s.getMimeType()){const r=e.imageIndexMap.get(s);(t.json.textures||[]).forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[G]={source:e.source},delete e.source)})}}),this}}U.EXTENSION_NAME=G;const P="KHR_draco_mesh_compression";let V,X,K,z;function q(e,t){const s=new V.DecoderBuffer;try{if(s.Init(t,t.length),e.GetEncodedGeometryType(s)!==V.TRIANGULAR_MESH)throw new Error(`[${P}] Unknown geometry type.`);const r=new V.Mesh;if(!e.DecodeBufferToMesh(s,r).ok()||0===r.ptr)throw new Error(`[${P}] Decoding failure.`);return r}finally{V.destroy(s)}}function $(e,t){const s=3*t.num_faces();let r,n;if(t.num_points()<=65534){const o=s*Uint16Array.BYTES_PER_ELEMENT;r=V._malloc(o),e.GetTrianglesUInt16Array(t,o,r),n=new Uint16Array(V.HEAPU16.buffer,r,s).slice()}else{const o=s*Uint32Array.BYTES_PER_ELEMENT;r=V._malloc(o),e.GetTrianglesUInt32Array(t,o,r),n=new Uint32Array(V.HEAPU32.buffer,r,s).slice()}return V._free(r),n}function Y(e,t,s,r){const n=K[r.componentType],o=X[r.componentType],i=s.num_components(),c=t.num_points()*i,a=c*o.BYTES_PER_ELEMENT,u=V._malloc(a);e.GetAttributeDataArrayForAllPoints(t,s,n,a,u);const l=new o(V.HEAPF32.buffer,u,c).slice();return V._free(u),l}var Q,W;!function(e){e[e.EDGEBREAKER=1]="EDGEBREAKER",e[e.SEQUENTIAL=0]="SEQUENTIAL"}(Q||(Q={})),function(e){e.POSITION="POSITION",e.NORMAL="NORMAL",e.COLOR="COLOR",e.TEX_COORD="TEX_COORD",e.GENERIC="GENERIC"}(W||(W={}));const J={[W.POSITION]:14,[W.NORMAL]:10,[W.COLOR]:8,[W.TEX_COORD]:12,[W.GENERIC]:12},Z={decodeSpeed:5,encodeSpeed:5,method:Q.EDGEBREAKER,quantizationBits:J,quantizationVolume:"mesh"};function ee(e,t=Z){const s=N({},Z,t);s.quantizationBits=N({},J,t.quantizationBits);const r=new z.Encoder,n=new z.MeshBuilder,o=new z.Mesh,i={},c=new z.DracoInt8Array;for(const t of e.listSemantics()){const c=e.getAttribute(t),a=te(t),u=se(n,c.getComponentType(),o,z[a],c.getCount(),c.getElementSize(),c.getArray());if(-1===u)throw new Error(`Error compressing "${t}" attribute.`);if(i[t]=u,"mesh"===s.quantizationVolume||"POSITION"!==t)r.SetAttributeQuantization(z[a],s.quantizationBits[a]);else{if("object"!=typeof s.quantizationVolume)throw new Error("Invalid quantization volume state.");{const{quantizationVolume:e}=s,t=Math.max(e.max[0]-e.min[0],e.max[1]-e.min[1],e.max[2]-e.min[2]);r.SetAttributeExplicitQuantization(z[a],s.quantizationBits[a],c.getElementSize(),e.min,t)}}}const a=e.getIndices();if(!a)throw new Error("Primitive must have indices.");n.AddFacesToMesh(o,a.getCount()/3,a.getArray()),r.SetSpeedOptions(s.encodeSpeed,s.decodeSpeed),r.SetTrackEncodedProperties(!0),s.method===Q.SEQUENTIAL||e.listTargets().length>0?r.SetEncodingMethod(z.MESH_SEQUENTIAL_ENCODING):r.SetEncodingMethod(z.MESH_EDGEBREAKER_ENCODING);const u=r.EncodeMeshToDracoBuffer(o,c);if(u<=0)throw new Error("Error applying Draco compression.");const l=new Uint8Array(u);for(let e=0;e<u;++e)l[e]=c.GetValue(e);const h=e.getAttribute("POSITION").getCount(),f=r.GetNumberOfEncodedPoints(),g=3*r.GetNumberOfEncodedFaces();if(e.listTargets().length>0&&f!==h)throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');return z.destroy(c),z.destroy(o),z.destroy(n),z.destroy(r),{numVertices:f,numIndices:g,data:l,attributeIDs:i}}function te(e){return"POSITION"===e?W.POSITION:"NORMAL"===e?W.NORMAL:e.startsWith("COLOR_")?W.COLOR:e.startsWith("TEXCOORD_")?W.TEX_COORD:W.GENERIC}function se(e,t,s,r,n,o,i){switch(t){case u.ComponentType.UNSIGNED_BYTE:return e.AddUInt8Attribute(s,r,n,o,i);case u.ComponentType.BYTE:return e.AddInt8Attribute(s,r,n,o,i);case u.ComponentType.UNSIGNED_SHORT:return e.AddUInt16Attribute(s,r,n,o,i);case u.ComponentType.SHORT:return e.AddInt16Attribute(s,r,n,o,i);case u.ComponentType.UNSIGNED_INT:return e.AddUInt32Attribute(s,r,n,o,i);case u.ComponentType.FLOAT:return e.AddFloatAttribute(s,r,n,o,i);default:throw new Error(`Unexpected component type, "${t}".`)}}const re="KHR_draco_mesh_compression";class ne extends s{constructor(...e){super(...e),this.extensionName=re,this.prereadTypes=[t.PRIMITIVE],this.prewriteTypes=[t.ACCESSOR],this.readDependencies=["draco3d.decoder"],this.writeDependencies=["draco3d.encoder"],this._decoderModule=null,this._encoderModule=null,this._encoderOptions={}}install(e,t){return"draco3d.decoder"===e&&(this._decoderModule=t,V=this._decoderModule,X={[u.ComponentType.FLOAT]:Float32Array,[u.ComponentType.UNSIGNED_INT]:Uint32Array,[u.ComponentType.UNSIGNED_SHORT]:Uint16Array,[u.ComponentType.UNSIGNED_BYTE]:Uint8Array,[u.ComponentType.SHORT]:Int16Array,[u.ComponentType.BYTE]:Int8Array},K={[u.ComponentType.FLOAT]:V.DT_FLOAT32,[u.ComponentType.UNSIGNED_INT]:V.DT_UINT32,[u.ComponentType.UNSIGNED_SHORT]:V.DT_UINT16,[u.ComponentType.UNSIGNED_BYTE]:V.DT_UINT8,[u.ComponentType.SHORT]:V.DT_INT16,[u.ComponentType.BYTE]:V.DT_INT8}),"draco3d.encoder"===e&&(this._encoderModule=t,z=this._encoderModule),this}setEncoderOptions(e){return this._encoderOptions=e,this}preread(e){if(!this._decoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.decoder".`);const t=this.document.getLogger(),s=e.jsonDoc,n=new Map;try{const o=s.json.meshes||[];for(const i of o)for(const o of i.primitives){if(!o.extensions||!o.extensions[re])continue;const i=o.extensions[re];let[c,a]=n.get(i.bufferView)||[];if(!a||!c){const e=s.json.bufferViews[i.bufferView],o=s.json.buffers[e.buffer],u=r.toView(o.uri?s.resources[o.uri]:s.resources[h],e.byteOffset||0,e.byteLength);c=new this._decoderModule.Decoder,a=q(c,u),n.set(i.bufferView,[c,a]),t.debug(`[${re}] Decompressed ${u.byteLength} bytes.`)}for(const t in o.attributes){const s=e.jsonDoc.json.accessors[o.attributes[t]],r=c.GetAttributeByUniqueId(a,i.attributes[t]),n=Y(c,a,r,s);e.accessors[o.attributes[t]].setArray(n)}void 0!==o.indices&&e.accessors[o.indices].setArray($(c,a))}}finally{for(const[e,t]of Array.from(n.values()))this._decoderModule.destroy(e),this._decoderModule.destroy(t)}return this}read(e){return this}prewrite(e,s){if(!this._encoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.encoder".`);const r=this.document.getLogger();r.debug(`[${re}] Compression options: ${JSON.stringify(this._encoderOptions)}`);const n=function(e){const s=e.getLogger(),r=new Set,n=new Set;for(const t of e.getRoot().listMeshes())for(const e of t.listPrimitives())e.getIndices()?e.getMode()!==o.Mode.TRIANGLES?(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-TRIANGLES primitive.`)):r.add(e):(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-indexed primitive.`));const i=e.getRoot().listAccessors(),c=new Map;for(let e=0;e<i.length;e++)c.set(i[e],e);const a=new Map,u=new Set,l=new Map;for(const t of Array.from(r)){let s=oe(t,c);if(u.has(s))l.set(t,s);else{if(a.has(t.getIndices())){const s=t.getIndices(),r=s.clone();c.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}for(const s of t.listAttributes())if(a.has(s)){const r=s.clone();c.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}s=oe(t,c),u.add(s),l.set(t,s),a.set(t.getIndices(),s);for(const e of t.listAttributes())a.set(e,s)}}for(const e of Array.from(a.keys())){const s=new Set(e.listParents().map(e=>e.propertyType));if(2!==s.size||!s.has(t.PRIMITIVE)||!s.has(t.ROOT))throw new Error(`[${re}] Compressed accessors must only be used as indices or vertex attributes.`)}for(const e of Array.from(r)){const t=l.get(e),s=e.getIndices();if(a.get(s)!==t||e.listAttributes().some(e=>a.get(e)!==t))throw new Error(`[${re}] Draco primitives must share all, or no, accessors.`)}for(const e of Array.from(n)){const t=e.getIndices();if(a.has(t)||e.listAttributes().some(e=>a.has(e)))throw new Error(`[${re}] Accessor cannot be shared by compressed and uncompressed primitives.`)}return l}(this.document),i=new Map;let c="mesh";"scene"===this._encoderOptions.quantizationVolume&&(1!==this.document.getRoot().listScenes().length?r.warn(`[${re}]: quantizationVolume=scene requires exactly 1 scene.`):c=g(this.document.getRoot().listScenes().pop()));for(const t of Array.from(n.keys())){const s=n.get(t);if(!s)throw new Error("Unexpected primitive.");if(i.has(s)){i.set(s,i.get(s));continue}const r=t.getIndices(),o=e.jsonDoc.json.accessors,a=ee(t,N({},this._encoderOptions,{quantizationVolume:c}));i.set(s,a);const u=e.createAccessorDef(r);u.count=a.numIndices,e.accessorIndexMap.set(r,o.length),o.push(u);for(const s of t.listSemantics()){const r=t.getAttribute(s),n=e.createAccessorDef(r);n.count=a.numVertices,e.accessorIndexMap.set(r,o.length),o.push(n)}const l=t.getAttribute("POSITION").getBuffer()||this.document.getRoot().listBuffers()[0];e.otherBufferViews.has(l)||e.otherBufferViews.set(l,[]),e.otherBufferViews.get(l).push(a.data)}return r.debug(`[${re}] Compressed ${n.size} primitives.`),e.extensionData[re]={primitiveHashMap:n,primitiveEncodingMap:i},this}write(e){const t=e.extensionData[re];for(const s of this.document.getRoot().listMeshes()){const r=e.jsonDoc.json.meshes[e.meshIndexMap.get(s)];for(let n=0;n<s.listPrimitives().length;n++){const o=s.listPrimitives()[n],i=r.primitives[n],c=t.primitiveHashMap.get(o);if(!c)continue;const a=t.primitiveEncodingMap.get(c);i.extensions=i.extensions||{},i.extensions[re]={bufferView:e.otherBufferViewsIndexMap.get(a.data),attributes:a.attributeIDs}}}if(!t.primitiveHashMap.size){const t=e.jsonDoc.json;t.extensionsUsed=(t.extensionsUsed||[]).filter(e=>e!==re),t.extensionsRequired=(t.extensionsRequired||[]).filter(e=>e!==re)}return this}}function oe(e,t){const s=[],r=e.getIndices();s.push(t.get(r));for(const r of e.listAttributes())s.push(t.get(r));return s.sort().join("|")}ne.EXTENSION_NAME=re,ne.EncoderMethod=Q;class ie extends e{init(){this.extensionName="KHR_lights_punctual",this.propertyType="Light",this.parentTypes=[t.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{color:[1,1,1],intensity:1,type:ie.Type.POINT,range:null,innerConeAngle:0,outerConeAngle:Math.PI/4})}getColor(){return this.get("color")}setColor(e){return this.set("color",e)}getColorHex(){return x.factorToHex(this.getColor())}setColorHex(e){const t=this.getColor().slice();return x.hexToFactor(e,t),this.setColor(t)}getIntensity(){return this.get("intensity")}setIntensity(e){return this.set("intensity",e)}getType(){return this.get("type")}setType(e){return this.set("type",e)}getRange(){return this.get("range")}setRange(e){return this.set("range",e)}getInnerConeAngle(){return this.get("innerConeAngle")}setInnerConeAngle(e){return this.set("innerConeAngle",e)}getOuterConeAngle(){return this.get("outerConeAngle")}setOuterConeAngle(e){return this.set("outerConeAngle",e)}}ie.EXTENSION_NAME="KHR_lights_punctual",ie.Type={POINT:"point",SPOT:"spot",DIRECTIONAL:"directional"};const ce="KHR_lights_punctual";class ae extends s{constructor(...e){super(...e),this.extensionName=ce}createLight(e=""){return new ie(this.document.getGraph(),e)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[ce])return this;const s=(t.json.extensions[ce].lights||[]).map(e=>{var t,s;const r=this.createLight().setName(e.name||"").setType(e.type);return void 0!==e.color&&r.setColor(e.color),void 0!==e.intensity&&r.setIntensity(e.intensity),void 0!==e.range&&r.setRange(e.range),void 0!==(null==(t=e.spot)?void 0:t.innerConeAngle)&&r.setInnerConeAngle(e.spot.innerConeAngle),void 0!==(null==(s=e.spot)?void 0:s.outerConeAngle)&&r.setOuterConeAngle(e.spot.outerConeAngle),r});return t.json.nodes.forEach((t,r)=>{t.extensions&&t.extensions[ce]&&e.nodes[r].setExtension(ce,s[t.extensions[ce].light])}),this}write(e){const t=e.jsonDoc;if(0===this.properties.size)return this;const s=[],r=new Map;for(const e of this.properties){const t=e,n={type:t.getType()};l.eq(t.getColor(),[1,1,1])||(n.color=t.getColor()),1!==t.getIntensity()&&(n.intensity=t.getIntensity()),null!=t.getRange()&&(n.range=t.getRange()),t.getName()&&(n.name=t.getName()),t.getType()===ie.Type.SPOT&&(n.spot={innerConeAngle:t.getInnerConeAngle(),outerConeAngle:t.getOuterConeAngle()}),s.push(n),r.set(t,s.length-1)}return this.document.getRoot().listNodes().forEach(s=>{const n=s.getExtension(ce);if(n){const o=e.nodeIndexMap.get(s),i=t.json.nodes[o];i.extensions=i.extensions||{},i.extensions[ce]={light:r.get(n)}}}),t.json.extensions=t.json.extensions||{},t.json.extensions[ce]={lights:s},this}}ae.EXTENSION_NAME=ce;const{R:ue,G:le}=p;class he extends e{init(){this.extensionName="KHR_materials_anisotropy",this.propertyType="Anisotropy",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{anisotropy:0,anisotropyTexture:null,anisotropyTextureInfo:new T(this.graph,"anisotropyTextureInfo"),anisotropyDirection:[1,0,0],anisotropyDirectionTexture:null,anisotropyDirectionTextureInfo:new T(this.graph,"anisotropyDirectionTextureInfo")})}getAnisotropy(){return this.get("anisotropy")}setAnisotropy(e){return this.set("anisotropy",e)}getAnisotropyTexture(){return this.getRef("anisotropyTexture")}getAnisotropyTextureInfo(){return this.getRef("anisotropyTexture")?this.getRef("anisotropyTextureInfo"):null}setAnisotropyTexture(e){return this.setRef("anisotropyTexture",e,{channels:ue})}getAnisotropyDirection(){return this.get("anisotropyDirection")}setAnisotropyDirection(e){return this.set("anisotropyDirection",e)}getAnisotropyDirectionTexture(){return this.getRef("anisotropyDirectionTexture")}getAnisotropyDirectionTextureInfo(){return this.getRef("anisotropyDirectionTexture")?this.getRef("anisotropyDirectionTextureInfo"):null}setAnisotropyDirectionTexture(e){return this.setRef("anisotropyDirectionTexture",e,{channels:le})}}he.EXTENSION_NAME="KHR_materials_anisotropy";const fe="KHR_materials_anisotropy";class ge extends s{constructor(...e){super(...e),this.extensionName=fe}createAnisotropy(){return new he(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[fe]){const n=this.createAnisotropy();e.materials[r].setExtension(fe,n);const o=t.extensions[fe];if(void 0!==o.anisotropy&&n.setAnisotropy(o.anisotropy),void 0!==o.anisotropyDirection&&n.setAnisotropyDirection(o.anisotropyDirection),void 0!==o.anisotropyTexture){const t=o.anisotropyTexture;n.setAnisotropyTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getAnisotropyTextureInfo(),t)}if(void 0!==o.anisotropyDirectionTexture){const t=o.anisotropyDirectionTexture;n.setAnisotropyDirectionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getAnisotropyDirectionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(fe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[fe]={anisotropy:r.getAnisotropy(),anisotropyDirection:r.getAnisotropyDirection()};if(r.getAnisotropyTexture()){const t=r.getAnisotropyTexture(),s=r.getAnisotropyTextureInfo();i.anisotropyTexture=e.createTextureInfoDef(t,s)}if(r.getAnisotropyDirectionTexture()){const t=r.getAnisotropyDirectionTexture(),s=r.getAnisotropyDirectionTextureInfo();i.anisotropyDirectionTexture=e.createTextureInfoDef(t,s)}}}),this}}ge.EXTENSION_NAME=fe;const{R:xe,G:Te,B:pe}=p;class de extends e{init(){this.extensionName="KHR_materials_clearcoat",this.propertyType="Clearcoat",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{clearcoatFactor:0,clearcoatTexture:null,clearcoatTextureInfo:new T(this.graph,"clearcoatTextureInfo"),clearcoatRoughnessFactor:0,clearcoatRoughnessTexture:null,clearcoatRoughnessTextureInfo:new T(this.graph,"clearcoatRoughnessTextureInfo"),clearcoatNormalScale:1,clearcoatNormalTexture:null,clearcoatNormalTextureInfo:new T(this.graph,"clearcoatNormalTextureInfo")})}getClearcoatFactor(){return this.get("clearcoatFactor")}setClearcoatFactor(e){return this.set("clearcoatFactor",e)}getClearcoatTexture(){return this.getRef("clearcoatTexture")}getClearcoatTextureInfo(){return this.getRef("clearcoatTexture")?this.getRef("clearcoatTextureInfo"):null}setClearcoatTexture(e){return this.setRef("clearcoatTexture",e,{channels:xe})}getClearcoatRoughnessFactor(){return this.get("clearcoatRoughnessFactor")}setClearcoatRoughnessFactor(e){return this.set("clearcoatRoughnessFactor",e)}getClearcoatRoughnessTexture(){return this.getRef("clearcoatRoughnessTexture")}getClearcoatRoughnessTextureInfo(){return this.getRef("clearcoatRoughnessTexture")?this.getRef("clearcoatRoughnessTextureInfo"):null}setClearcoatRoughnessTexture(e){return this.setRef("clearcoatRoughnessTexture",e,{channels:Te})}getClearcoatNormalScale(){return this.get("clearcoatNormalScale")}setClearcoatNormalScale(e){return this.set("clearcoatNormalScale",e)}getClearcoatNormalTexture(){return this.getRef("clearcoatNormalTexture")}getClearcoatNormalTextureInfo(){return this.getRef("clearcoatNormalTexture")?this.getRef("clearcoatNormalTextureInfo"):null}setClearcoatNormalTexture(e){return this.setRef("clearcoatNormalTexture",e,{channels:xe|Te|pe})}}de.EXTENSION_NAME="KHR_materials_clearcoat";const me="KHR_materials_clearcoat";class Ee extends s{constructor(...e){super(...e),this.extensionName=me}createClearcoat(){return new de(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[me]){const n=this.createClearcoat();e.materials[r].setExtension(me,n);const o=t.extensions[me];if(void 0!==o.clearcoatFactor&&n.setClearcoatFactor(o.clearcoatFactor),void 0!==o.clearcoatRoughnessFactor&&n.setClearcoatRoughnessFactor(o.clearcoatRoughnessFactor),void 0!==o.clearcoatTexture){const t=o.clearcoatTexture;n.setClearcoatTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatTextureInfo(),t)}if(void 0!==o.clearcoatRoughnessTexture){const t=o.clearcoatRoughnessTexture;n.setClearcoatRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatRoughnessTextureInfo(),t)}if(void 0!==o.clearcoatNormalTexture){const t=o.clearcoatNormalTexture;n.setClearcoatNormalTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatNormalTextureInfo(),t),void 0!==t.scale&&n.setClearcoatNormalScale(t.scale)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(me);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[me]={clearcoatFactor:r.getClearcoatFactor(),clearcoatRoughnessFactor:r.getClearcoatRoughnessFactor()};if(r.getClearcoatTexture()){const t=r.getClearcoatTexture(),s=r.getClearcoatTextureInfo();i.clearcoatTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatRoughnessTexture()){const t=r.getClearcoatRoughnessTexture(),s=r.getClearcoatRoughnessTextureInfo();i.clearcoatRoughnessTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatNormalTexture()){const t=r.getClearcoatNormalTexture(),s=r.getClearcoatNormalTextureInfo();i.clearcoatNormalTexture=e.createTextureInfoDef(t,s),1!==r.getClearcoatNormalScale()&&(i.clearcoatNormalTexture.scale=r.getClearcoatNormalScale())}}}),this}}Ee.EXTENSION_NAME=me;class Ie extends e{init(){this.extensionName="KHR_materials_emissive_strength",this.propertyType="EmissiveStrength",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{emissiveStrength:1})}getEmissiveStrength(){return this.get("emissiveStrength")}setEmissiveStrength(e){return this.set("emissiveStrength",e)}}Ie.EXTENSION_NAME="KHR_materials_emissive_strength";const ye="KHR_materials_emissive_strength";class Re extends s{constructor(...e){super(...e),this.extensionName=ye}createEmissiveStrength(){return new Ie(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[ye]){const r=this.createEmissiveStrength();e.materials[s].setExtension(ye,r);const n=t.extensions[ye];void 0!==n.emissiveStrength&&r.setEmissiveStrength(n.emissiveStrength)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ye);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[ye]={emissiveStrength:r.getEmissiveStrength()}}}),this}}Re.EXTENSION_NAME=ye;class Ne extends e{init(){this.extensionName="KHR_materials_ior",this.propertyType="IOR",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{ior:0})}getIOR(){return this.get("ior")}setIOR(e){return this.set("ior",e)}}Ne.EXTENSION_NAME="KHR_materials_ior";const Ae="KHR_materials_ior";class _e extends s{constructor(...e){super(...e),this.extensionName=Ae}createIOR(){return new Ne(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[Ae]){const r=this.createIOR();e.materials[s].setExtension(Ae,r);const n=t.extensions[Ae];void 0!==n.ior&&r.setIOR(n.ior)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ae);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[Ae]={ior:r.getIOR()}}}),this}}_e.EXTENSION_NAME=Ae;const{R:Ce,G:Se}=p;class Me extends e{init(){this.extensionName="KHR_materials_iridescence",this.propertyType="Iridescence",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{iridescenceFactor:0,iridescenceTexture:null,iridescenceTextureInfo:new T(this.graph,"iridescenceTextureInfo"),iridescenceIOR:1.3,iridescenceThicknessMinimum:100,iridescenceThicknessMaximum:400,iridescenceThicknessTexture:null,iridescenceThicknessTextureInfo:new T(this.graph,"iridescenceThicknessTextureInfo")})}getIridescenceFactor(){return this.get("iridescenceFactor")}setIridescenceFactor(e){return this.set("iridescenceFactor",e)}getIridescenceTexture(){return this.getRef("iridescenceTexture")}getIridescenceTextureInfo(){return this.getRef("iridescenceTexture")?this.getRef("iridescenceTextureInfo"):null}setIridescenceTexture(e){return this.setRef("iridescenceTexture",e,{channels:Ce})}getIridescenceIOR(){return this.get("iridescenceIOR")}setIridescenceIOR(e){return this.set("iridescenceIOR",e)}getIridescenceThicknessMinimum(){return this.get("iridescenceThicknessMinimum")}setIridescenceThicknessMinimum(e){return this.set("iridescenceThicknessMinimum",e)}getIridescenceThicknessMaximum(){return this.get("iridescenceThicknessMaximum")}setIridescenceThicknessMaximum(e){return this.set("iridescenceThicknessMaximum",e)}getIridescenceThicknessTexture(){return this.getRef("iridescenceThicknessTexture")}getIridescenceThicknessTextureInfo(){return this.getRef("iridescenceThicknessTexture")?this.getRef("iridescenceThicknessTextureInfo"):null}setIridescenceThicknessTexture(e){return this.setRef("iridescenceThicknessTexture",e,{channels:Se})}}Me.EXTENSION_NAME="KHR_materials_iridescence";const De="KHR_materials_iridescence";class Oe extends s{constructor(...e){super(...e),this.extensionName=De}createIridescence(){return new Me(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[De]){const n=this.createIridescence();e.materials[r].setExtension(De,n);const o=t.extensions[De];if(void 0!==o.iridescenceFactor&&n.setIridescenceFactor(o.iridescenceFactor),void 0!==o.iridescenceIor&&n.setIridescenceIOR(o.iridescenceIor),void 0!==o.iridescenceThicknessMinimum&&n.setIridescenceThicknessMinimum(o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&n.setIridescenceThicknessMaximum(o.iridescenceThicknessMaximum),void 0!==o.iridescenceTexture){const t=o.iridescenceTexture;n.setIridescenceTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceTextureInfo(),t)}if(void 0!==o.iridescenceThicknessTexture){const t=o.iridescenceThicknessTexture;n.setIridescenceThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getIridescenceThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(De);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[De]={};if(r.getIridescenceFactor()>0&&(i.iridescenceFactor=r.getIridescenceFactor()),1.3!==r.getIridescenceIOR()&&(i.iridescenceIor=r.getIridescenceIOR()),100!==r.getIridescenceThicknessMinimum()&&(i.iridescenceThicknessMinimum=r.getIridescenceThicknessMinimum()),400!==r.getIridescenceThicknessMaximum()&&(i.iridescenceThicknessMaximum=r.getIridescenceThicknessMaximum()),r.getIridescenceTexture()){const t=r.getIridescenceTexture(),s=r.getIridescenceTextureInfo();i.iridescenceTexture=e.createTextureInfoDef(t,s)}if(r.getIridescenceThicknessTexture()){const t=r.getIridescenceThicknessTexture(),s=r.getIridescenceThicknessTextureInfo();i.iridescenceThicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}Oe.EXTENSION_NAME=De;const{R:Fe,G:we,B:be,A:je}=p;class ve extends e{init(){this.extensionName="KHR_materials_pbrSpecularGlossiness",this.propertyType="PBRSpecularGlossiness",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{diffuseFactor:[1,1,1,1],diffuseTexture:null,diffuseTextureInfo:new T(this.graph,"diffuseTextureInfo"),specularFactor:[1,1,1],glossinessFactor:1,specularGlossinessTexture:null,specularGlossinessTextureInfo:new T(this.graph,"specularGlossinessTextureInfo")})}getDiffuseFactor(){return this.get("diffuseFactor")}setDiffuseFactor(e){return this.set("diffuseFactor",e)}getDiffuseHex(){return x.factorToHex(this.getDiffuseFactor())}setDiffuseHex(e){const t=this.getDiffuseFactor().slice();return this.setDiffuseFactor(x.hexToFactor(e,t))}getDiffuseTexture(){return this.getRef("diffuseTexture")}getDiffuseTextureInfo(){return this.getRef("diffuseTexture")?this.getRef("diffuseTextureInfo"):null}setDiffuseTexture(e){return this.setRef("diffuseTexture",e,{channels:Fe|we|be|je})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getGlossinessFactor(){return this.get("glossinessFactor")}setGlossinessFactor(e){return this.set("glossinessFactor",e)}getSpecularGlossinessTexture(){return this.getRef("specularGlossinessTexture")}getSpecularGlossinessTextureInfo(){return this.getRef("specularGlossinessTexture")?this.getRef("specularGlossinessTextureInfo"):null}setSpecularGlossinessTexture(e){return this.setRef("specularGlossinessTexture",e,{channels:Fe|we|be|je})}}ve.EXTENSION_NAME="KHR_materials_pbrSpecularGlossiness";const ke="KHR_materials_pbrSpecularGlossiness";class Be extends s{constructor(...e){super(...e),this.extensionName=ke}createPBRSpecularGlossiness(){return new ve(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[ke]){const n=this.createPBRSpecularGlossiness();e.materials[r].setExtension(ke,n);const o=t.extensions[ke];if(void 0!==o.diffuseFactor&&n.setDiffuseFactor(o.diffuseFactor),void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.glossinessFactor&&n.setGlossinessFactor(o.glossinessFactor),void 0!==o.diffuseTexture){const t=o.diffuseTexture;n.setDiffuseTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getDiffuseTextureInfo(),t)}if(void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;n.setSpecularGlossinessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularGlossinessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ke);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[ke]={diffuseFactor:r.getDiffuseFactor(),specularFactor:r.getSpecularFactor(),glossinessFactor:r.getGlossinessFactor()};if(r.getDiffuseTexture()){const t=r.getDiffuseTexture(),s=r.getDiffuseTextureInfo();i.diffuseTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularGlossinessTexture()){const t=r.getSpecularGlossinessTexture(),s=r.getSpecularGlossinessTextureInfo();i.specularGlossinessTexture=e.createTextureInfoDef(t,s)}}}),this}}Be.EXTENSION_NAME=ke;const{R:He,G:Ge,B:Le,A:Ue}=p;class Pe extends e{init(){this.extensionName="KHR_materials_sheen",this.propertyType="Sheen",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{sheenColorFactor:[0,0,0],sheenColorTexture:null,sheenColorTextureInfo:new T(this.graph,"sheenColorTextureInfo"),sheenRoughnessFactor:0,sheenRoughnessTexture:null,sheenRoughnessTextureInfo:new T(this.graph,"sheenRoughnessTextureInfo")})}getSheenColorFactor(){return this.get("sheenColorFactor")}getSheenColorHex(){return x.factorToHex(this.getSheenColorFactor())}setSheenColorFactor(e){return this.set("sheenColorFactor",e)}setSheenColorHex(e){const t=this.getSheenColorFactor().slice();return this.set("sheenColorFactor",x.hexToFactor(e,t))}getSheenColorTexture(){return this.getRef("sheenColorTexture")}getSheenColorTextureInfo(){return this.getRef("sheenColorTexture")?this.getRef("sheenColorTextureInfo"):null}setSheenColorTexture(e){return this.setRef("sheenColorTexture",e,{channels:He|Ge|Le})}getSheenRoughnessFactor(){return this.get("sheenRoughnessFactor")}setSheenRoughnessFactor(e){return this.set("sheenRoughnessFactor",e)}getSheenRoughnessTexture(){return this.getRef("sheenRoughnessTexture")}getSheenRoughnessTextureInfo(){return this.getRef("sheenRoughnessTexture")?this.getRef("sheenRoughnessTextureInfo"):null}setSheenRoughnessTexture(e){return this.setRef("sheenRoughnessTexture",e,{channels:Ue})}}Pe.EXTENSION_NAME="KHR_materials_sheen";const Ve="KHR_materials_sheen";class Xe extends s{constructor(...e){super(...e),this.extensionName=Ve}createSheen(){return new Pe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ve]){const n=this.createSheen();e.materials[r].setExtension(Ve,n);const o=t.extensions[Ve];if(void 0!==o.sheenColorFactor&&n.setSheenColorFactor(o.sheenColorFactor),void 0!==o.sheenRoughnessFactor&&n.setSheenRoughnessFactor(o.sheenRoughnessFactor),void 0!==o.sheenColorTexture){const t=o.sheenColorTexture;n.setSheenColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenColorTextureInfo(),t)}if(void 0!==o.sheenRoughnessTexture){const t=o.sheenRoughnessTexture;n.setSheenRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenRoughnessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ve);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ve]={sheenColorFactor:r.getSheenColorFactor(),sheenRoughnessFactor:r.getSheenRoughnessFactor()};if(r.getSheenColorTexture()){const t=r.getSheenColorTexture(),s=r.getSheenColorTextureInfo();i.sheenColorTexture=e.createTextureInfoDef(t,s)}if(r.getSheenRoughnessTexture()){const t=r.getSheenRoughnessTexture(),s=r.getSheenRoughnessTextureInfo();i.sheenRoughnessTexture=e.createTextureInfoDef(t,s)}}}),this}}Xe.EXTENSION_NAME=Ve;const{R:Ke,G:ze,B:qe,A:$e}=p;class Ye extends e{init(){this.extensionName="KHR_materials_specular",this.propertyType="Specular",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{specularFactor:1,specularTexture:null,specularTextureInfo:new T(this.graph,"specularTextureInfo"),specularColorFactor:[1,1,1],specularColorTexture:null,specularColorTextureInfo:new T(this.graph,"specularColorTextureInfo")})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getSpecularColorFactor(){return this.get("specularColorFactor")}setSpecularColorFactor(e){return this.set("specularColorFactor",e)}getSpecularColorHex(){return x.factorToHex(this.getSpecularColorFactor())}setSpecularColorHex(e){const t=this.getSpecularColorFactor().slice();return this.set("specularColorFactor",x.hexToFactor(e,t))}getSpecularTexture(){return this.getRef("specularTexture")}getSpecularTextureInfo(){return this.getRef("specularTexture")?this.getRef("specularTextureInfo"):null}setSpecularTexture(e){return this.setRef("specularTexture",e,{channels:$e})}getSpecularColorTexture(){return this.getRef("specularColorTexture")}getSpecularColorTextureInfo(){return this.getRef("specularColorTexture")?this.getRef("specularColorTextureInfo"):null}setSpecularColorTexture(e){return this.setRef("specularColorTexture",e,{channels:Ke|ze|qe})}}Ye.EXTENSION_NAME="KHR_materials_specular";const Qe="KHR_materials_specular";class We extends s{constructor(...e){super(...e),this.extensionName=Qe}createSpecular(){return new Ye(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Qe]){const n=this.createSpecular();e.materials[r].setExtension(Qe,n);const o=t.extensions[Qe];if(void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.specularColorFactor&&n.setSpecularColorFactor(o.specularColorFactor),void 0!==o.specularTexture){const t=o.specularTexture;n.setSpecularTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularTextureInfo(),t)}if(void 0!==o.specularColorTexture){const t=o.specularColorTexture;n.setSpecularColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularColorTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Qe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Qe]={};if(1!==r.getSpecularFactor()&&(i.specularFactor=r.getSpecularFactor()),l.eq(r.getSpecularColorFactor(),[1,1,1])||(i.specularColorFactor=r.getSpecularColorFactor()),r.getSpecularTexture()){const t=r.getSpecularTexture(),s=r.getSpecularTextureInfo();i.specularTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularColorTexture()){const t=r.getSpecularColorTexture(),s=r.getSpecularColorTextureInfo();i.specularColorTexture=e.createTextureInfoDef(t,s)}}}),this}}We.EXTENSION_NAME=Qe;const{R:Je,G:Ze,B:et,A:tt}=p;class st extends e{init(){this.extensionName="KHR_materials_translucency",this.propertyType="Translucency",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{translucencyFactor:1,translucencyTexture:null,translucencyTextureInfo:new T(this.graph,"translucencyTextureInfo"),translucencyColorFactor:[1,1,1],translucencyColorTexture:null,translucencyColorTextureInfo:new T(this.graph,"translucencyColorTextureInfo")})}getTranslucencyFactor(){return this.get("translucencyFactor")}setTranslucencyFactor(e){return this.set("translucencyFactor",e)}getTranslucencyColorFactor(){return this.get("translucencyColorFactor")}setTranslucencyColorFactor(e){return this.set("translucencyColorFactor",e)}getTranslucencyColorHex(){return x.factorToHex(this.getTranslucencyColorFactor())}setTranslucencyColorHex(e){const t=this.getTranslucencyColorFactor().slice();return this.set("translucencyColorFactor",x.hexToFactor(e,t))}getTranslucencyTexture(){return this.getRef("translucencyTexture")}getTranslucencyTextureInfo(){return this.getRef("translucencyTexture")?this.getRef("translucencyTextureInfo"):null}setTranslucencyTexture(e){return this.setRef("translucencyTexture",e,{channels:tt})}getTranslucencyColorTexture(){return this.getRef("translucencyColorTexture")}getTranslucencyColorTextureInfo(){return this.getRef("translucencyColorTexture")?this.getRef("translucencyColorTextureInfo"):null}setTranslucencyColorTexture(e){return this.setRef("translucencyColorTexture",e,{channels:Je|Ze|et})}}st.EXTENSION_NAME="KHR_materials_translucency";const rt="KHR_materials_translucency";class nt extends s{constructor(...e){super(...e),this.extensionName=rt}createTranslucency(){return new st(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[rt]){const n=this.createTranslucency();e.materials[r].setExtension(rt,n);const o=t.extensions[rt];if(void 0!==o.translucencyFactor&&n.setTranslucencyFactor(o.translucencyFactor),void 0!==o.translucencyColorFactor&&n.setTranslucencyColorFactor(o.translucencyColorFactor),void 0!==o.translucencyTexture){const t=o.translucencyTexture;n.setTranslucencyTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTranslucencyTextureInfo(),t)}if(void 0!==o.translucencyColorTexture){const t=o.translucencyColorTexture;n.setTranslucencyColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTranslucencyColorTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(rt);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[rt]={};if(1!==r.getTranslucencyFactor()&&(i.translucencyFactor=r.getTranslucencyFactor()),l.eq(r.getTranslucencyColorFactor(),[1,1,1])||(i.translucencyColorFactor=r.getTranslucencyColorFactor()),r.getTranslucencyTexture()){const t=r.getTranslucencyTexture(),s=r.getTranslucencyTextureInfo();i.translucencyTexture=e.createTextureInfoDef(t,s)}if(r.getTranslucencyColorTexture()){const t=r.getTranslucencyColorTexture(),s=r.getTranslucencyColorTextureInfo();i.translucencyColorTexture=e.createTextureInfoDef(t,s)}}}),this}}nt.EXTENSION_NAME=rt;const{R:ot}=p;class it extends e{init(){this.extensionName="KHR_materials_transmission",this.propertyType="Transmission",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{transmissionFactor:0,transmissionTexture:null,transmissionTextureInfo:new T(this.graph,"transmissionTextureInfo")})}getTransmissionFactor(){return this.get("transmissionFactor")}setTransmissionFactor(e){return this.set("transmissionFactor",e)}getTransmissionTexture(){return this.getRef("transmissionTexture")}getTransmissionTextureInfo(){return this.getRef("transmissionTexture")?this.getRef("transmissionTextureInfo"):null}setTransmissionTexture(e){return this.setRef("transmissionTexture",e,{channels:ot})}}it.EXTENSION_NAME="KHR_materials_transmission";const ct="KHR_materials_transmission";class at extends s{constructor(...e){super(...e),this.extensionName=ct}createTransmission(){return new it(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[ct]){const n=this.createTransmission();e.materials[r].setExtension(ct,n);const o=t.extensions[ct];if(void 0!==o.transmissionFactor&&n.setTransmissionFactor(o.transmissionFactor),void 0!==o.transmissionTexture){const t=o.transmissionTexture;n.setTransmissionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTransmissionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ct);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[ct]={transmissionFactor:r.getTransmissionFactor()};if(r.getTransmissionTexture()){const t=r.getTransmissionTexture(),s=r.getTransmissionTextureInfo();i.transmissionTexture=e.createTextureInfoDef(t,s)}}}),this}}at.EXTENSION_NAME=ct;class ut extends e{init(){this.extensionName="KHR_materials_unlit",this.propertyType="Unlit",this.parentTypes=[t.MATERIAL]}}ut.EXTENSION_NAME="KHR_materials_unlit";const lt="KHR_materials_unlit";class ht extends s{constructor(...e){super(...e),this.extensionName=lt}createUnlit(){return new ut(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{t.extensions&&t.extensions[lt]&&e.materials[s].setExtension(lt,this.createUnlit())}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{if(s.getExtension(lt)){const r=e.materialIndexMap.get(s),n=t.json.materials[r];n.extensions=n.extensions||{},n.extensions[lt]={}}}),this}}ht.EXTENSION_NAME=lt;class ft extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="Mapping",this.parentTypes=["MappingList"]}getDefaults(){return Object.assign(super.getDefaults(),{material:null,variants:[]})}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}addVariant(e){return this.addRef("variants",e)}removeVariant(e){return this.removeRef("variants",e)}listVariants(){return this.listRefs("variants")}}ft.EXTENSION_NAME="KHR_materials_variants";class gt extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="MappingList",this.parentTypes=[t.PRIMITIVE]}getDefaults(){return Object.assign(super.getDefaults(),{mappings:[]})}addMapping(e){return this.addRef("mappings",e)}removeMapping(e){return this.removeRef("mappings",e)}listMappings(){return this.listRefs("mappings")}}gt.EXTENSION_NAME="KHR_materials_variants";class xt extends e{init(){this.extensionName="KHR_materials_variants",this.propertyType="Variant",this.parentTypes=["MappingList"]}}xt.EXTENSION_NAME="KHR_materials_variants";const Tt="KHR_materials_variants";class pt extends s{constructor(...e){super(...e),this.extensionName=Tt}createMappingList(){return new gt(this.document.getGraph())}createVariant(e=""){return new xt(this.document.getGraph(),e)}createMapping(){return new ft(this.document.getGraph())}listVariants(){return Array.from(this.properties).filter(e=>e instanceof xt)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[Tt])return this;const s=(t.json.extensions[Tt].variants||[]).map(e=>this.createVariant().setName(e.name||""));return(t.json.meshes||[]).forEach((t,r)=>{const n=e.meshes[r];(t.primitives||[]).forEach((t,r)=>{if(!t.extensions||!t.extensions[Tt])return;const o=this.createMappingList(),i=t.extensions[Tt];for(const t of i.mappings){const r=this.createMapping();void 0!==t.material&&r.setMaterial(e.materials[t.material]);for(const e of t.variants||[])r.addVariant(s[e]);o.addMapping(r)}n.listPrimitives()[r].setExtension(Tt,o)})}),this}write(e){const t=e.jsonDoc,s=this.listVariants();if(!s.length)return this;const r=[],n=new Map;for(const t of s)n.set(t,r.length),r.push(e.createPropertyDef(t));for(const t of this.document.getRoot().listMeshes()){const s=e.meshIndexMap.get(t);t.listPrimitives().forEach((t,r)=>{const o=t.getExtension(Tt);if(!o)return;const i=e.jsonDoc.json.meshes[s].primitives[r],c=o.listMappings().map(t=>{const s=e.createPropertyDef(t),r=t.getMaterial();return r&&(s.material=e.materialIndexMap.get(r)),s.variants=t.listVariants().map(e=>n.get(e)),s});i.extensions=i.extensions||{},i.extensions[Tt]={mappings:c}})}return t.json.extensions=t.json.extensions||{},t.json.extensions[Tt]={variants:r},this}}pt.EXTENSION_NAME=Tt;const{G:dt}=p;class mt extends e{init(){this.extensionName="KHR_materials_volume",this.propertyType="Volume",this.parentTypes=[t.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{thicknessFactor:0,thicknessTexture:null,thicknessTextureInfo:new T(this.graph,"thicknessTexture"),attenuationDistance:Infinity,attenuationColor:[1,1,1]})}getThicknessFactor(){return this.get("thicknessFactor")}setThicknessFactor(e){return this.set("thicknessFactor",e)}getThicknessTexture(){return this.getRef("thicknessTexture")}getThicknessTextureInfo(){return this.getRef("thicknessTexture")?this.getRef("thicknessTextureInfo"):null}setThicknessTexture(e){return this.setRef("thicknessTexture",e,{channels:dt})}getAttenuationDistance(){return this.get("attenuationDistance")}setAttenuationDistance(e){return this.set("attenuationDistance",e)}getAttenuationColor(){return this.get("attenuationColor")}setAttenuationColor(e){return this.set("attenuationColor",e)}getAttenuationColorHex(){return x.factorToHex(this.getAttenuationColor())}setAttenuationColorHex(e){const t=this.getAttenuationColor().slice();return this.set("attenuationColor",x.hexToFactor(e,t))}}mt.EXTENSION_NAME="KHR_materials_volume";const Et="KHR_materials_volume";class It extends s{constructor(...e){super(...e),this.extensionName=Et}createVolume(){return new mt(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Et]){const n=this.createVolume();e.materials[r].setExtension(Et,n);const o=t.extensions[Et];if(void 0!==o.thicknessFactor&&n.setThicknessFactor(o.thicknessFactor),void 0!==o.attenuationDistance&&n.setAttenuationDistance(o.attenuationDistance),void 0!==o.attenuationColor&&n.setAttenuationColor(o.attenuationColor),void 0!==o.thicknessTexture){const t=o.thicknessTexture;n.setThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Et);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Et]={};if(r.getThicknessFactor()>0&&(i.thicknessFactor=r.getThicknessFactor()),Number.isFinite(r.getAttenuationDistance())&&(i.attenuationDistance=r.getAttenuationDistance()),l.eq(r.getAttenuationColor(),[1,1,1])||(i.attenuationColor=r.getAttenuationColor()),r.getThicknessTexture()){const t=r.getThicknessTexture(),s=r.getThicknessTextureInfo();i.thicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}It.EXTENSION_NAME=Et;const yt="KHR_mesh_quantization";class Rt extends s{constructor(...e){super(...e),this.extensionName=yt}read(e){return this}write(e){return this}}Rt.EXTENSION_NAME=yt;const Nt="KHR_texture_basisu";class At{match(e){return 171===e[0]&&75===e[1]&&84===e[2]&&88===e[3]&&32===e[4]&&50===e[5]&&48===e[6]&&187===e[7]&&13===e[8]&&10===e[9]&&26===e[10]&&10===e[11]}getSize(e){const t=d(e);return[t.pixelWidth,t.pixelHeight]}getChannels(e){const t=d(e).dataFormatDescriptor[0];if(t.colorModel===m.ETC1S)return 2===t.samples.length&&15==(15&t.samples[1].channelID)?4:3;if(t.colorModel===m.UASTC)return 3==(15&t.samples[0].channelID)?4:3;throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`)}getGPUByteLength(e){const t=d(e),s=this.getChannels(e)>3;let r=0;for(let e=0;e<t.levels.length;e++){const n=t.levels[e];r+=n.uncompressedByteLength?n.uncompressedByteLength:Math.max(1,Math.floor(t.pixelWidth/Math.pow(2,e)))/4*(Math.max(1,Math.floor(t.pixelHeight/Math.pow(2,e)))/4)*(s?16:8)}return r}}class _t extends s{constructor(...e){super(...e),this.extensionName=Nt,this.prereadTypes=[t.TEXTURE]}static register(){f.registerFormat("image/ktx2",new At)}preread(e){return e.jsonDoc.json.textures.forEach(e=>{e.extensions&&e.extensions[Nt]&&(e.source=e.extensions[Nt].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/ktx2"===s.getMimeType()){const r=e.imageIndexMap.get(s);t.json.textures.forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[Nt]={source:e.source},delete e.source)})}}),this}}_t.EXTENSION_NAME=Nt;class Ct extends e{init(){this.extensionName="KHR_texture_transform",this.propertyType="Transform",this.parentTypes=[t.TEXTURE_INFO]}getDefaults(){return Object.assign(super.getDefaults(),{offset:[0,0],rotation:0,scale:[1,1],texCoord:null})}getOffset(){return this.get("offset")}setOffset(e){return this.set("offset",e)}getRotation(){return this.get("rotation")}setRotation(e){return this.set("rotation",e)}getScale(){return this.get("scale")}setScale(e){return this.set("scale",e)}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}}Ct.EXTENSION_NAME="KHR_texture_transform";const St="KHR_texture_transform";class Mt extends s{constructor(...e){super(...e),this.extensionName=St}createTransform(){return new Ct(this.document.getGraph())}read(e){for(const[t,s]of Array.from(e.textureInfos.entries())){if(!s.extensions||!s.extensions[St])continue;const e=this.createTransform(),r=s.extensions[St];void 0!==r.offset&&e.setOffset(r.offset),void 0!==r.rotation&&e.setRotation(r.rotation),void 0!==r.scale&&e.setScale(r.scale),void 0!==r.texCoord&&e.setTexCoord(r.texCoord),t.setExtension(St,e)}return this}write(e){const t=Array.from(e.textureInfoDefMap.entries());for(const[e,s]of t){const t=e.getExtension(St);if(!t)continue;s.extensions=s.extensions||{};const r={},n=l.eq;n(t.getOffset(),[0,0])||(r.offset=t.getOffset()),0!==t.getRotation()&&(r.rotation=t.getRotation()),n(t.getScale(),[1,1])||(r.scale=t.getScale()),null!=t.getTexCoord()&&(r.texCoord=t.getTexCoord()),s.extensions[St]=r}return this}}Mt.EXTENSION_NAME=St;const Dt=[t.ROOT,t.SCENE,t.NODE,t.MESH,t.MATERIAL,t.TEXTURE,t.ANIMATION];class Ot extends e{init(){this.extensionName="KHR_xmp_json_ld",this.propertyType="Packet",this.parentTypes=Dt}getDefaults(){return Object.assign(super.getDefaults(),{context:{},properties:{}})}getContext(){return this.get("context")}setContext(e){return this.set("context",N({},e))}listProperties(){return Object.keys(this.get("properties"))}getProperty(e){const t=this.get("properties");return e in t?t[e]:null}setProperty(e,t){this._assertContext(e);const s=N({},this.get("properties"));return t?s[e]=t:delete s[e],this.set("properties",s)}toJSONLD(){return N({"@context":Ft(this.get("context"))},Ft(this.get("properties")))}fromJSONLD(e){const t=(e=Ft(e))["@context"];return t&&this.set("context",t),delete e["@context"],this.set("properties",e)}_assertContext(e){if(!(e.split(":")[0]in this.get("context")))throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)}}function Ft(e){return JSON.parse(JSON.stringify(e))}Ot.EXTENSION_NAME="KHR_xmp_json_ld";const wt="KHR_xmp_json_ld";class bt extends s{constructor(...e){super(...e),this.extensionName=wt}createPacket(){return new Ot(this.document.getGraph())}listPackets(){return Array.from(this.properties)}read(e){var t;const s=null==(t=e.jsonDoc.json.extensions)?void 0:t[wt];if(!s||!s.packets)return this;const r=e.jsonDoc.json,n=this.document.getRoot(),o=s.packets.map(e=>this.createPacket().fromJSONLD(e)),i=[[r.asset],r.scenes,r.nodes,r.meshes,r.materials,r.images,r.animations],c=[[n],n.listScenes(),n.listNodes(),n.listMeshes(),n.listMaterials(),n.listTextures(),n.listAnimations()];for(let e=0;e<i.length;e++){const t=i[e]||[];for(let s=0;s<t.length;s++){const r=t[s];r.extensions&&r.extensions[wt]&&c[e][s].setExtension(wt,o[r.extensions[wt].packet])}}return this}write(e){const{json:s}=e.jsonDoc,r=[];for(const n of this.properties){r.push(n.toJSONLD());for(const o of n.listParents()){let n;switch(o.propertyType){case t.ROOT:n=s.asset;break;case t.SCENE:n=s.scenes[e.sceneIndexMap.get(o)];break;case t.NODE:n=s.nodes[e.nodeIndexMap.get(o)];break;case t.MESH:n=s.meshes[e.meshIndexMap.get(o)];break;case t.MATERIAL:n=s.materials[e.materialIndexMap.get(o)];break;case t.TEXTURE:n=s.images[e.imageIndexMap.get(o)];break;case t.ANIMATION:n=s.animations[e.animationIndexMap.get(o)];break;default:n=null,this.document.getLogger().warn(`[${wt}]: Unsupported parent property, "${o.propertyType}"`)}n&&(n.extensions=n.extensions||{},n.extensions[wt]={packet:r.length-1})}}return r.length>0&&(s.extensions=s.extensions||{},s.extensions[wt]={packets:r}),this}}bt.EXTENSION_NAME=wt;const jt=[ne,ae,ge,Ee,Re,_e,Oe,Be,We,Xe,nt,at,ht,pt,It,Rt,_t,Mt,bt],vt=[R,H,U,...jt];export{vt as ALL_EXTENSIONS,he as Anisotropy,de as Clearcoat,ne as DracoMeshCompression,Ie as EmissiveStrength,E as INSTANCE_ATTRIBUTE,Ne as IOR,I as InstancedMesh,Me as Iridescence,jt as KHRONOS_EXTENSIONS,ie as Light,ae as LightsPunctual,ft as Mapping,gt as MappingList,ge as MaterialsAnisotropy,Ee as MaterialsClearcoat,Re as MaterialsEmissiveStrength,_e as MaterialsIOR,Oe as MaterialsIridescence,Be as MaterialsPBRSpecularGlossiness,Xe as MaterialsSheen,We as MaterialsSpecular,nt as MaterialsTranslucency,at as MaterialsTransmission,ht as MaterialsUnlit,pt as MaterialsVariants,It as MaterialsVolume,R as MeshGPUInstancing,Rt as MeshQuantization,H as MeshoptCompression,ve as PBRSpecularGlossiness,Ot as Packet,Pe as Sheen,Ye as Specular,_t as TextureBasisu,Mt as TextureTransform,U as TextureWebP,Ct as Transform,st as Translucency,it as Transmission,ut as Unlit,xt as Variant,mt as Volume,bt as XMP};
 //# sourceMappingURL=extensions.modern.js.map
diff --git a/dist/extensions.modern.js.map b/dist/extensions.modern.js.map
index 80a1f0ec839281423a417d0d1c52bdd52fafeeb0..138e2723521bc478fc6f62362a965d0bf7370b4b 100644
--- a/dist/extensions.modern.js.map
+++ b/dist/extensions.modern.js.map
@@ -1 +1 @@
-{"version":3,"file":"extensions.modern.js","sources":["../src/ext-mesh-gpu-instancing/instanced-mesh.ts","../src/constants.ts","../src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts","../src/ext-meshopt-compression/constants.ts","../src/ext-meshopt-compression/encoder.ts","../src/ext-meshopt-compression/meshopt-compression.ts","../src/ext-meshopt-compression/decoder.ts","../src/ext-texture-webp/texture-webp.ts","../src/khr-draco-mesh-compression/decoder.ts","../src/khr-draco-mesh-compression/encoder.ts","../src/khr-draco-mesh-compression/draco-mesh-compression.ts","../src/khr-lights-punctual/light.ts","../src/khr-lights-punctual/lights-punctual.ts","../src/khr-materials-clearcoat/clearcoat.ts","../src/khr-materials-clearcoat/materials-clearcoat.ts","../src/khr-materials-emissive-strength/emissive-strength.ts","../src/khr-materials-emissive-strength/materials-emissive-strength.ts","../src/khr-materials-ior/ior.ts","../src/khr-materials-ior/materials-ior.ts","../src/khr-materials-iridescence/iridescence.ts","../src/khr-materials-iridescence/materials-iridescence.ts","../src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts","../src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts","../src/khr-materials-sheen/sheen.ts","../src/khr-materials-sheen/materials-sheen.ts","../src/khr-materials-specular/specular.ts","../src/khr-materials-specular/materials-specular.ts","../src/khr-materials-transmission/transmission.ts","../src/khr-materials-transmission/materials-transmission.ts","../src/khr-materials-unlit/unlit.ts","../src/khr-materials-unlit/materials-unlit.ts","../src/khr-materials-variants/mapping.ts","../src/khr-materials-variants/mapping-list.ts","../src/khr-materials-variants/variant.ts","../src/khr-materials-variants/materials-variants.ts","../src/khr-materials-volume/volume.ts","../src/khr-materials-volume/materials-volume.ts","../src/khr-mesh-quantization/mesh-quantization.ts","../src/khr-texture-basisu/texture-basisu.ts","../src/khr-texture-transform/transform.ts","../src/khr-texture-transform/texture-transform.ts","../src/khr-xmp-json-ld/packet.ts","../src/khr-xmp-json-ld/xmp.ts","../src/extensions.ts"],"sourcesContent":["import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\n\ninterface IInstancedMesh extends IProperty {\n\tattributes: { [key: string]: Accessor };\n}\n\n// See BufferViewUsage in `writer-context.ts`.\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\n\n/**\n * # InstancedMesh\n *\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link MeshGPUInstancing}.\n */\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\n\tpublic declare propertyType: 'InstancedMesh';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\n\t\tthis.propertyType = 'InstancedMesh';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: {} });\n\t}\n\n\t/** Returns an instance attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\n\t * instance count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\n\t}\n\n\t/**\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\n\t * will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n","export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\nexport const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';\n","import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh';\n\nconst NAME = EXT_MESH_GPU_INSTANCING;\n\ninterface InstancedMeshDef {\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\n/**\n * # MeshGPUInstancing\n *\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\n * prepares mesh data for efficient GPU instancing.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\n * batch.\n *\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\n * > is important to note that (1) GPU instancing and other optimizations are possible  and\n * > encouraged  even without this extension, and (2) other common meanings of the term\n * > \"instancing\" exist, distinct from this extension. See\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\n * > of the `EXT_mesh_gpu_instancing` specification._\n *\n * Properties:\n * - {@link InstancedMesh}\n *\n * ### Example\n *\n * The `MeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\n * which may be attached to any {@link Node} instance. For example:\n *\n * ```typescript\n * import { MeshGPUInstancing } from '@gltf-transform/extensions';\n *\n * // Create standard mesh, node, and scene hierarchy.\n * // ...\n *\n * // Assign positions for each instance.\n * const batchPositions = doc.createAccessor('instance_positions')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0,\n * \t\t1, 0, 0,\n * \t\t2, 0, 0,\n * \t]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(buffer);\n *\n * // Assign IDs for each instance.\n * const batchIDs = doc.createAccessor('instance_ids')\n * \t.setArray(new Uint8Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR)\n * \t.setBuffer(buffer);\n *\n * // Create an Extension attached to the Document.\n * const batchExtension = document.createExtension(MeshGPUInstancing)\n * \t.setRequired(true);\n * const batch = batchExtension.createInstancedMesh()\n * \t.setAttribute('TRANSLATION', batchPositions)\n * \t.setAttribute('_ID', batchIDs);\n *\n * node\n * \t.setMesh(mesh)\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\n * ```\n *\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\n * be prefixed with an underscore (`_*`).\n */\nexport class MeshGPUInstancing extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly provideTypes = [PropertyType.NODE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\n\tpublic createInstancedMesh(): InstancedMesh {\n\t\treturn new InstancedMesh(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\n\t\t\tconst instancedMesh = this.createInstancedMesh();\n\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\n\t\t\t}\n\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\n\t\t// views grouped by parent reference.\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\n\t\tfor (const prop of this.properties) {\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\n\t\t\t\tif (instancedMesh) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\n\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\n\t\t\t\t\t});\n\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import type { GLTF, TypedArray } from '@gltf-transform/core';\n\nexport enum EncoderMethod {\n\tQUANTIZE = 'quantize',\n\tFILTER = 'filter',\n}\n\nexport interface MeshoptBufferExtension {\n\tfallback?: boolean;\n}\n\nexport enum MeshoptMode {\n\tATTRIBUTES = 'ATTRIBUTES',\n\tTRIANGLES = 'TRIANGLES',\n\tINDICES = 'INDICES',\n}\n\nexport enum MeshoptFilter {\n\tNONE = 'NONE',\n\tOCTAHEDRAL = 'OCTAHEDRAL',\n\tQUATERNION = 'QUATERNION',\n\tEXPONENTIAL = 'EXPONENTIAL',\n}\n\nexport interface MeshoptBufferViewExtension {\n\tbuffer: number;\n\tbyteOffset: number;\n\tbyteLength: number;\n\tbyteStride: number;\n\tcount: number;\n\tmode: MeshoptMode;\n\tfilter?: MeshoptFilter;\n}\n\n/**\n * When using filters, the accessor definition written to the file will not necessarily have the\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\n * output, so float32 input must be ignored.\n */\nexport interface PreparedAccessor {\n\tarray: TypedArray;\n\tbyteStride: number;\n\tnormalized: boolean;\n\tcomponentType: GLTF.AccessorComponentType;\n\tmin?: number[];\n\tmax?: number[];\n}\n","import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants';\nimport {\n\tAccessor,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBufferUtils,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPrimitive,\n\tRoot,\n\tTypedArray,\n\tTypedArrayConstructor,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\nconst { normalize, denormalize } = MathUtils;\n\n/** Pre-processes array with required filters or padding. */\nexport function prepareAccessor(\n\taccessor: Accessor,\n\tencoder: typeof MeshoptEncoder,\n\tmode: MeshoptMode,\n\tfilterOptions: { filter: MeshoptFilter; bits?: number }\n): PreparedAccessor {\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\n\tconst result: PreparedAccessor = {\n\t\tarray: accessor.getArray()!,\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\n\t\tcomponentType: accessor.getComponentType(),\n\t\tnormalized: accessor.getNormalized(),\n\t};\n\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\n\n\tif (filter !== MeshoptFilter.NONE) {\n\t\tlet array = accessor.getNormalized() ? denormalizeArray(accessor) : new Float32Array(result.array);\n\n\t\tswitch (filter) {\n\t\t\tcase MeshoptFilter.EXPONENTIAL: //  K single-precision floating point values.\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\n\t\t\t\tresult.componentType = FLOAT;\n\t\t\t\tresult.normalized = false;\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: //  four 8- or 16-bit normalized values.\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.QUATERNION: //  four 16-bit normalized values.\n\t\t\t\tresult.byteStride = 8;\n\t\t\t\tresult.componentType = SHORT;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid filter.');\n\t\t}\n\n\t\tresult.min = accessor.getMin([]);\n\t\tresult.max = accessor.getMax([]);\n\t\tif (accessor.getNormalized()) {\n\t\t\tresult.min = result.min.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t\tresult.max = result.max.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t}\n\t\tif (result.normalized) {\n\t\t\tresult.min = result.min.map((v) => normalize(v, result.componentType));\n\t\t\tresult.max = result.max.map((v) => normalize(v, result.componentType));\n\t\t}\n\t} else if (result.byteStride % 4) {\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\n\t}\n\n\treturn result;\n}\n\nfunction denormalizeArray(attribute: Accessor): Float32Array {\n\tconst componentType = attribute.getComponentType();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\tfor (let i = 0; i < srcArray.length; i++) {\n\t\tdstArray[i] = denormalize(srcArray[i], componentType);\n\t}\n\treturn dstArray;\n}\n\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\n\tconst elementCount = srcArray.length / elementSize;\n\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\n\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n\n/** Pad normals with a .w component for octahedral encoding. */\nfunction padNormals(srcArray: Float32Array): Float32Array {\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\n\t\tdstArray[i * 4] = srcArray[i * 3];\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\n\t}\n\treturn dstArray;\n}\n\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\n\t\t});\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\n\t}\n\n\treturn MeshoptMode.ATTRIBUTES;\n}\n\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\n\tconst refs = doc\n\t\t.getGraph()\n\t\t.listParentEdges(accessor)\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\n\n\tfor (const ref of refs) {\n\t\tconst refName = ref.getName();\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\n\n\t\t// Indices.\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\n\n\t\t// Attributes.\n\t\t//\n\t\t// NOTES:\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\n\t\t//   quantization for these attributes.\n\t\tif (refName === 'attributes') {\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'NORMAL') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey === 'TANGENT') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// Animation.\n\t\tif (refName === 'output') {\n\t\t\tconst targetPath = getTargetPath(accessor);\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\treturn { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/489\n\t\tif (refName === 'input') return { filter: MeshoptFilter.NONE };\n\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\n\t}\n\n\treturn { filter: MeshoptFilter.NONE };\n}\n\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\n\tfor (const sampler of accessor.listParents()) {\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\n\t\tfor (const channel of sampler.listParents()) {\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\n\t\t\treturn channel.getTargetPath();\n\t\t}\n\t}\n\treturn null;\n}\n","import {\n\tAccessor,\n\tBuffer,\n\tBufferUtils,\n\tExtension,\n\tGLB_BUFFER,\n\tGLTF,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants';\nimport { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder';\nimport { isFallbackBuffer } from './decoder';\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\n\nconst NAME = EXT_MESHOPT_COMPRESSION;\n\ninterface EncoderOptions {\n\tmethod?: EncoderMethod;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\n\tmethod: EncoderMethod.QUANTIZE,\n};\n\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\n\n/**\n * # MeshoptCompression\n *\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)\n * provides compression and fast decoding for geometry, morph targets, and animations.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\n * library) offers a lightweight decoder with very fast runtime decompression, and is\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\n * large, other complementary compression methods should be used as well.\n *\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\n * pre-optimizes assets for this purpose  without this secondary compression, the size\n * reduction is considerably less.\n *\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\n * considerably faster than Draco decoding, neither compression method will improve runtime\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\n * vertex count or draw calls  not just compress it. Finally, be aware that Meshopt compression is\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\n * writing files, and must be provided by the application. Compression may alternatively be applied\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { MeshoptCompression } from '@gltf-transform/extensions';\n * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';\n *\n * await MeshoptDecoder.ready;\n * await MeshoptEncoder.ready;\n *\n * const io = new NodeIO()\n *\t.registerExtensions([MeshoptCompression])\n *\t.registerDependencies({\n *\t\t'meshopt.decoder': MeshoptDecoder,\n *\t\t'meshopt.encoder': MeshoptEncoder,\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode. (Medium, -c)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize()\n * );\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.QUANTIZE });\n * await io.write('compressed-medium.glb', document);\n *\n * // Write and encode. (High, -cc)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\n * );\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.FILTER });\n * await io.write('compressed-high.glb', document);\n * ```\n */\nexport class MeshoptCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['meshopt.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'meshopt.decoder') {\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\n\t\t}\n\t\tif (key === 'meshopt.encoder') {\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\n\t *\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\n\t * \t`gltfpack -cc`.\n\t *\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\n\t * with both methods.\n\t *\n\t * Example:\n\t *\n\t * ```ts\n\t * doc.createExtension(MeshoptCompression)\n\t * \t.setRequired(true)\n\t * \t.setEncoderOptions({\n\t * \t\tmethod: MeshoptCompression.EncoderMethod.QUANTIZE\n\t * \t});\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Decoding.\n\t */\n\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\n\t\tif (!this._decoder) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\n\t\t}\n\t\tif (!this._decoder.supported) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\n\t\t}\n\n\t\tif (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prereadBuffers(context);\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\n\t\t\tthis._prereadPrimitives(context);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @internal Decode buffer views. */\n\tprivate _prereadBuffers(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\t\tviewDefs.forEach((viewDef, index) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\n\t\t\tconst count = meshoptDef.count;\n\t\t\tconst stride = meshoptDef.byteStride;\n\t\t\tconst result = new Uint8Array(count * stride);\n\n\t\t\tconst bufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\n\n\t\t\tcontext.bufferViews[index] = result;\n\t\t});\n\t}\n\n\t/**\n\t * Mark fallback buffers and replacements.\n\t *\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\n\t * after Buffers have been parsed.\n\t * @internal\n\t */\n\tprivate _prereadPrimitives(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\n\t\t//\n\t\tviewDefs.forEach((viewDef) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @hidden Removes Fallback buffers, if extension is required. */\n\tpublic read(_context: ReaderContext): this {\n\t\tif (!this.isRequired()) return this;\n\n\t\t// Replace fallback buffers.\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\n\t\t\t\tif (parent instanceof Accessor) {\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallbackBuffer.dispose();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Encoding.\n\t */\n\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\n\t\tif (propertyType === PropertyType.ACCESSOR) {\n\t\t\tthis._prewriteAccessors(context);\n\t\t} else if (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prewriteBuffers(context);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @internal Claims accessors that can be compressed. */\n\tprivate _prewriteAccessors(context: WriterContext): void {\n\t\tconst json = context.jsonDoc.json;\n\t\tconst encoder = this._encoder!;\n\t\tconst options = this._encoderOptions;\n\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\n\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\n\t\tthis._encoderBufferViews = {};\n\t\tthis._encoderBufferViewData = {};\n\t\tthis._encoderBufferViewAccessors = {};\n\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\n\t\t\t// Example: https://skfb.ly/6qAD8\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\n\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\n\t\t\tconst filter =\n\t\t\t\toptions.method === EncoderMethod.FILTER\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\n\t\t\tconst { array, byteStride } = preparedAccessor;\n\n\t\t\tconst buffer = accessor.getBuffer();\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\n\n\t\t\t// Buffer view grouping key.\n\t\t\tconst key = [usage, mode, filter.filter, byteStride, bufferIndex].join(':');\n\n\t\t\tlet bufferView = this._encoderBufferViews[key];\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\n\t\t\t// Write new buffer view, if needed.\n\t\t\tif (!bufferView || !bufferViewData) {\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\n\t\t\t\t\tbuffer: fallbackBufferIndex,\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\n\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\n\t\t\t\t\textensions: {\n\t\t\t\t\t\t[NAME]: {\n\t\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\n\t\t\t\t\t\t\tbyteStride: byteStride,\n\t\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Write accessor.\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\tjson.accessors!.push(accessorDef);\n\t\t\tbufferViewAccessors.push(accessorDef);\n\n\t\t\t// Update buffer view.\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n\t\t\tbufferView.byteLength += array.byteLength;\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\n\t\t}\n\t}\n\n\t/** @internal Writes compressed buffer views. */\n\tprivate _prewriteBuffers(context: WriterContext): void {\n\t\tconst encoder = this._encoder!;\n\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\n\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\n\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\n\n\t\t\tbufferViewData.length = 0;\n\t\t\tbufferViewData.push(compressedData);\n\t\t\totherBufferViews.push(compressedData);\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\n\t\t}\n\t}\n\n\t/** @hidden Puts encoded data into glTF output. */\n\tpublic write(context: WriterContext): this {\n\t\tlet fallbackBufferByteOffset = 0;\n\n\t\t// Write final encoded buffer view properties.\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\n\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\n\t\t\t}\n\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\n\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\n\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\n\t\t}\n\n\t\t// Write final fallback buffer.\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\n\t\tfallbackBuffer.dispose();\n\n\t\treturn this;\n\t}\n}\n","import { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport type { GLTF } from '@gltf-transform/core';\nimport type { MeshoptBufferExtension } from './constants';\n\n/**\n * Returns true for a fallback buffer, else false.\n *\n *   - All references to the fallback buffer must come from bufferViews that\n *     have a EXT_meshopt_compression extension specified.\n *   - No references to the fallback buffer may come from\n *     EXT_meshopt_compression extension JSON.\n */\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\n\treturn !!fallbackDef.fallback;\n}\n","import {\n\tBufferUtils,\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { EXT_TEXTURE_WEBP } from '../constants';\n\nconst NAME = EXT_TEXTURE_WEBP;\n\nclass WEBPImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\n\t}\n\tgetSize(array: Uint8Array): vec2 | null {\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\n\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\n\t\tlet offset = 12;\n\t\twhile (offset < view.byteLength) {\n\t\t\tconst chunkId = BufferUtils.decodeText(\n\t\t\t\tnew Uint8Array([\n\t\t\t\t\tview.getUint8(offset),\n\t\t\t\t\tview.getUint8(offset + 1),\n\t\t\t\t\tview.getUint8(offset + 2),\n\t\t\t\t\tview.getUint8(offset + 3),\n\t\t\t\t])\n\t\t\t);\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\n\t\t\tif (chunkId === 'VP8 ') {\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\n\t\t\t\treturn [width, height];\n\t\t\t} else if (chunkId === 'VP8L') {\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\n\t\t\t\treturn [width, height];\n\t\t\t}\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\n\t\t}\n\n\t\treturn null;\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * # TextureWebP\n *\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\n * enables WebP images for any material texture.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * WebP typically provides the minimal transmission\n * size, but [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\n * like Basis Universal, with the `KHR_texture_basisu` extension.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureWebP } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const webpExtension = document.createExtension(TextureWebP)\n * \t.setRequired(true);\n * document.createTexture('MyWebPTexture')\n * \t.setMimeType('image/webp')\n * \t.setImage(fs.readFileSync('my-texture.webp'));\n * ```\n *\n * WebP conversion is not done automatically when adding the extension as shown above  you must\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\n *\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\n * JPEG image data.\n */\nexport class TextureWebP extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\n\t\ttextureDefs.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\nexport let decoderModule: DecoderModule;\n\n// Initialized when decoder module loads.\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\nlet DATA_TYPE: { [key: number]: DataType };\n\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\n\tconst buffer = new decoderModule.DecoderBuffer();\n\ttry {\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\n\t\t}\n\n\t\tconst dracoMesh = new decoderModule.Mesh();\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\n\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\n\t\t}\n\n\t\treturn dracoMesh;\n\t} finally {\n\t\tdecoderModule.destroy(buffer);\n\t}\n}\n\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\n\tconst numFaces = mesh.num_faces();\n\tconst numIndices = numFaces * 3;\n\n\tlet ptr: number;\n\tlet indices: Uint16Array | Uint32Array;\n\n\tif (mesh.num_points() <= 65534) {\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t} else {\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t}\n\n\tdecoderModule._free(ptr);\n\n\treturn indices;\n}\n\nexport function decodeAttribute(\n\tdecoder: Decoder,\n\tmesh: Mesh,\n\tattribute: Attribute,\n\taccessorDef: GLTF.IAccessor\n): TypedArray {\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\n\tconst numComponents = attribute.num_components();\n\tconst numPoints = mesh.num_points();\n\tconst numValues = numPoints * numComponents;\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\n\n\tconst ptr = decoderModule._malloc(byteLength);\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\tdecoderModule._free(ptr);\n\n\treturn array;\n}\n\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\n\tdecoderModule = _decoderModule;\n\n\tCOMPONENT_ARRAY = {\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\n\t};\n\n\tDATA_TYPE = {\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\n\t};\n}\n","import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\n\nexport let encoderModule: EncoderModule;\n\nexport enum EncoderMethod {\n\tEDGEBREAKER = 1,\n\tSEQUENTIAL = 0,\n}\n\nenum AttributeEnum {\n\tPOSITION = 'POSITION',\n\tNORMAL = 'NORMAL',\n\tCOLOR = 'COLOR',\n\tTEX_COORD = 'TEX_COORD',\n\tGENERIC = 'GENERIC',\n}\n\nconst DEFAULT_QUANTIZATION_BITS = {\n\t[AttributeEnum.POSITION]: 14,\n\t[AttributeEnum.NORMAL]: 10,\n\t[AttributeEnum.COLOR]: 8,\n\t[AttributeEnum.TEX_COORD]: 12,\n\t[AttributeEnum.GENERIC]: 12,\n};\n\nexport interface EncodedPrimitive {\n\tnumVertices: number;\n\tnumIndices: number;\n\tdata: Uint8Array;\n\tattributeIDs: { [key: string]: number };\n}\n\nexport interface EncoderOptions {\n\tdecodeSpeed?: number;\n\tencodeSpeed?: number;\n\tmethod?: EncoderMethod;\n\tquantizationBits?: { [key: string]: number };\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\n\tdecodeSpeed: 5,\n\tencodeSpeed: 5,\n\tmethod: EncoderMethod.EDGEBREAKER,\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\n\tquantizationVolume: 'mesh',\n};\n\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\n\tencoderModule = _encoderModule;\n}\n\n/**\n * References:\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\n */\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\n\n\tconst encoder = new encoderModule.Encoder();\n\tconst builder = new encoderModule.MeshBuilder();\n\tconst mesh = new encoderModule.Mesh();\n\n\tconst attributeIDs: { [key: string]: number } = {};\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tconst attributeEnum = getAttributeEnum(semantic);\n\t\tconst attributeID: number = addAttribute(\n\t\t\tbuilder,\n\t\t\tattribute.getComponentType(),\n\t\t\tmesh,\n\t\t\tencoderModule[attributeEnum],\n\t\t\tattribute.getCount(),\n\t\t\tattribute.getElementSize(),\n\t\t\tattribute.getArray()!\n\t\t);\n\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\n\n\t\tattributeIDs[semantic] = attributeID;\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\n\t\t\tencoder.SetAttributeQuantization(encoderModule[attributeEnum], options.quantizationBits[attributeEnum]);\n\t\t} else if (typeof options.quantizationVolume === 'object') {\n\t\t\tconst { quantizationVolume } = options;\n\t\t\tconst range = Math.max(\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2]\n\t\t\t);\n\t\t\tencoder.SetAttributeExplicitQuantization(\n\t\t\t\tencoderModule[attributeEnum],\n\t\t\t\toptions.quantizationBits[attributeEnum],\n\t\t\t\tattribute.getElementSize(),\n\t\t\t\tquantizationVolume.min,\n\t\t\t\trange\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error('Invalid quantization volume state.');\n\t\t}\n\t}\n\n\tconst indices = prim.getIndices();\n\tif (!indices) throw new Error('Primitive must have indices.');\n\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\n\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n\tencoder.SetTrackEncodedProperties(true);\n\n\t// Preserve vertex order for primitives with morph targets.\n\tif (options.method === EncoderMethod.SEQUENTIAL || prim.listTargets().length > 0) {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n\t} else {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n\t}\n\n\tconst byteLength = encoder.EncodeMeshToDracoBuffer(mesh, dracoBuffer);\n\tif (byteLength <= 0) throw new Error('Error applying Draco compression.');\n\n\tconst data = new Uint8Array(byteLength);\n\tfor (let i = 0; i < byteLength; ++i) {\n\t\tdata[i] = dracoBuffer.GetValue(i);\n\t}\n\n\tconst prevNumVertices = prim.getAttribute('POSITION')!.getCount();\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\n\n\tif (prim.listTargets().length > 0 && numVertices !== prevNumVertices) {\n\t\tthrow new Error(\n\t\t\t'Compression reduced vertex count unexpectedly, corrupting morph targets.' +\n\t\t\t\t' Applying the \"weld\" function before compression may resolve the issue.'\n\t\t);\n\t}\n\n\tencoderModule.destroy(dracoBuffer);\n\tencoderModule.destroy(mesh);\n\tencoderModule.destroy(builder);\n\tencoderModule.destroy(encoder);\n\n\treturn { numVertices, numIndices, data, attributeIDs };\n}\n\nfunction getAttributeEnum(semantic: string): AttributeEnum {\n\tif (semantic === 'POSITION') {\n\t\treturn AttributeEnum.POSITION;\n\t} else if (semantic === 'NORMAL') {\n\t\treturn AttributeEnum.NORMAL;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\treturn AttributeEnum.COLOR;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\treturn AttributeEnum.TEX_COORD;\n\t}\n\treturn AttributeEnum.GENERIC;\n}\n\nfunction addAttribute(\n\tbuilder: MeshBuilder,\n\tcomponentType: GLTF.AccessorComponentType,\n\tmesh: Mesh,\n\tattribute: number,\n\tcount: number,\n\titemSize: number,\n\tarray: TypedArray\n): number {\n\tswitch (componentType) {\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.BYTE:\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.SHORT:\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\n\t\tdefault:\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\n\t}\n}\n","import {\n\tAccessor,\n\tbbox,\n\tbounds,\n\tBufferUtils,\n\tDocument,\n\tExtension,\n\tGLB_BUFFER,\n\tPrimitive,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder';\nimport { EncodedPrimitive, encodeGeometry, EncoderMethod, EncoderOptions, initEncoderModule } from './encoder';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\ninterface DracoPrimitiveExtension {\n\tbufferView: number;\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\ninterface DracoWriterContext {\n\tprimitiveHashMap: Map<Primitive, string>;\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\n}\n\n/**\n * # DracoMeshCompression\n *\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\n * provides advanced compression for mesh geometry.\n *\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\n * in many cases. When animation or textures are large, other complementary compression methods\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\n * size savings.\n *\n * Be aware that decompression happens before uploading to the GPU  this will add some latency to\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\n * or draw calls  not just compress it. Finally, be aware that Draco compression is lossy:\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\n * and must be provided by the application.\n *\n * ### Encoding options\n *\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\n * edgebreaker method will give higher compression in general, but changes the\n * order of the model's vertices. To preserve index order, use sequential\n * compression. When a mesh uses morph targets, or a high decoding speed is\n * selected, sequential compression will automatically be chosen.\n *\n * Both speed options affect the encoder's choice of algorithms. For example, a\n * requirement for fast decoding may prevent the encoder from using the best\n * compression methods even if the encoding speed is set to 0. In general, the\n * faster of the two options limits the choice of features that can be used by the\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\n * the encoder to choose the optimal method out of the available features for the\n * given --decodeSpeed.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { DracoMeshCompression } from '@gltf-transform/extensions';\n *\n * import draco3d from 'draco3dgltf';\n *\n * // ...\n *\n * const io = new NodeIO()\n *\t.registerExtensions([DracoMeshCompression])\n *\t.registerDependencies({\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode.\n * document.createExtension(DracoMeshCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({\n * \t\tmethod: DracoMeshCompression.EncoderMethod.EDGEBREAKER,\n * \t\tencodeSpeed: 5,\n * \t\tdecodeSpeed: 5,\n * \t});\n * await io.write('compressed.glb', document);\n * ```\n */\nexport class DracoMeshCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['draco3d.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/**\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\n\t */\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoderModule: DecoderModule | null = null;\n\tprivate _encoderModule: EncoderModule | null = null;\n\tprivate _encoderOptions: EncoderOptions = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'draco3d.decoder') {\n\t\t\tthis._decoderModule = dependency as DecoderModule;\n\t\t\tinitDecoderModule(this._decoderModule);\n\t\t}\n\t\tif (key === 'draco3d.encoder') {\n\t\t\tthis._encoderModule = dependency as EncoderModule;\n\t\t\tinitEncoderModule(this._encoderModule);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets Draco compression options. Compression does not take effect until the Document is\n\t * written with an I/O class.\n\t *\n\t * Defaults:\n\t * ```\n\t * decodeSpeed?: number = 5;\n\t * encodeSpeed?: number = 5;\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = options;\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tif (!this._decoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\n\n\t\ttry {\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\t\tfor (const meshDef of meshDefs) {\n\t\t\t\tfor (const primDef of meshDef.primitives) {\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\n\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\n\n\t\t\t\t\tif (!dracoMesh || !decoder) {\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\t\t\t\tconst resource = bufferDef.uri\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\n\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attributes.\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\n\t\t\t\t\tif (primDef.indices !== undefined) {\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\n\t\t\t\tthis._decoderModule.destroy(decoder);\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\n\t\tif (!this._encoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\n\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\n\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\n\t\t\t} else {\n\t\t\t\tquantizationVolume = bounds(this.document.getRoot().listScenes().pop()!);\n\t\t\t}\n\t\t}\n\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\n\t\t\tconst primHash = primitiveHashMap.get(prim);\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\n\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\n\n\t\t\t// Create a new EncodedPrimitive.\n\t\t\tconst encodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\n\n\t\t\t// Create indices definition, update count.\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\n\t\t\tindicesDef.count = encodedPrim.numIndices;\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\n\t\t\taccessorDefs.push(indicesDef);\n\n\t\t\t// Create attribute definitions, update count.\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\n\t\t\t\taccessorDefs.push(attributeDef);\n\t\t\t}\n\n\t\t\t// Map compressed buffer view to a Buffer.\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\n\t\t}\n\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\n\n\t\tcontext.extensionData[NAME] = {\n\t\t\tprimitiveHashMap,\n\t\t\tprimitiveEncodingMap,\n\t\t} as DracoWriterContext;\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\n\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\n\t\t\t\tconst primDef = meshDef.primitives[i];\n\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\n\t\t\t\tif (!primHash) continue;\n\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = {\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Omit the extension if nothing was compressed.\n\t\tif (!dracoContext.primitiveHashMap.size) {\n\t\t\tconst json = context.jsonDoc.json;\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\n * fail, and would break assumptions required for compression, this function will throw an error.\n */\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\n\tconst logger = doc.getLogger();\n\tconst included = new Set<Primitive>();\n\tconst excluded = new Set<Primitive>();\n\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tif (!prim.getIndices()) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-indexed primitive.`);\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-TRIANGLES primitive.`);\n\t\t\t} else {\n\t\t\t\tincluded.add(prim);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create an Accessor->index mapping.\n\tconst accessors = doc.getRoot().listAccessors();\n\tconst accessorIndices = new Map<Accessor, number>();\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\n\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\n\t// compressed Primitive and Accessor to this hash key.\n\tconst includedAccessors = new Map<Accessor, string>();\n\tconst includedHashKeys = new Set<string>();\n\tconst primToHashKey = new Map<Primitive, string>();\n\tfor (const prim of Array.from(included)) {\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\n\n\t\t// If accessors of an identical primitive have already been checked, we're done.\n\t\tif (includedHashKeys.has(hashKey)) {\n\t\t\tprimToHashKey.set(prim, hashKey);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\t\tconst dstIndices = indices.clone();\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\n\t\t}\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tif (includedAccessors.has(attribute)) {\n\t\t\t\tconst dstAttribute = attribute.clone();\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\n\t\t\t}\n\t\t}\n\n\t\t// With conflicts resolved, compute the hash key again.\n\t\thashKey = createHashKey(prim, accessorIndices);\n\n\t\t// Commit the primitive and its accessors to the hash key.\n\t\tincludedHashKeys.add(hashKey);\n\t\tprimToHashKey.set(prim, hashKey);\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tincludedAccessors.set(attribute, hashKey);\n\t\t}\n\t}\n\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\n\t\t}\n\t}\n\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\n\tfor (const prim of Array.from(included)) {\n\t\tconst hashKey = primToHashKey.get(prim);\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\n\t\t) {\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\n\t\t}\n\t}\n\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\n\tfor (const prim of Array.from(excluded)) {\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\n\t\t}\n\t}\n\n\treturn primToHashKey;\n}\n\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\n\tconst hashElements = [];\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\n\thashElements.push(indexMap.get(indices));\n\tfor (const attribute of prim.listAttributes()) {\n\t\thashElements.push(indexMap.get(attribute));\n\t}\n\n\treturn hashElements.sort().join('|');\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\nimport { ColorUtils } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\n\ninterface ILight extends IProperty {\n\tcolor: vec3;\n\tintensity: number;\n\ttype: PunctualLightType;\n\trange: number | null;\n\tinnerConeAngle: number;\n\touterConeAngle: number;\n}\n\ntype PunctualLightType = 'point' | 'spot' | 'directional';\n\n/**\n * # Light\n *\n * Defines a light attached to a {@link Node}. See {@link LightsPunctual}.\n */\nexport class Light extends ExtensionProperty<ILight> {\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\n\tpublic declare propertyType: 'Light';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\t/**********************************************************************************************\n\t * CONSTANTS.\n\t */\n\n\tpublic static Type: Record<string, PunctualLightType> = {\n\t\tPOINT: 'point',\n\t\tSPOT: 'spot',\n\t\tDIRECTIONAL: 'directional',\n\t};\n\n\t/**********************************************************************************************\n\t * INSTANCE.\n\t */\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\n\t\tthis.propertyType = 'Light';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<ILight> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tcolor: [1, 1, 1] as vec3,\n\t\t\tintensity: 1,\n\t\t\ttype: Light.Type.POINT,\n\t\t\trange: null,\n\t\t\tinnerConeAngle: 0,\n\t\t\touterConeAngle: Math.PI / 4,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * COLOR.\n\t */\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic getColor(): vec3 {\n\t\treturn this.get('color');\n\t}\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic setColor(color: vec3): this {\n\t\treturn this.set('color', color);\n\t}\n\n\t/** Light color; sRGB hexadecimal color. */\n\tpublic getColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getColor());\n\t}\n\n\t/** Light color; sRGB hexadecimal color. */\n\tpublic setColorHex(hex: number): this {\n\t\tconst color = this.getColor().slice() as vec3;\n\t\tColorUtils.hexToFactor(hex, color);\n\t\treturn this.setColor(color);\n\t}\n\n\t/**********************************************************************************************\n\t * INTENSITY.\n\t */\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic getIntensity(): number {\n\t\treturn this.get('intensity');\n\t}\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic setIntensity(intensity: number): this {\n\t\treturn this.set('intensity', intensity);\n\t}\n\n\t/**********************************************************************************************\n\t * TYPE.\n\t */\n\n\t/** Type. */\n\tpublic getType(): PunctualLightType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Type. */\n\tpublic setType(type: PunctualLightType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**********************************************************************************************\n\t * RANGE.\n\t */\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic getRange(): number | null {\n\t\treturn this.get('range');\n\t}\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic setRange(range: number | null): this {\n\t\treturn this.set('range', range);\n\t}\n\n\t/**********************************************************************************************\n\t * SPOT LIGHT PROPERTIES\n\t */\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\n\t * < outerConeAngle.\n\t */\n\tpublic getInnerConeAngle(): number {\n\t\treturn this.get('innerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\n\t * < outerConeAngle.\n\t */\n\tpublic setInnerConeAngle(angle: number): this {\n\t\treturn this.set('innerConeAngle', angle);\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t *  PI / 2.0.\n\t */\n\tpublic getOuterConeAngle(): number {\n\t\treturn this.get('outerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t *  PI / 2.0.\n\t */\n\tpublic setOuterConeAngle(angle: number): this {\n\t\treturn this.set('outerConeAngle', angle);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\nimport { Light } from './light';\n\nconst NAME = KHR_LIGHTS_PUNCTUAL;\n\ninterface LightsPunctualRootDef {\n\tlights?: LightDef[];\n}\n\ninterface LightsPunctualNodeDef {\n\tlight: number;\n}\n\ninterface LightDef {\n\tname?: string;\n\tcolor?: vec3;\n\tintensity?: number;\n\trange?: number;\n\ttype: 'spot' | 'point' | 'directional';\n\tspot?: {\n\t\tinnerConeAngle?: number;\n\t\touterConeAngle?: number;\n\t};\n}\n\n/**\n * # LightsPunctual\n *\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\n * spot.\n *\n * Punctual lights are parameterized, infinitely small points that emit light in\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\n * of that node.\n *\n * Properties:\n * - {@link Light}\n *\n * ### Example\n *\n * ```typescript\n * import { LightsPunctual, Light, LightType } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const lightsExtension = document.createExtension(LightsPunctual);\n *\n * // Create a Light property.\n * const light = lightsExtension.createLight()\n *\t.setType(LightType.POINT)\n *\t.setIntensity(2.0)\n *\t.setColor([1.0, 0.0, 0.0]);\n *\n * // Attach the property to a Material.\n * node.setExtension('KHR_lights_punctual', light);\n * ```\n */\nexport class LightsPunctual extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\n\tpublic createLight(name = ''): Light {\n\t\treturn new Light(this.document.getGraph(), name);\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\n\t\tconst lights = lightDefs.map((lightDef) => {\n\t\t\tconst light = this.createLight()\n\t\t\t\t.setName(lightDef.name || '')\n\t\t\t\t.setType(lightDef.type);\n\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\n\n\t\t\tif (lightDef.spot?.innerConeAngle !== undefined) {\n\t\t\t\tlight.setInnerConeAngle(lightDef.spot.innerConeAngle);\n\t\t\t}\n\t\t\tif (lightDef.spot?.outerConeAngle !== undefined) {\n\t\t\t\tlight.setOuterConeAngle(lightDef.spot.outerConeAngle);\n\t\t\t}\n\n\t\t\treturn light;\n\t\t});\n\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (this.properties.size === 0) return this;\n\n\t\tconst lightDefs = [];\n\t\tconst lightIndexMap = new Map<Light, number>();\n\n\t\tfor (const property of this.properties) {\n\t\t\tconst light = property as Light;\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\n\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\n\n\t\t\tif (light.getName()) lightDef.name = light.getName();\n\n\t\t\tif (light.getType() === Light.Type.SPOT) {\n\t\t\t\tlightDef.spot = {\n\t\t\t\t\tinnerConeAngle: light.getInnerConeAngle(),\n\t\t\t\t\touterConeAngle: light.getOuterConeAngle(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlightDefs.push(lightDef);\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\n\t\t}\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\n\t\t\t\tif (light) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\n\t\t\t\t}\n\t\t\t});\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\n\ninterface IClearcoat extends IProperty {\n\tclearcoatFactor: number;\n\tclearcoatTexture: Texture;\n\tclearcoatTextureInfo: TextureInfo;\n\n\tclearcoatRoughnessFactor: number;\n\tclearcoatRoughnessTexture: Texture;\n\tclearcoatRoughnessTextureInfo: TextureInfo;\n\n\tclearcoatNormalScale: number;\n\tclearcoatNormalTexture: Texture;\n\tclearcoatNormalTextureInfo: TextureInfo;\n}\n\nconst { R, G, B } = TextureChannel;\n\n/**\n * # Clearcoat\n *\n * Defines clear coat for a PBR material. See {@link MaterialsClearcoat}.\n */\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\n\tpublic declare propertyType: 'Clearcoat';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\n\t\tthis.propertyType = 'Clearcoat';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IClearcoat> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tclearcoatFactor: 0,\n\t\t\tclearcoatTexture: null,\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\n\n\t\t\tclearcoatRoughnessFactor: 0,\n\t\t\tclearcoatRoughnessTexture: null,\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\n\n\t\t\tclearcoatNormalScale: 1,\n\t\t\tclearcoatNormalTexture: null,\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat.\n\t */\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic getClearcoatFactor(): number {\n\t\treturn this.get('clearcoatFactor');\n\t}\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatFactor(factor: number): this {\n\t\treturn this.set('clearcoatFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\n\t * normal map properties.\n\t */\n\tpublic getClearcoatTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat texture. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat roughness.\n\t */\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic getClearcoatRoughnessFactor(): number {\n\t\treturn this.get('clearcoatRoughnessFactor');\n\t}\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat roughness texture. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat normals.\n\t */\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic getClearcoatNormalScale(): number {\n\t\treturn this.get('clearcoatNormalScale');\n\t}\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalScale(scale: number): this {\n\t\treturn this.set('clearcoatNormalScale', scale);\n\t}\n\n\t/**\n\t * Clearcoat normal map. Independent of the material base layer normal map.\n\t */\n\tpublic getClearcoatNormalTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatNormalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat normal texture. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\nimport { Clearcoat } from './clearcoat';\n\nconst NAME = KHR_MATERIALS_CLEARCOAT;\n\ninterface ClearcoatDef {\n\tclearcoatFactor?: number;\n\tclearcoatRoughnessFactor?: number;\n\tclearcoatTexture?: GLTF.ITextureInfo;\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\n}\n\n/**\n * # MaterialsClearcoat\n *\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)\n * defines a clear coating on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\n *\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\n *\n * A clear coat is a common technique used in Physically-Based\n * Rendering for a protective layer applied to a base material.\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\n *\n * Properties:\n * - {@link Clearcoat}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const clearcoatExtension = document.createExtension(MaterialsClearcoat);\n *\n * // Create Clearcoat property.\n * const clearcoat = clearcoatExtension.createClearcoat()\n *\t.setClearcoatFactor(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\n * ```\n */\nexport class MaterialsClearcoat extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\n\tpublic createClearcoat(): Clearcoat {\n\t\treturn new Clearcoat(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst clearcoat = this.createClearcoat();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\n\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\n\t\t\t\tif (clearcoat) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\n\t\t\t\t\t} as ClearcoatDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\n\ninterface IEmissiveStrength extends IProperty {\n\temissiveStrength: number;\n}\n\n/**\n * # EmissiveStrength\n *\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\n * (HDR) emissive materials. See {@link MaterialsEmissiveStrength}.\n */\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare propertyType: 'EmissiveStrength';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\t\tthis.propertyType = 'EmissiveStrength';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\n\t}\n\n\t/**********************************************************************************************\n\t * EmissiveStrength.\n\t */\n\n\t/** EmissiveStrength. */\n\tpublic getEmissiveStrength(): number {\n\t\treturn this.get('emissiveStrength');\n\t}\n\n\t/** EmissiveStrength. */\n\tpublic setEmissiveStrength(strength: number): this {\n\t\treturn this.set('emissiveStrength', strength);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\nimport { EmissiveStrength } from './emissive-strength';\n\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\ninterface EmissiveStrengthDef {\n\temissiveStrength?: number;\n}\n\n/**\n * # MaterialsEmissiveStrength\n *\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\n *\n * [[include:UNRATIFIED_EXTENSIONS_NOTE.md]]\n *\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\n *\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\n * given arbitrarily high values.\n *\n * For implementations where a physical light unit is needed, the units for the multiplicative\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\n * emissive factor of 1.0 results in a fully exposed pixel.\n *\n * Properties:\n * - {@link EmissiveStrength}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const emissiveStrengthExtension = document.createExtension(MaterialsEmissiveStrength);\n *\n * // Create EmissiveStrength property.\n * const emissiveStrength = emissiveStrengthExtension\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\n * ```\n */\nexport class MaterialsEmissiveStrength extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\n\tpublic createEmissiveStrength(): EmissiveStrength {\n\t\treturn new EmissiveStrength(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\n\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\n\t\t\t\tif (emissiveStrength) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\n\t\t\t\t\t} as EmissiveStrengthDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\n\ninterface IIOR extends IProperty {\n\tior: number;\n}\n\n/**\n * # IOR\n *\n * Defines index of refraction for a PBR {@link Material}. See {@link MaterialsIOR}.\n */\nexport class IOR extends ExtensionProperty<IIOR> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\n\tpublic declare propertyType: 'IOR';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\n\t\tthis.propertyType = 'IOR';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIOR> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 0 });\n\t}\n\n\t/**********************************************************************************************\n\t * IOR.\n\t */\n\n\t/** IOR. */\n\tpublic getIOR(): number {\n\t\treturn this.get('ior');\n\t}\n\n\t/** IOR. */\n\tpublic setIOR(ior: number): this {\n\t\treturn this.set('ior', ior);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\nimport { IOR } from './ior';\n\nconst NAME = KHR_MATERIALS_IOR;\n\ninterface IORDef {\n\tior?: number;\n}\n\n/**\n * # MaterialsIOR\n *\n * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)\n * defines index of refraction on a glTF PBR material.\n *\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\n * refraction to a certain value.\n *\n * Properties:\n * - {@link IOR}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsIOR, IOR } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iorExtension = document.createExtension(MaterialsIOR);\n *\n * // Create IOR property.\n * const ior = iorExtension.createIOR().setIOR(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_ior', ior);\n * ```\n */\nexport class MaterialsIOR extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new IOR property for use on a {@link Material}. */\n\tpublic createIOR(): IOR {\n\t\treturn new IOR(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst ior = this.createIOR();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\n\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iorDef.ior !== undefined) {\n\t\t\t\t\tior.setIOR(iorDef.ior);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\n\t\t\t\tif (ior) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\tior: ior.getIOR(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\n\ninterface IIridescence extends IProperty {\n\tiridescenceFactor: number;\n\tiridescenceTexture: Texture;\n\tiridescenceTextureInfo: TextureInfo;\n\tiridescenceIOR: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: Texture;\n\tiridescenceThicknessTextureInfo: TextureInfo;\n}\n\nconst { R, G } = TextureChannel;\n\n/**\n * # Iridescence\n *\n * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link MaterialsIridescence}.\n */\nexport class Iridescence extends ExtensionProperty<IIridescence> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare propertyType: 'Iridescence';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IRIDESCENCE;\n\t\tthis.propertyType = 'Iridescence';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIridescence> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tiridescenceFactor: 0.0,\n\t\t\tiridescenceTexture: null,\n\t\t\tiridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),\n\t\t\tiridescenceIOR: 1.3,\n\t\t\tiridescenceThicknessMinimum: 100,\n\t\t\tiridescenceThicknessMaximum: 400,\n\t\t\tiridescenceThicknessTexture: null,\n\t\t\tiridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence.\n\t */\n\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\n\tpublic getIridescenceFactor(): number {\n\t\treturn this.get('iridescenceFactor');\n\t}\n\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\n\tpublic setIridescenceFactor(factor: number): this {\n\t\treturn this.set('iridescenceFactor', factor);\n\t}\n\n\t/**\n\t * Iridescence intensity.\n\t *\n\t * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\n\t * be packed with additional data in the other channels.\n\t */\n\tpublic getIridescenceTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;\n\t}\n\n\t/** Iridescence intensity. See {@link getIridescenceTexture}. */\n\tpublic setIridescenceTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence IOR.\n\t */\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic getIridescenceIOR(): number {\n\t\treturn this.get('iridescenceIOR');\n\t}\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic setIridescenceIOR(ior: number): this {\n\t\treturn this.set('iridescenceIOR', ior);\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence thickness.\n\t */\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMinimum(): number {\n\t\treturn this.get('iridescenceThicknessMinimum');\n\t}\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMinimum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMinimum', thickness);\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMaximum(): number {\n\t\treturn this.get('iridescenceThicknessMaximum');\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMaximum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMaximum', thickness);\n\t}\n\n\t/**\n\t * The green channel of this texture defines the thickness of the\n\t * thin-film layer by blending between the minimum and maximum thickness.\n\t */\n\tpublic getIridescenceThicknessTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceThicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence thickness texture.\n\t * If no texture is attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;\n\t}\n\n\t/** Sets iridescence thickness texture. See {@link getIridescenceThicknessTexture}. */\n\tpublic setIridescenceThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceThicknessTexture', texture, { channels: G });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\nimport { Iridescence } from './iridescence';\n\nconst NAME = KHR_MATERIALS_IRIDESCENCE;\n\ninterface IridescenceDef {\n\tiridescenceFactor: number;\n\tiridescenceTexture: GLTF.ITextureInfo;\n\tiridescenceIOR: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsIridescence\n *\n * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)\n * defines iridescence (thin film interference) on a PBR material.\n *\n * Iridescence describes an effect where hue varies depending on the viewing\n * angle and illumination angle: A thin-film of a semi-transparent layer\n * results in inter-reflections and due to thin-film interference, certain\n * wavelengths get absorbed or amplified. Iridescence can be seen on soap\n * bubbles, oil films, or on the wings of many insects. With this extension,\n * thickness and index of refraction (IOR) of the thin-film can be specified,\n * enabling iridescent materials.\n *\n * Properties:\n * - {@link Iridescence}\n *\n * ### Example\n *\n * The `MaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsIridescence, Iridescence } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iridescenceExtension = document.createExtension(MaterialsIridescence);\n *\n * // Create an Iridescence property.\n * const iridescence = iridescenceExtension.createIridescence()\n * \t.setIridescenceFactor(1.0)\n * \t.setIridescenceIOR(1.8);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_iridescence', iridescence);\n * ```\n */\nexport class MaterialsIridescence extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Iridescence property for use on a {@link Material}. */\n\tpublic createIridescence(): Iridescence {\n\t\treturn new Iridescence(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst iridescence = this.createIridescence();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, iridescence);\n\n\t\t\t\tconst iridescenceDef = materialDef.extensions[NAME] as IridescenceDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iridescenceDef.iridescenceFactor !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceIOR !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceIOR(iridescenceDef.iridescenceIOR);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMinimum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMaximum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (iridescenceDef.iridescenceTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst iridescence = material.getExtension<Iridescence>(NAME);\n\t\t\t\tif (iridescence) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst iridescenceDef = (materialDef.extensions[NAME] = {} as IridescenceDef);\n\n\t\t\t\t\tif (iridescence.getIridescenceFactor() > 0) {\n\t\t\t\t\t\tiridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceIOR() !== 1.3) {\n\t\t\t\t\t\tiridescenceDef.iridescenceIOR = iridescence.getIridescenceIOR();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMinimum() !== 100) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMaximum() !== 400) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (iridescence.getIridescenceTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceThicknessTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\n\ninterface IPBRSpecularGlossiness extends IProperty {\n\tdiffuseFactor: vec4;\n\tdiffuseTexture: Texture;\n\tdiffuseTextureInfo: TextureInfo;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tspecularGlossinessTexture: Texture;\n\tspecularGlossinessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # PBRSpecularGlossiness\n *\n * Converts a {@link Material} to a spec/gloss workflow. See {@link MaterialsPBRSpecularGlossiness}.\n */\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\n\t\t\tdiffuseTexture: null,\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tglossinessFactor: 1.0,\n\t\t\tspecularGlossinessTexture: null,\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse.\n\t */\n\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\n\tpublic getDiffuseFactor(): vec4 {\n\t\treturn this.get('diffuseFactor');\n\t}\n\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseFactor(factor: vec4): this {\n\t\treturn this.set('diffuseFactor', factor);\n\t}\n\n\t/** Diffuse; sRGB hexadecimal color. */\n\tpublic getDiffuseHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getDiffuseFactor());\n\t}\n\n\t/** Diffuse; sRGB hexadecimal color. */\n\tpublic setDiffuseHex(hex: number): this {\n\t\tconst factor = this.getDiffuseFactor().slice() as vec4;\n\t\treturn this.setDiffuseFactor(ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\n\t * spec/gloss PBR workflow.\n\t */\n\tpublic getDiffuseTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\n\t}\n\n\t/** Sets diffuse texture. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A });\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. */\n\tpublic getSpecularFactor(): vec3 {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. */\n\tpublic setSpecularFactor(factor: vec3): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Glossiness.\n\t */\n\n\t/** Glossiness; linear multiplier. */\n\tpublic getGlossinessFactor(): number {\n\t\treturn this.get('glossinessFactor');\n\t}\n\n\t/** Glossiness; linear multiplier. */\n\tpublic setGlossinessFactor(factor: number): this {\n\t\treturn this.set('glossinessFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Specular/Glossiness.\n\t */\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic getSpecularGlossinessTexture(): Texture | null {\n\t\treturn this.getRef('specularGlossinessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\n\t}\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness';\n\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\ninterface SpecularGlossinessDef {\n\tdiffuseFactor?: vec4;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tdiffuseTexture?: GLTF.ITextureInfo;\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsPBRSpecularGlossiness\n *\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\n *\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\n * > {@link MaterialsSpecular} extension instead, which provides specular data within a metal/rough\n * > workflow._\n *\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\n *\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\n *\n * Properties:\n * - {@link PBRSpecularGlossiness}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specGlossExtension = document.createExtension(MaterialsPBRSpecularGlossiness);\n *\n * // Create a PBRSpecularGlossiness property.\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\n * \t.setSpecularFactor(1.0);\n *\n * // // Assign to a Material.\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\n * ```\n */\nexport class MaterialsPBRSpecularGlossiness extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\n\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\n\t\t\t\tif (specGloss) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\n\t\t\t\t\t} as SpecularGlossinessDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\n\ninterface ISheen extends IProperty {\n\tsheenColorFactor: vec3;\n\tsheenColorTexture: Texture;\n\tsheenColorTextureInfo: TextureInfo;\n\tsheenRoughnessFactor: number;\n\tsheenRoughnessTexture: Texture;\n\tsheenRoughnessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Sheen\n *\n * Defines sheen on a PBR {@link Material}. See {@link MaterialsSheen}.\n */\nexport class Sheen extends ExtensionProperty<ISheen> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\n\tpublic declare propertyType: 'Sheen';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\n\t\tthis.propertyType = 'Sheen';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISheen> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\n\t\t\tsheenColorTexture: null,\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\n\t\t\tsheenRoughnessFactor: 0.0,\n\t\t\tsheenRoughnessTexture: null,\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen color.\n\t */\n\n\t/** Sheen; linear multiplier. */\n\tpublic getSheenColorFactor(): vec3 {\n\t\treturn this.get('sheenColorFactor');\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic getSheenColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSheenColorFactor());\n\t}\n\n\t/** Sheen; linear multiplier. */\n\tpublic setSheenColorFactor(factor: vec3): this {\n\t\treturn this.set('sheenColorFactor', factor);\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic setSheenColorHex(hex: number): this {\n\t\tconst factor = this.getSheenColorFactor().slice() as vec3;\n\t\treturn this.set('sheenColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Sheen color texture, in sRGB colorspace.\n\t */\n\tpublic getSheenColorTexture(): Texture | null {\n\t\treturn this.getRef('sheenColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\n\t}\n\n\t/** Sets sheen color texture. See {@link getSheenColorTexture}. */\n\tpublic setSheenColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen roughness.\n\t */\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic getSheenRoughnessFactor(): number {\n\t\treturn this.get('sheenRoughnessFactor');\n\t}\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic setSheenRoughnessFactor(factor: number): this {\n\t\treturn this.set('sheenRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getSheenRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('sheenRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\nimport { Sheen } from './sheen';\n\nconst NAME = KHR_MATERIALS_SHEEN;\n\ninterface SheenDef {\n\tsheenColorFactor?: vec3;\n\tsheenRoughnessFactor?: number;\n\tsheenColorTexture?: GLTF.ITextureInfo;\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSheen\n *\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\n * defines a velvet-like sheen layered on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\n *\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\n * > Group._\n *\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\n * cloth and fabric materials.\n *\n * Properties:\n * - {@link Sheen}\n *\n * ### Example\n *\n * The `MaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSheen, Sheen } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const sheenExtension = document.createExtension(MaterialsSheen);\n *\n * // Create a Sheen property.\n * const sheen = sheenExtension.createSheen()\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_sheen', sheen);\n * ```\n */\nexport class MaterialsSheen extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Sheen property for use on a {@link Material}. */\n\tpublic createSheen(): Sheen {\n\t\treturn new Sheen(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst sheen = this.createSheen();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\n\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\n\t\t\t\tif (sheen) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\n\t\t\t\t\t} as SheenDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\n\ninterface ISpecular extends IProperty {\n\tspecularFactor: number;\n\tspecularTexture: Texture;\n\tspecularTextureInfo: TextureInfo;\n\tspecularColorFactor: vec3;\n\tspecularColorTexture: Texture;\n\tspecularColorTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Specular\n *\n * Defines specular reflectivity on a PBR {@link Material}. See {@link MaterialsSpecular}.\n */\nexport class Specular extends ExtensionProperty<ISpecular> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\n\tpublic declare propertyType: 'Specular';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\n\t\tthis.propertyType = 'Specular';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISpecular> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tspecularFactor: 1.0,\n\t\t\tspecularTexture: null,\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tspecularColorTexture: null,\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic getSpecularFactor(): number {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic setSpecularFactor(factor: number): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\n\tpublic getSpecularColorFactor(): vec3 {\n\t\treturn this.get('specularColorFactor');\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\n\tpublic setSpecularColorFactor(factor: vec3): this {\n\t\treturn this.set('specularColorFactor', factor);\n\t}\n\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\n\tpublic getSpecularColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSpecularColorFactor());\n\t}\n\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\n\tpublic setSpecularColorHex(hex: number): this {\n\t\tconst factor = this.getSpecularColorFactor().slice() as vec3;\n\t\treturn this.set('specularColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\n\t * diffuse material.\n\t *\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\n\t * be packed with specular color (RGB) into a single texture.\n\t */\n\tpublic getSpecularTexture(): Texture | null {\n\t\treturn this.getRef('specularTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\n\t}\n\n\t/** Sets specular texture. See {@link getSpecularTexture}. */\n\tpublic setSpecularTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\n\t}\n\n\t/**\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\n\t *\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\n\t * factor (A) into a single texture.\n\t */\n\tpublic getSpecularColorTexture(): Texture | null {\n\t\treturn this.getRef('specularColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular color texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\n\t}\n\n\t/** Sets specular color texture. See {@link getSpecularColorTexture}. */\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\nimport { Specular } from './specular';\n\nconst NAME = KHR_MATERIALS_SPECULAR;\n\ninterface SpecularDef {\n\tspecularFactor?: number;\n\tspecularColorFactor?: vec3;\n\tspecularTexture?: GLTF.ITextureInfo;\n\tspecularColorTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSpecular\n *\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)\n * adjusts the strength of the specular reflection in the dielectric BRDF.\n *\n * MaterialsSpecular is a better alternative to the older\n * {@link MaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\n * provides specular information while remaining within a metal/rough PBR workflow. A\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\n *\n * Properties:\n * - {@link Specular}\n *\n * ### Example\n *\n * The `MaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSpecular, Specular } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specularExtension = document.createExtension(MaterialsSpecular);\n *\n * // Create a Specular property.\n * const specular = specularExtension.createSpecular()\n * \t.setSpecularFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_specular', specular);\n * ```\n */\nexport class MaterialsSpecular extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Specular property for use on a {@link Material}. */\n\tpublic createSpecular(): Specular {\n\t\treturn new Specular(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specular = this.createSpecular();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\n\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\n\t\t\t\tif (specular) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\n\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specular.getSpecularTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\n\ninterface ITransmission extends IProperty {\n\ttransmissionFactor: number;\n\ttransmissionTexture: Texture;\n\ttransmissionTextureInfo: TextureInfo;\n}\n\nconst { R } = TextureChannel;\n\n/**\n * # Transmission\n *\n * Defines optical transmission on a PBR {@link Material}. See {@link MaterialsTransmission}.\n */\nexport class Transmission extends ExtensionProperty<ITransmission> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\n\tpublic declare propertyType: 'Transmission';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\n\t\tthis.propertyType = 'Transmission';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransmission> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\ttransmissionFactor: 0.0,\n\t\t\ttransmissionTexture: null,\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Transmission.\n\t */\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic getTransmissionFactor(): number {\n\t\treturn this.get('transmissionFactor');\n\t}\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionFactor(factor: number): this {\n\t\treturn this.set('transmissionFactor', factor);\n\t}\n\n\t/**\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\n\t * addition of the `KHR_materials_volume` extension.\n\t */\n\tpublic getTransmissionTexture(): Texture | null {\n\t\treturn this.getRef('transmissionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\n\t}\n\n\t/** Sets transmission texture. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\nimport { Transmission } from './transmission';\n\nconst NAME = KHR_MATERIALS_TRANSMISSION;\n\ninterface TransmissionDef {\n\ttransmissionFactor?: number;\n\ttransmissionTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsTransmission\n *\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\n * scattering, or dispersion.\n *\n * While default PBR materials using alpha blending become invisible as their opacity approaches\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\n * transmission values. When combined with {@link MaterialsVolume}, transmission may be used for\n * thicker materials and refractive effects.\n *\n * Properties:\n * - {@link Transmission}\n *\n * ### Example\n *\n * The `MaterialsTransmission` class provides a single {@link ExtensionProperty} type,\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsTransmission, Transmission } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transmissionExtension = document.createExtension(MaterialsTransmission);\n *\n * // Create a Transmission property.\n * const transmission = transmissionExtension.createTransmission()\n * \t.setTransmissionFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_transmission', transmission);\n * ```\n */\nexport class MaterialsTransmission extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transmission property for use on a {@link Material}. */\n\tpublic createTransmission(): Transmission {\n\t\treturn new Transmission(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst transmission = this.createTransmission();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\n\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\n\t\t\t\tif (transmission) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\n\t\t\t\t\t} as TransmissionDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\n\n/**\n * # Unlit\n *\n * Converts a PBR {@link Material} to an unlit shading model. See {@link MaterialsUnlit}.\n */\nexport class Unlit extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\n\tpublic declare propertyType: 'Unlit';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\n\t\tthis.propertyType = 'Unlit';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\nimport { Unlit } from './unlit';\n\nconst NAME = KHR_MATERIALS_UNLIT;\n\n/**\n * # MaterialsUnlit\n *\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)\n * defines an unlit shading model for use in glTF 2.0 materials.\n *\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\n *\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\n *\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\n * effects like hand painted illustrative styles or baked toon shaders.\n *\n * Properties:\n * - {@link Unlit}\n *\n * ### Example\n *\n * The `MaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\n * be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsUnlit, Unlit } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const unlitExtension = document.createExtension(MaterialsUnlit);\n *\n * // Create an Unlit property.\n * const unlit = unlitExtension.createUnlit();\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_unlit', unlit);\n * ```\n */\nexport class MaterialsUnlit extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Unlit property for use on a {@link Material}. */\n\tpublic createUnlit(): Unlit {\n\t\treturn new Unlit(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Material, Nullable } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport type { Variant } from './variant';\n\ninterface IMapping extends IProperty {\n\tmaterial: Material;\n\tvariants: Variant[];\n}\n\n/**\n * # Mapping\n *\n * Maps {@link Variant}s to {@link Material}s. See {@link MaterialsVariants}.\n */\nexport class Mapping extends ExtensionProperty<IMapping> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Mapping';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Mapping';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n\n\tprotected getDefaults(): Nullable<IMapping> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: [] });\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/** Adds a {@link Variant} to this mapping. */\n\tpublic addVariant(variant: Variant): this {\n\t\treturn this.addRef('variants', variant);\n\t}\n\n\t/** Removes a {@link Variant} from this mapping. */\n\tpublic removeVariant(variant: Variant): this {\n\t\treturn this.removeRef('variants', variant);\n\t}\n\n\t/** Lists {@link Variant}s in this mapping. */\n\tpublic listVariants(): Variant[] {\n\t\treturn this.listRefs('variants');\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport type { Mapping } from './mapping';\n\ninterface IMappingList extends IProperty {\n\tmappings: Mapping[];\n}\n\n/**\n * # MappingList\n *\n * List of material variant {@link Mapping}s. See {@link MaterialsVariants}.\n */\nexport class MappingList extends ExtensionProperty<IMappingList> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'MappingList';\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'MappingList';\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\n\t}\n\n\tprotected getDefaults(): Nullable<IMappingList> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: [] });\n\t}\n\n\t/** Adds a {@link Mapping} to this mapping. */\n\tpublic addMapping(mapping: Mapping): this {\n\t\treturn this.addRef('mappings', mapping);\n\t}\n\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\n\tpublic removeMapping(mapping: Mapping): this {\n\t\treturn this.removeRef('mappings', mapping);\n\t}\n\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\n\tpublic listMappings(): Mapping[] {\n\t\treturn this.listRefs('mappings');\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\n\n/**\n * # Variant\n *\n * Defines a variant of a {@link Material}. See {@link MaterialsVariants}.\n */\nexport class Variant extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Variant';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Variant';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport { Mapping } from './mapping';\nimport { MappingList } from './mapping-list';\nimport { Variant } from './variant';\n\nconst NAME = KHR_MATERIALS_VARIANTS;\n\ninterface VariantsRootDef {\n\tvariants: VariantDef[];\n}\n\ninterface VariantDef {\n\tname?: string;\n}\n\ninterface VariantPrimDef {\n\tmappings: VariantMappingDef[];\n}\n\ninterface VariantMappingDef {\n\tmaterial: number;\n\tvariants: number[];\n}\n\n/**\n * # MaterialsVariants\n *\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\n *\n * ![Illustration](/media/extensions/khr-materials-variants.png)\n *\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\n *\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\n * `MaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\n * defining the variants available to an application. Triggering a variant is out of scope of this\n * extension, but could be handled in the application with a UI dropdown, particular game states,\n * and so on.\n *\n * Mesh geometry cannot be changed by this extension, although another extension\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\n *\n * Properties:\n * - {@link Variant}\n * - {@link Mapping}\n * - {@link MappingList}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsVariants } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const variantExtension = document.createExtension(MaterialsVariants);\n *\n * // Create some Variant states.\n * const healthyVariant = variantExtension.createVariant('Healthy');\n * const damagedVariant = variantExtension.createVariant('Damaged');\n *\n * // Create mappings from a Variant state to a Material.\n * const healthyMapping = variantExtension.createMapping()\n * \t.addVariant(healthyVariant)\n * \t.setMaterial(healthyMat);\n * const damagedMapping = variantExtension.createMapping()\n * \t.addVariant(damagedVariant)\n * \t.setMaterial(damagedMat);\n *\n * // Attach the mappings to a Primitive.\n * primitive.setExtension(\n * \t'KHR_materials_variants',\n * \tvariantExtension.createMappingList()\n * \t\t.addMapping(healthyMapping)\n * \t\t.addMapping(damagedMapping)\n * );\n * ```\n *\n * A few notes about this extension:\n *\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\n * \t instead, so assign that material accordingly. This material can be  but doesn't have to be \n * \t associated with one of the available variants.\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\n * \t Variant will be chosen by the viewer.\n * 3. Variant names are how these states are identified, so choose informative names.\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\n * \t the option of downloading only textures associated with the default state, and lazy-loading\n * \t any textures for inactive Variants only when they are needed.\n */\nexport class MaterialsVariants extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new MappingList property. */\n\tpublic createMappingList(): MappingList {\n\t\treturn new MappingList(this.document.getGraph());\n\t}\n\n\t/** Creates a new Variant property. */\n\tpublic createVariant(name = ''): Variant {\n\t\treturn new Variant(this.document.getGraph(), name);\n\t}\n\n\t/** Creates a new Mapping property. */\n\tpublic createMapping(): Mapping {\n\t\treturn new Mapping(this.document.getGraph());\n\t}\n\n\t/** Lists all Variants on the current Document. */\n\tpublic listVariants(): Variant[] {\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\t// Read all top-level variant names.\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\n\t\tconst variantDefs = variantsRootDef.variants || [];\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\n\n\t\t// For each mesh primitive, read its material/variant mappings.\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\n\t\t\tconst mesh = context.meshes[meshIndex];\n\t\t\tconst primDefs = meshDef.primitives || [];\n\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst mappingList = this.createMappingList();\n\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\n\t\t\t\t\tconst mapping = this.createMapping();\n\n\t\t\t\t\tif (mappingDef.material !== undefined) {\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingList.addMapping(mapping);\n\t\t\t\t}\n\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst variants = this.listVariants();\n\t\tif (!variants.length) return this;\n\n\t\t// Write all top-level variant names.\n\t\tconst variantDefs = [];\n\t\tconst variantIndexMap = new Map<Variant, number>();\n\t\tfor (const variant of variants) {\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\n\t\t}\n\n\t\t// For each mesh primitive, write its material/variant mappings.\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\n\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\n\t\t\t\tif (!mappingList) return;\n\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\n\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\n\n\t\t\t\t\tconst material = mapping.getMaterial();\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\n\n\t\t\t\t\treturn mappingDef;\n\t\t\t\t});\n\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\n\t\t\t});\n\t\t}\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\n\ninterface IVolume extends IProperty {\n\tthicknessFactor: number;\n\tthicknessTexture: Texture;\n\tthicknessTextureInfo: TextureInfo;\n\tattenuationDistance: number;\n\tattenuationColor: vec3;\n}\n\nconst { G } = TextureChannel;\n\n/**\n * # Volume\n *\n * Defines volume on a PBR {@link Material}. See {@link MaterialsVolume}.\n */\nexport class Volume extends ExtensionProperty<IVolume> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\n\tpublic declare propertyType: 'Volume';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\n\t\tthis.propertyType = 'Volume';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IVolume> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tthicknessFactor: 0.0,\n\t\t\tthicknessTexture: null,\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\n\t\t\tattenuationDistance: Infinity,\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Thickness.\n\t */\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic getThicknessFactor(): number {\n\t\treturn this.get('thicknessFactor');\n\t}\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic setThicknessFactor(factor: number): this {\n\t\treturn this.set('thicknessFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic getThicknessTexture(): Texture | null {\n\t\treturn this.getRef('thicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic setThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Attenuation.\n\t */\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic getAttenuationDistance(): number {\n\t\treturn this.get('attenuationDistance');\n\t}\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic setAttenuationDistance(distance: number): this {\n\t\treturn this.set('attenuationDistance', distance);\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColor(): vec3 {\n\t\treturn this.get('attenuationColor');\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColor(color: vec3): this {\n\t\treturn this.set('attenuationColor', color);\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getAttenuationColor());\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColorHex(hex: number): this {\n\t\tconst factor = this.getAttenuationColor().slice() as vec3;\n\t\treturn this.set('attenuationColor', ColorUtils.hexToFactor(hex, factor));\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\nimport { Volume } from './volume';\n\nconst NAME = KHR_MATERIALS_VOLUME;\n\ninterface VolumeDef {\n\tthicknessFactor?: number;\n\tthicknessTexture?: GLTF.ITextureInfo;\n\tattenuationDistance?: number;\n\tattenuationColor?: vec3;\n}\n\n/**\n * # MaterialsVolume\n *\n * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\n * translucency.\n *\n * ![Illustration](/media/extensions/khr-materials-volume.png)\n *\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\n * > volume (right). The overall color depends on the distance the light traveled through it; at\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\n * > large distances. Source: Khronos Group._\n *\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\n * effects will require future (TBD) extensions.\n *\n * The volume extension must be combined with {@link MaterialsTransmission} or\n * `KHR_materials_translucency` in order to define entry of light into the volume.\n *\n * Properties:\n * - {@link Volume}\n *\n * ### Example\n *\n * The `MaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\n * may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsVolume, Volume } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const volumeExtension = document.createExtension(MaterialsVolume);\n *\n * // Create a Volume property.\n * const volume = volumeExtension.createVolume()\n * \t.setThicknessFactor(1.0)\n * \t.setThicknessTexture(texture)\n * \t.setAttenuationDistance(1.0)\n * \t.setAttenuationColorHex(0xFFEEEE);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_volume', volume);\n * ```\n *\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\n */\nexport class MaterialsVolume extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Volume property for use on a {@link Material}. */\n\tpublic createVolume(): Volume {\n\t\treturn new Volume(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst volume = this.createVolume();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\n\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tvolume.setThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\n\t\t\t\tif (volume) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\n\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (volume.getThicknessTexture()) {\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MESH_QUANTIZATION } from '../constants';\n\nconst NAME = KHR_MESH_QUANTIZATION;\n\n/**\n * # MeshQuantization\n *\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\n *\n * Quantization provides a memory/precision tradeoff  depending on the application needs, 16-bit or\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\n * mesh might be written to a uint16 {@link Accessor}, with values `065536`, normalized to be\n * interpreted as `01`. With an additional 10x scale on any node {@link Node} instantiating the\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\n * up to 50% file size reduction.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing more flexible use of\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\n * types would yield an invalid glTF document, under the stricter core glTF specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { MeshQuantization } from '@gltf-transform/extensions';\n * import { quantize } from '@gltf-transform/functions';\n *\n * // Create an Extension attached to the Document.\n * const quantizationExtension = document.createExtension(MeshQuantization).setRequired(true);\n *\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\n * // or apply the provided quantize() function to compute quantized accessors automatically:\n * await document.transform(quantize({\n * \tquantizePosition: 16,\n * \tquantizeNormal: 12,\n * \tquantizeTexcoord: 14\n * }));\n * ```\n *\n * For more documentation about automatic quantization, see the {@link quantize} function.\n */\nexport class MeshQuantization extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tread(_: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\twrite(_: WriterContext): this {\n\t\treturn this;\n\t}\n}\n","import { KTX2Model, read as readKTX } from 'ktx-parse';\nimport {\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { KHR_TEXTURE_BASISU } from '../constants';\n\nconst NAME = KHR_TEXTURE_BASISU;\n\ninterface BasisuDef {\n\tsource: number;\n}\n\nclass KTX2ImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray[0] === 0xab &&\n\t\t\tarray[1] === 0x4b &&\n\t\t\tarray[2] === 0x54 &&\n\t\t\tarray[3] === 0x58 &&\n\t\t\tarray[4] === 0x20 &&\n\t\t\tarray[5] === 0x32 &&\n\t\t\tarray[6] === 0x30 &&\n\t\t\tarray[7] === 0xbb &&\n\t\t\tarray[8] === 0x0d &&\n\t\t\tarray[9] === 0x0a &&\n\t\t\tarray[10] === 0x1a &&\n\t\t\tarray[11] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst container = readKTX(array);\n\t\treturn [container.pixelWidth, container.pixelHeight];\n\t}\n\tgetChannels(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\tif (dfd.colorModel === KTX2Model.ETC1S) {\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === 15 ? 4 : 3;\n\t\t} else if (dfd.colorModel === KTX2Model.UASTC) {\n\t\t\treturn (dfd.samples[0].channelID & 0xf) === 3 ? 4 : 3;\n\t\t}\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\n\t}\n\tgetGPUByteLength(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst hasAlpha = this.getChannels(array) > 3;\n\n\t\tlet uncompressedBytes = 0;\n\t\tfor (let i = 0; i < container.levels.length; i++) {\n\t\t\tconst level = container.levels[i];\n\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\n\t\t\tif (level.uncompressedByteLength) {\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\n\t\t\t} else {\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\n\t\t\t}\n\t\t}\n\n\t\treturn uncompressedBytes;\n\t}\n}\n\n/**\n * # TextureBasisu\n *\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\n *\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\n * framerate while uploading images, or where GPU memory is limited.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureBasisu } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const basisuExtension = document.createExtension(TextureBasisu)\n * \t.setRequired(true);\n * document.createTexture('MyCompressedTexture')\n * \t.setMimeType('image/ktx2')\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\n * ```\n *\n * Compression is not done automatically when adding the extension as shown above  you must\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\n * [glTF-Transform CLI](/cli.html) has functions to help with this, or any similar KTX2-capable\n * utility will work.\n *\n * When the `KHR_texture_basisu` extension is added to a file by glTF-Transform, the extension\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\n * PNG or JPEG image data.\n *\n * > _**NOTICE:** Compressing some textures  particularly 3-component (RGB) normal maps, and\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\n * > texture before compressing it.\n * >\n * > For best results when authoring new textures, use\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\n * > prominent UV seams._\n */\nexport class TextureBasisu extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\n\t\t\t\ttextureDef.source = basisuDef.source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\n\ninterface ITransform extends IProperty {\n\toffset: vec2;\n\trotation: number;\n\tscale: vec2;\n\ttexCoord: number | null; // null  do not override TextureInfo.\n}\n\n/**\n * # Transform\n *\n * Defines UV transform for a {@link TextureInfo}. See {@link TextureTransform}.\n */\nexport class Transform extends ExtensionProperty<ITransform> {\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\n\tpublic declare propertyType: 'Transform';\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\n\t\tthis.propertyType = 'Transform';\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransform> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\toffset: [0.0, 0.0] as vec2,\n\t\t\trotation: 0,\n\t\t\tscale: [1.0, 1.0] as vec2,\n\t\t\ttexCoord: null,\n\t\t});\n\t}\n\n\tpublic getOffset(): vec2 {\n\t\treturn this.get('offset');\n\t}\n\tpublic setOffset(offset: vec2): this {\n\t\treturn this.set('offset', offset);\n\t}\n\n\tpublic getRotation(): number {\n\t\treturn this.get('rotation');\n\t}\n\tpublic setRotation(rotation: number): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\tpublic getScale(): vec2 {\n\t\treturn this.get('scale');\n\t}\n\tpublic setScale(scale: vec2): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\tpublic getTexCoord(): number | null {\n\t\treturn this.get('texCoord');\n\t}\n\tpublic setTexCoord(texCoord: number | null): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\nimport { Transform } from './transform';\n\nconst NAME = KHR_TEXTURE_TRANSFORM;\n\ninterface TransformDef {\n\toffset?: vec2;\n\trotation?: number;\n\tscale?: vec2;\n\ttexCoord?: number;\n}\n\n/**\n * # TextureTransform\n *\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\n *\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\n * this time.\n *\n * Properties:\n * - {@link Transform}\n *\n * ### Example\n *\n * The `TextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\n * may be attached to any {@link TextureInfo} instance. For example:\n *\n * ```typescript\n * import { TextureTransform } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transformExtension = document.createExtension(TextureTransform)\n * \t.setRequired(true);\n *\n * // Create a reusable Transform.\n * const transform = transformExtension.createTransform()\n * \t.setScale([100, 100]);\n *\n * // Apply the Transform to a Material's baseColorTexture.\n * document.createMaterial()\n * \t.setBaseColorTexture(myTexture)\n * \t.getBaseColorTextureInfo()\n * \t.setExtension('KHR_texture_transform', transform);\n * ```\n */\nexport class TextureTransform extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\n\tpublic createTransform(): Transform {\n\t\treturn new Transform(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\n\n\t\t\tconst transform = this.createTransform();\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\n\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\n\n\t\t\ttextureInfo.setExtension(NAME, transform);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\n\t\t\tif (!transform) continue;\n\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\n\t\t\tconst transformDef = {} as TransformDef;\n\n\t\t\tconst eq = MathUtils.eq;\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\n\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { Nullable, PropertyType, ExtensionProperty, IProperty } from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants';\n\ntype Term = string;\ntype TermDefinition = string | Record<string, string>;\n\ntype Value = string | number | boolean;\n\nconst PARENT_TYPES = [\n\tPropertyType.ROOT,\n\tPropertyType.SCENE,\n\tPropertyType.NODE,\n\tPropertyType.MESH,\n\tPropertyType.MATERIAL,\n\tPropertyType.TEXTURE,\n\tPropertyType.ANIMATION,\n];\n\ninterface IPacket extends IProperty {\n\t// https://json-ld.org/spec/latest/json-ld/#the-context\n\tcontext: Record<Term, TermDefinition>;\n\tproperties: Record<string, Value | Record<string, unknown>>;\n}\n\n/**\n * # Packet\n *\n * Defines an XMP packet associated with a Document or Property. See {@link XMP}.\n */\nexport class Packet extends ExtensionProperty<IPacket> {\n\tpublic declare propertyType: 'Packet';\n\tpublic declare parentTypes: typeof PARENT_TYPES;\n\tpublic declare extensionName: typeof KHR_XMP_JSON_LD;\n\tpublic static EXTENSION_NAME = KHR_XMP_JSON_LD;\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_XMP_JSON_LD;\n\t\tthis.propertyType = 'Packet';\n\t\tthis.parentTypes = PARENT_TYPES;\n\t}\n\n\tprotected getDefaults(): Nullable<IPacket> {\n\t\treturn Object.assign(super.getDefaults(), { context: {}, properties: {} });\n\t}\n\n\t/**********************************************************************************************\n\t * Context.\n\t */\n\n\t/**\n\t * Returns the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t */\n\tpublic getContext(): Record<Term, TermDefinition> {\n\t\treturn this.get('context');\n\t}\n\n\t/**\n\t * Sets the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setContext({\n\t *   dc: 'http://purl.org/dc/elements/1.1/',\n\t *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\n\t * });\n\t * ```\n\t *\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t * @param definition URI for XMP namespace.\n\t */\n\tpublic setContext(context: Record<Term, TermDefinition>): this {\n\t\treturn this.set('context', { ...context });\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Lists properties defined in this packet.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.listProperties(); //  ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\n\t * ```\n\t */\n\tpublic listProperties(): string[] {\n\t\treturn Object.keys(this.get('properties'));\n\t}\n\n\t/**\n\t * Returns the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.getProperty('dc:Creator'); //  {\"@list\": [\"Acme, Inc.\"]}\n\t * packet.getProperty('dc:Title'); //  {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\n\t * packet.getProperty('xmp:CreateDate'); //  \"2022-01-01\"\n\t * ```\n\t */\n\tpublic getProperty(name: string): Value | Record<string, unknown> | null {\n\t\tconst properties = this.get('properties');\n\t\treturn name in properties ? properties[name] : null;\n\t}\n\n\t/**\n\t * Sets the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\n\t * packet.setProperty('dc:Title', {\n\t * \t'@type': 'rdf:Alt',\n\t * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\n\t * });\n\t * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\n\t * ```\n\t */\n\tpublic setProperty(name: string, value: Value | Record<string, unknown>): this {\n\t\tthis._assertContext(name);\n\n\t\tconst properties = { ...this.get('properties') };\n\t\tif (value) {\n\t\t\tproperties[name] = value;\n\t\t} else {\n\t\t\tdelete properties[name];\n\t\t}\n\t\treturn this.set('properties', properties);\n\t}\n\n\t/**********************************************************************************************\n\t * Serialize / Deserialize.\n\t */\n\n\t/**\n\t * Serializes the packet context and properties to a JSONLD object.\n\t */\n\tpublic toJSONLD(): Record<string, unknown> {\n\t\tconst context = copyJSON(this.get('context'));\n\t\tconst properties = copyJSON(this.get('properties'));\n\t\treturn { '@context': context, ...properties };\n\t}\n\n\t/**\n\t * Deserializes a JSONLD packet, then overwrites existing context and properties with\n\t * the new values.\n\t */\n\tpublic fromJSONLD(jsonld: Record<string, unknown>): this {\n\t\tjsonld = copyJSON(jsonld);\n\n\t\t// Context.\n\t\tconst context = jsonld['@context'] as Record<Term, TermDefinition>;\n\t\tif (context) this.set('context', context);\n\t\tdelete jsonld['@context'];\n\n\t\t// Properties.\n\t\treturn this.set('properties', jsonld as Record<string, string | Record<string, unknown>>);\n\t}\n\n\t/**********************************************************************************************\n\t * Validation.\n\t */\n\n\t/** @hidden */\n\tprivate _assertContext(name: string) {\n\t\tconst prefix = name.split(':')[0];\n\t\tif (!(prefix in this.get('context'))) {\n\t\t\tthrow new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\n\t\t}\n\t}\n}\n\nfunction copyJSON<T>(object: T): T {\n\treturn JSON.parse(JSON.stringify(object));\n}\n","import {\n\tAnimation,\n\tExtension,\n\tGLTF,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPropertyType,\n\tReaderContext,\n\tScene,\n\tTexture,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants';\nimport { Packet } from './packet';\n\nconst NAME = KHR_XMP_JSON_LD;\n\ntype XMPPacketDef = Record<string, unknown>;\n\ntype XMPParentDef =\n\t| GLTF.IAsset\n\t| GLTF.IScene\n\t| GLTF.INode\n\t| GLTF.IMesh\n\t| GLTF.IMaterial\n\t| GLTF.ITexture\n\t| GLTF.IAnimation;\n\ninterface XMPPropertyDef {\n\tpacket: number;\n}\n\ninterface XMPRootDef {\n\tpackets?: XMPPacketDef[];\n}\n\n/**\n * # XMP\n *\n * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)\n * defines XMP metadata associated with a glTF asset.\n *\n * XMP metadata provides standardized fields describing the content, provenance, usage\n * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the\n * parsing or runtime behavior of the content  for that, use custom extensions, custom vertex\n * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred\n * for binary content like mesh data, animations, or textures.\n *\n * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}\n * to the document {@link Root}. In less common cases where metadata must be associated with\n * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},\n * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.\n *\n * Within each packet, XMP properties become available when an\n * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered\n * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not\n * registered as context. While not all XMP namespaces are relevant to 3D assets, some common\n * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`\n * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)\n * orientation data.\n *\n * Common XMP contexts for 3D models include:\n *\n * | Prefix      | URI                                         | Name                           |\n * |:------------|:--------------------------------------------|:-------------------------------|\n * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |\n * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |\n * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |\n * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |\n * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |\n *\n * Only the XMP contexts required for a packet should be assigned, and different packets\n * in the same asset may use different contexts.\n *\n * Properties:\n * - {@link Packet}\n *\n * ### Example\n *\n * ```typescript\n * import { XMP, Packet } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const xmpExtension = document.createExtension(XMP);\n *\n * // Create Packet property.\n * const packet = xmpExtension.createPacket()\n * \t.setContext({\n * \t\tdc: 'http://purl.org/dc/elements/1.1/',\n * \t})\n *\t.setProperty('dc:Creator', {\"@list\": [\"Acme, Inc.\"]});\n *\n * // Option 1: Assign to Document Root.\n * document.getRoot().setExtension('KHR_xmp_json_ld', packet);\n *\n * // Option 2: Assign to a specific Property.\n * texture.setExtension('KHR_xmp_json_ld', packet);\n * ```\n */\nexport class XMP extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\n\tpublic createPacket(): Packet {\n\t\treturn new Packet(this.document.getGraph());\n\t}\n\n\t/** Lists XMP packets currently defined in a {@link Document}. */\n\tpublic listPackets(): Packet[] {\n\t\treturn Array.from(this.properties) as Packet[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst extensionDef = context.jsonDoc.json.extensions?.[NAME] as XMPRootDef | undefined;\n\t\tif (!extensionDef || !extensionDef.packets) return this;\n\n\t\t// Deserialize packets.\n\t\tconst json = context.jsonDoc.json;\n\t\tconst root = this.document.getRoot();\n\t\tconst packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\n\n\t\tconst defLists = [\n\t\t\t[json.asset],\n\t\t\tjson.scenes,\n\t\t\tjson.nodes,\n\t\t\tjson.meshes,\n\t\t\tjson.materials,\n\t\t\tjson.images,\n\t\t\tjson.animations,\n\t\t];\n\n\t\tconst propertyLists = [\n\t\t\t[root],\n\t\t\troot.listScenes(),\n\t\t\troot.listNodes(),\n\t\t\troot.listMeshes(),\n\t\t\troot.listMaterials(),\n\t\t\troot.listTextures(),\n\t\t\troot.listAnimations(),\n\t\t];\n\n\t\t// Assign packets.\n\t\tfor (let i = 0; i < defLists.length; i++) {\n\t\t\tconst defs = defLists[i] || [];\n\t\t\tfor (let j = 0; j < defs.length; j++) {\n\t\t\t\tconst def = defs[j];\n\t\t\t\tif (def.extensions && def.extensions[NAME]) {\n\t\t\t\t\tconst xmpDef = def.extensions[NAME] as XMPPropertyDef;\n\t\t\t\t\tpropertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst { json } = context.jsonDoc;\n\n\t\tconst packetDefs = [];\n\n\t\tfor (const packet of this.properties as Set<Packet>) {\n\t\t\t// Serialize packets.\n\t\t\tpacketDefs.push(packet.toJSONLD());\n\n\t\t\t// Assign packets.\n\n\t\t\tfor (const parent of packet.listParents()) {\n\t\t\t\tlet parentDef: XMPParentDef | null;\n\n\t\t\t\tswitch (parent.propertyType) {\n\t\t\t\t\tcase PropertyType.ROOT:\n\t\t\t\t\t\tparentDef = json.asset;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.SCENE:\n\t\t\t\t\t\tparentDef = json.scenes![context.sceneIndexMap.get(parent as Scene)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.NODE:\n\t\t\t\t\t\tparentDef = json.nodes![context.nodeIndexMap.get(parent as Node)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MESH:\n\t\t\t\t\t\tparentDef = json.meshes![context.meshIndexMap.get(parent as Mesh)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MATERIAL:\n\t\t\t\t\t\tparentDef = json.materials![context.materialIndexMap.get(parent as Material)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.TEXTURE:\n\t\t\t\t\t\tparentDef = json.images![context.imageIndexMap.get(parent as Texture)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.ANIMATION:\n\t\t\t\t\t\tparentDef = json.animations![context.animationIndexMap.get(parent as Animation)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparentDef = null;\n\t\t\t\t\t\tthis.document\n\t\t\t\t\t\t\t.getLogger()\n\t\t\t\t\t\t\t.warn(`[${NAME}]: Unsupported parent property, \"${parent.propertyType}\"`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!parentDef) continue;\n\n\t\t\t\tparentDef.extensions = parentDef.extensions || {};\n\t\t\t\tparentDef.extensions[NAME] = { packet: packetDefs.length - 1 };\n\t\t\t}\n\t\t}\n\n\t\tif (packetDefs.length > 0) {\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[NAME] = { packets: packetDefs };\n\t\t}\n\n\t\treturn this;\n\t}\n}\n","/** @module extensions */\n\nimport { MeshGPUInstancing } from './ext-mesh-gpu-instancing';\nimport { MeshoptCompression } from './ext-meshopt-compression';\nimport { TextureWebP } from './ext-texture-webp';\nimport { DracoMeshCompression } from './khr-draco-mesh-compression';\nimport { LightsPunctual } from './khr-lights-punctual';\nimport { MaterialsClearcoat } from './khr-materials-clearcoat';\nimport { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';\nimport { MaterialsIOR } from './khr-materials-ior';\nimport { MaterialsIridescence } from './khr-materials-iridescence';\nimport { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';\nimport { MaterialsSheen } from './khr-materials-sheen';\nimport { MaterialsSpecular } from './khr-materials-specular';\nimport { MaterialsTransmission } from './khr-materials-transmission';\nimport { MaterialsUnlit } from './khr-materials-unlit';\nimport { MaterialsVariants } from './khr-materials-variants';\nimport { MaterialsVolume } from './khr-materials-volume';\nimport { MeshQuantization } from './khr-mesh-quantization';\nimport { TextureBasisu } from './khr-texture-basisu';\nimport { TextureTransform } from './khr-texture-transform';\nimport { XMP } from './khr-xmp-json-ld';\n\nexport const KHRONOS_EXTENSIONS = [\n\tDracoMeshCompression,\n\tLightsPunctual,\n\tMaterialsClearcoat,\n\tMaterialsEmissiveStrength,\n\tMaterialsIOR,\n\tMaterialsIridescence,\n\tMaterialsPBRSpecularGlossiness,\n\tMaterialsSpecular,\n\tMaterialsSheen,\n\tMaterialsTransmission,\n\tMaterialsUnlit,\n\tMaterialsVariants,\n\tMaterialsVolume,\n\tMeshQuantization,\n\tTextureBasisu,\n\tTextureTransform,\n\tXMP,\n];\n\nexport const ALL_EXTENSIONS = [MeshGPUInstancing, MeshoptCompression, TextureWebP, ...KHRONOS_EXTENSIONS];\n\nexport * from './ext-mesh-gpu-instancing';\nexport * from './ext-meshopt-compression';\nexport * from './ext-texture-webp';\nexport * from './khr-draco-mesh-compression';\nexport * from './khr-lights-punctual';\nexport * from './khr-materials-clearcoat';\nexport * from './khr-materials-emissive-strength';\nexport * from './khr-materials-ior';\nexport * from './khr-materials-iridescence';\nexport * from './khr-materials-sheen';\nexport * from './khr-materials-specular';\nexport * from './khr-materials-pbr-specular-glossiness';\nexport * from './khr-materials-transmission';\nexport * from './khr-materials-unlit';\nexport * from './khr-materials-variants';\nexport * from './khr-materials-volume';\nexport * from './khr-mesh-quantization';\nexport * from './khr-texture-basisu';\nexport * from './khr-texture-transform';\nexport * from './khr-xmp-json-ld';\n"],"names":["INSTANCE_ATTRIBUTE","InstancedMesh","ExtensionProperty","init","this","extensionName","propertyType","parentTypes","PropertyType","NODE","getDefaults","Object","assign","super","attributes","getAttribute","semantic","getRefMap","setAttribute","accessor","setRefMap","usage","listAttributes","listRefMapValues","listSemantics","listRefMapKeys","EXTENSION_NAME","NAME","MeshGPUInstancing","Extension","provideTypes","prewriteTypes","ACCESSOR","createInstancedMesh","document","getGraph","read","context","jsonDoc","json","nodes","forEach","nodeDef","nodeIndex","extensions","instancedMeshDef","instancedMesh","accessors","setExtension","prewrite","accessorUsageGroupedByParent","add","prop","properties","attribute","addAccessorToUsageGroup","write","getRoot","listNodes","node","getExtension","nodeIndexMap","get","accessorIndexMap","EncoderMethod","MeshoptMode","MeshoptFilter","BYTE","SHORT","FLOAT","Accessor","ComponentType","normalize","denormalize","MathUtils","prepareAccessor","encoder","mode","filterOptions","filter","bits","result","array","getArray","byteStride","getElementSize","getComponentSize","componentType","getComponentType","normalized","getNormalized","ATTRIBUTES","NONE","srcArray","dstArray","Float32Array","length","i","denormalizeArray","EXPONENTIAL","encodeFilterExp","getCount","OCTAHEDRAL","il","padNormals","encodeFilterOct","QUATERNION","encodeFilterQuat","Error","min","getMin","max","getMax","map","v","elementSize","elementStride","BufferUtils","padNumber","BYTES_PER_ELEMENT","constructor","j","padArrayElements","byteLength","getMeshoptMode","WriterContext","BufferViewUsage","ELEMENT_ARRAY_BUFFER","listParents","some","parent","Primitive","getMode","Mode","TRIANGLES","INDICES","getMeshoptFilter","doc","refs","listParentEdges","edge","getParent","Root","ref","refName","getName","refKey","getAttributes","key","startsWith","targetPath","getTargetPath","sampler","AnimationSampler","channel","AnimationChannel","DEFAULT_ENCODER_OPTIONS","method","QUANTIZE","MeshoptCompression","prereadTypes","BUFFER","PRIMITIVE","readDependencies","writeDependencies","_decoder","_decoderFallbackBufferMap","Map","_encoder","_encoderOptions","_encoderFallbackBuffer","_encoderBufferViews","_encoderBufferViewData","_encoderBufferViewAccessors","install","dependency","setEncoderOptions","options","preread","isRequired","supported","_prereadBuffers","_prereadPrimitives","bufferViews","viewDef","index","meshoptDef","byteOffset","count","stride","Uint8Array","bufferDef","buffers","buffer","source","toView","uri","resources","GLB_BUFFER","decodeGltfBuffer","fallback","set","_context","fallbackBuffer","swap","dispose","_prewriteAccessors","_prewriteBuffers","createBuffer","fallbackBufferIndex","listBuffers","indexOf","listAccessors","getAccessorUsage","FILTER","preparedAccessor","getBuffer","bufferIndex","join","bufferView","bufferViewData","bufferViewAccessors","target","USAGE_TO_TARGET","ARRAY_BUFFER","undefined","[object Object]","accessorDef","createAccessorDef","push","EXT_meshopt_compression","otherBufferViews","concat","encodeGltfBuffer","compressedData","pad","fallbackBufferByteOffset","bufferViewIndex","otherBufferViewsIndexMap","finalBufferViewDef","compressedByteOffset","bufferIndexMap","fallbackBufferDef","WEBPImageUtils","match","getSize","RIFF","decodeText","slice","WEBP","view","DataView","offset","chunkId","getUint8","chunkByteLength","getUint32","getInt16","b0","b1","b2","getChannels","_buffer","TextureWebP","TEXTURE","ImageUtils","registerFormat","textures","textureDef","listTextures","texture","getMimeType","imageIndex","imageIndexMap","decoderModule","COMPONENT_ARRAY","DATA_TYPE","encoderModule","decodeGeometry","decoder","data","DecoderBuffer","Init","GetEncodedGeometryType","TRIANGULAR_MESH","dracoMesh","Mesh","DecodeBufferToMesh","ok","ptr","destroy","decodeIndex","mesh","numIndices","num_faces","indices","num_points","Uint16Array","_malloc","GetTrianglesUInt16Array","HEAPU16","Uint32Array","GetTrianglesUInt32Array","HEAPU32","_free","decodeAttribute","dataType","ArrayCtor","numComponents","num_components","numValues","GetAttributeDataArrayForAllPoints","HEAPF32","AttributeEnum","DEFAULT_QUANTIZATION_BITS","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","decodeSpeed","encodeSpeed","EDGEBREAKER","quantizationBits","quantizationVolume","encodeGeometry","prim","_options","Encoder","builder","MeshBuilder","attributeIDs","dracoBuffer","DracoInt8Array","attributeEnum","getAttributeEnum","attributeID","addAttribute","SetAttributeQuantization","range","Math","SetAttributeExplicitQuantization","getIndices","AddFacesToMesh","SetSpeedOptions","SetTrackEncodedProperties","SEQUENTIAL","listTargets","SetEncodingMethod","MESH_SEQUENTIAL_ENCODING","MESH_EDGEBREAKER_ENCODING","EncodeMeshToDracoBuffer","GetValue","prevNumVertices","numVertices","GetNumberOfEncodedPoints","GetNumberOfEncodedFaces","itemSize","UNSIGNED_BYTE","AddUInt8Attribute","AddInt8Attribute","UNSIGNED_SHORT","AddUInt16Attribute","AddInt16Attribute","UNSIGNED_INT","AddUInt32Attribute","AddFloatAttribute","DracoMeshCompression","_decoderModule","_encoderModule","Int16Array","Int8Array","DT_FLOAT32","DT_UINT32","DT_UINT16","DT_UINT8","DT_INT16","DT_INT8","logger","getLogger","dracoMeshes","meshDefs","meshes","meshDef","primDef","primitives","dracoDef","bufferViewDef","Decoder","debug","dracoAttribute","GetAttributeByUniqueId","attributeArray","setArray","Array","from","values","_propertyType","JSON","stringify","primitiveHashMap","included","Set","excluded","listMeshes","listPrimitives","warn","accessorIndices","includedAccessors","includedHashKeys","primToHashKey","hashKey","createHashKey","has","dstIndices","clone","dstAttribute","keys","size","ROOT","attr","listDracoPrimitives","primitiveEncodingMap","listScenes","bounds","pop","primHash","accessorDefs","encodedPrim","indicesDef","attributeDef","extensionData","dracoContext","meshIndexMap","extensionsUsed","name","extensionsRequired","indexMap","hashElements","sort","Light","color","intensity","type","Type","POINT","innerConeAngle","outerConeAngle","PI","getColor","setColor","getColorHex","ColorUtils","factorToHex","setColorHex","hex","hexToFactor","getIntensity","setIntensity","getType","setType","getRange","setRange","getInnerConeAngle","setInnerConeAngle","angle","getOuterConeAngle","setOuterConeAngle","SPOT","DIRECTIONAL","LightsPunctual","createLight","lights","lightDef","light","setName","spot","lightDefs","lightIndexMap","property","eq","R","G","B","TextureChannel","Clearcoat","MATERIAL","clearcoatFactor","clearcoatTexture","clearcoatTextureInfo","TextureInfo","graph","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatRoughnessTextureInfo","clearcoatNormalScale","clearcoatNormalTexture","clearcoatNormalTextureInfo","getClearcoatFactor","setClearcoatFactor","factor","getClearcoatTexture","getRef","getClearcoatTextureInfo","setClearcoatTexture","setRef","channels","getClearcoatRoughnessFactor","setClearcoatRoughnessFactor","getClearcoatRoughnessTexture","getClearcoatRoughnessTextureInfo","setClearcoatRoughnessTexture","getClearcoatNormalScale","setClearcoatNormalScale","scale","getClearcoatNormalTexture","getClearcoatNormalTextureInfo","setClearcoatNormalTexture","MaterialsClearcoat","createClearcoat","textureDefs","materials","materialDef","materialIndex","clearcoat","clearcoatDef","textureInfoDef","setTextureInfo","listMaterials","material","materialIndexMap","textureInfo","createTextureInfoDef","EmissiveStrength","emissiveStrength","getEmissiveStrength","setEmissiveStrength","strength","MaterialsEmissiveStrength","createEmissiveStrength","emissiveStrengthDef","IOR","ior","getIOR","setIOR","MaterialsIOR","createIOR","iorDef","Iridescence","iridescenceFactor","iridescenceTexture","iridescenceTextureInfo","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","iridescenceThicknessTextureInfo","getIridescenceFactor","setIridescenceFactor","getIridescenceTexture","getIridescenceTextureInfo","setIridescenceTexture","getIridescenceIOR","setIridescenceIOR","getIridescenceThicknessMinimum","setIridescenceThicknessMinimum","thickness","getIridescenceThicknessMaximum","setIridescenceThicknessMaximum","getIridescenceThicknessTexture","getIridescenceThicknessTextureInfo","setIridescenceThicknessTexture","MaterialsIridescence","createIridescence","iridescence","iridescenceDef","A","PBRSpecularGlossiness","diffuseFactor","diffuseTexture","diffuseTextureInfo","specularFactor","glossinessFactor","specularGlossinessTexture","specularGlossinessTextureInfo","getDiffuseFactor","setDiffuseFactor","getDiffuseHex","setDiffuseHex","getDiffuseTexture","getDiffuseTextureInfo","setDiffuseTexture","getSpecularFactor","setSpecularFactor","getGlossinessFactor","setGlossinessFactor","getSpecularGlossinessTexture","getSpecularGlossinessTextureInfo","setSpecularGlossinessTexture","MaterialsPBRSpecularGlossiness","createPBRSpecularGlossiness","specGloss","specGlossDef","Sheen","sheenColorFactor","sheenColorTexture","sheenColorTextureInfo","sheenRoughnessFactor","sheenRoughnessTexture","sheenRoughnessTextureInfo","getSheenColorFactor","getSheenColorHex","setSheenColorFactor","setSheenColorHex","getSheenColorTexture","getSheenColorTextureInfo","setSheenColorTexture","getSheenRoughnessFactor","setSheenRoughnessFactor","getSheenRoughnessTexture","getSheenRoughnessTextureInfo","setSheenRoughnessTexture","MaterialsSheen","createSheen","sheen","sheenDef","Specular","specularTexture","specularTextureInfo","specularColorFactor","specularColorTexture","specularColorTextureInfo","getSpecularColorFactor","setSpecularColorFactor","getSpecularColorHex","setSpecularColorHex","getSpecularTexture","getSpecularTextureInfo","setSpecularTexture","getSpecularColorTexture","getSpecularColorTextureInfo","setSpecularColorTexture","MaterialsSpecular","createSpecular","specular","specularDef","Transmission","transmissionFactor","transmissionTexture","transmissionTextureInfo","getTransmissionFactor","setTransmissionFactor","getTransmissionTexture","getTransmissionTextureInfo","setTransmissionTexture","MaterialsTransmission","createTransmission","transmission","transmissionDef","Unlit","MaterialsUnlit","createUnlit","Mapping","variants","getMaterial","setMaterial","addVariant","variant","addRef","removeVariant","removeRef","listVariants","listRefs","MappingList","mappings","addMapping","mapping","removeMapping","listMappings","Variant","MaterialsVariants","createMappingList","createVariant","createMapping","variantDef","meshIndex","primIndex","mappingList","variantPrimDef","mappingDef","variantIndex","variantDefs","variantIndexMap","createPropertyDef","mappingDefs","Volume","thicknessFactor","thicknessTexture","thicknessTextureInfo","attenuationDistance","Infinity","attenuationColor","getThicknessFactor","setThicknessFactor","getThicknessTexture","getThicknessTextureInfo","setThicknessTexture","getAttenuationDistance","setAttenuationDistance","distance","getAttenuationColor","setAttenuationColor","getAttenuationColorHex","setAttenuationColorHex","MaterialsVolume","createVolume","volume","volumeDef","Number","isFinite","MeshQuantization","_","KTX2ImageUtils","container","readKTX","pixelWidth","pixelHeight","dfd","dataFormatDescriptor","colorModel","KTX2Model","ETC1S","samples","channelID","UASTC","getGPUByteLength","hasAlpha","uncompressedBytes","levels","level","uncompressedByteLength","floor","pow","TextureBasisu","Transform","TEXTURE_INFO","rotation","texCoord","getOffset","setOffset","getRotation","setRotation","getScale","setScale","getTexCoord","setTexCoord","TextureTransform","createTransform","textureInfos","entries","transform","transformDef","textureInfoEntries","textureInfoDefMap","PARENT_TYPES","SCENE","MESH","ANIMATION","Packet","getContext","setContext","listProperties","getProperty","setProperty","value","_assertContext","toJSONLD","@context","copyJSON","fromJSONLD","jsonld","split","object","parse","XMP","createPacket","listPackets","extensionDef","_context$jsonDoc$json","packets","root","packetDef","defLists","asset","scenes","images","animations","propertyLists","listAnimations","defs","def","packet","packetDefs","parentDef","sceneIndexMap","animationIndexMap","KHRONOS_EXTENSIONS","ALL_EXTENSIONS"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"extensions.modern.js","sources":["../src/ext-mesh-gpu-instancing/instanced-mesh.ts","../src/constants.ts","../src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts","../src/ext-meshopt-compression/constants.ts","../src/ext-meshopt-compression/encoder.ts","../src/ext-meshopt-compression/meshopt-compression.ts","../src/ext-meshopt-compression/decoder.ts","../src/ext-texture-webp/texture-webp.ts","../src/khr-draco-mesh-compression/decoder.ts","../src/khr-draco-mesh-compression/encoder.ts","../src/khr-draco-mesh-compression/draco-mesh-compression.ts","../src/khr-lights-punctual/light.ts","../src/khr-lights-punctual/lights-punctual.ts","../src/khr-materials-anisotropy/anisotropy.ts","../src/khr-materials-anisotropy/materials-anisotropy.ts","../src/khr-materials-clearcoat/clearcoat.ts","../src/khr-materials-clearcoat/materials-clearcoat.ts","../src/khr-materials-emissive-strength/emissive-strength.ts","../src/khr-materials-emissive-strength/materials-emissive-strength.ts","../src/khr-materials-ior/ior.ts","../src/khr-materials-ior/materials-ior.ts","../src/khr-materials-iridescence/iridescence.ts","../src/khr-materials-iridescence/materials-iridescence.ts","../src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts","../src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts","../src/khr-materials-sheen/sheen.ts","../src/khr-materials-sheen/materials-sheen.ts","../src/khr-materials-specular/specular.ts","../src/khr-materials-specular/materials-specular.ts","../src/khr-materials-translucency/translucency.ts","../src/khr-materials-translucency/materials-translucency.ts","../src/khr-materials-transmission/transmission.ts","../src/khr-materials-transmission/materials-transmission.ts","../src/khr-materials-unlit/unlit.ts","../src/khr-materials-unlit/materials-unlit.ts","../src/khr-materials-variants/mapping.ts","../src/khr-materials-variants/mapping-list.ts","../src/khr-materials-variants/variant.ts","../src/khr-materials-variants/materials-variants.ts","../src/khr-materials-volume/volume.ts","../src/khr-materials-volume/materials-volume.ts","../src/khr-mesh-quantization/mesh-quantization.ts","../src/khr-texture-basisu/texture-basisu.ts","../src/khr-texture-transform/transform.ts","../src/khr-texture-transform/texture-transform.ts","../src/khr-xmp-json-ld/packet.ts","../src/khr-xmp-json-ld/xmp.ts","../src/extensions.ts"],"sourcesContent":["import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\r\n\r\ninterface IInstancedMesh extends IProperty {\r\n\tattributes: { [key: string]: Accessor };\r\n}\r\n\r\n// See BufferViewUsage in `writer-context.ts`.\r\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\r\n\r\n/**\r\n * # InstancedMesh\r\n *\r\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link MeshGPUInstancing}.\r\n */\r\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\r\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\r\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\r\n\tpublic declare propertyType: 'InstancedMesh';\r\n\tpublic declare parentTypes: [PropertyType.NODE];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\r\n\t\tthis.propertyType = 'InstancedMesh';\r\n\t\tthis.parentTypes = [PropertyType.NODE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: {} });\r\n\t}\r\n\r\n\t/** Returns an instance attribute as an {@link Accessor}. */\r\n\tpublic getAttribute(semantic: string): Accessor | null {\r\n\t\treturn this.getRefMap('attributes', semantic);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\r\n\t * instance count.\r\n\t */\r\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\r\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\r\n\t}\r\n\r\n\t/**\r\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\r\n\t * will be consistent with the order returned by {@link .listSemantics}().\r\n\t */\r\n\tpublic listAttributes(): Accessor[] {\r\n\t\treturn this.listRefMapValues('attributes');\r\n\t}\r\n\r\n\t/**\r\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\r\n\t * consistent with the order returned by {@link .listAttributes}().\r\n\t */\r\n\tpublic listSemantics(): string[] {\r\n\t\treturn this.listRefMapKeys('attributes');\r\n\t}\r\n}\r\n","export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\r\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\r\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\r\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\r\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\r\nexport const KHR_MATERIALS_ANISOTROPY = 'KHR_materials_anisotropy';\r\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\r\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\r\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\r\nexport const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';\r\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\r\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\r\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\r\nexport const KHR_MATERIALS_TRANSLUCENCY = 'KHR_materials_translucency';\r\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\r\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\r\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\r\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\r\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\r\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\r\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\r\nexport const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';\r\n","import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\r\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh';\r\n\r\nconst NAME = EXT_MESH_GPU_INSTANCING;\r\n\r\ninterface InstancedMeshDef {\r\n\tattributes: {\r\n\t\t[name: string]: number;\r\n\t};\r\n}\r\n\r\n/**\r\n * # MeshGPUInstancing\r\n *\r\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\r\n * prepares mesh data for efficient GPU instancing.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\r\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\r\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\r\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\r\n * batch.\r\n *\r\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\r\n * > is important to note that (1) GPU instancing and other optimizations are possible  and\r\n * > encouraged  even without this extension, and (2) other common meanings of the term\r\n * > \"instancing\" exist, distinct from this extension. See\r\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\r\n * > of the `EXT_mesh_gpu_instancing` specification._\r\n *\r\n * Properties:\r\n * - {@link InstancedMesh}\r\n *\r\n * ### Example\r\n *\r\n * The `MeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\r\n * which may be attached to any {@link Node} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MeshGPUInstancing } from '@gltf-transform/extensions';\r\n *\r\n * // Create standard mesh, node, and scene hierarchy.\r\n * // ...\r\n *\r\n * // Assign positions for each instance.\r\n * const batchPositions = doc.createAccessor('instance_positions')\r\n * \t.setArray(new Float32Array([\r\n * \t\t0, 0, 0,\r\n * \t\t1, 0, 0,\r\n * \t\t2, 0, 0,\r\n * \t]))\r\n * \t.setType(Accessor.Type.VEC3)\r\n * \t.setBuffer(buffer);\r\n *\r\n * // Assign IDs for each instance.\r\n * const batchIDs = doc.createAccessor('instance_ids')\r\n * \t.setArray(new Uint8Array([0, 1, 2]))\r\n * \t.setType(Accessor.Type.SCALAR)\r\n * \t.setBuffer(buffer);\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const batchExtension = document.createExtension(MeshGPUInstancing)\r\n * \t.setRequired(true);\r\n * const batch = batchExtension.createInstancedMesh()\r\n * \t.setAttribute('TRANSLATION', batchPositions)\r\n * \t.setAttribute('_ID', batchIDs);\r\n *\r\n * node\r\n * \t.setMesh(mesh)\r\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\r\n * ```\r\n *\r\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\r\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\r\n * be prefixed with an underscore (`_*`).\r\n */\r\nexport class MeshGPUInstancing extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly provideTypes = [PropertyType.NODE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\r\n\tpublic createInstancedMesh(): InstancedMesh {\r\n\t\treturn new InstancedMesh(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\r\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\r\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\r\n\t\t\tconst instancedMesh = this.createInstancedMesh();\r\n\r\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\r\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic prewrite(context: WriterContext): this {\r\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\r\n\t\t// views grouped by parent reference.\r\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\r\n\t\tfor (const prop of this.properties) {\r\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\r\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listNodes()\r\n\t\t\t.forEach((node) => {\r\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\r\n\t\t\t\tif (instancedMesh) {\r\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\r\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\r\n\r\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\r\n\r\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\r\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\r\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import type { GLTF, TypedArray } from '@gltf-transform/core';\r\n\r\nexport enum EncoderMethod {\r\n\tQUANTIZE = 'quantize',\r\n\tFILTER = 'filter',\r\n}\r\n\r\nexport interface MeshoptBufferExtension {\r\n\tfallback?: boolean;\r\n}\r\n\r\nexport enum MeshoptMode {\r\n\tATTRIBUTES = 'ATTRIBUTES',\r\n\tTRIANGLES = 'TRIANGLES',\r\n\tINDICES = 'INDICES',\r\n}\r\n\r\nexport enum MeshoptFilter {\r\n\tNONE = 'NONE',\r\n\tOCTAHEDRAL = 'OCTAHEDRAL',\r\n\tQUATERNION = 'QUATERNION',\r\n\tEXPONENTIAL = 'EXPONENTIAL',\r\n}\r\n\r\nexport interface MeshoptBufferViewExtension {\r\n\tbuffer: number;\r\n\tbyteOffset: number;\r\n\tbyteLength: number;\r\n\tbyteStride: number;\r\n\tcount: number;\r\n\tmode: MeshoptMode;\r\n\tfilter?: MeshoptFilter;\r\n}\r\n\r\n/**\r\n * When using filters, the accessor definition written to the file will not necessarily have the\r\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\r\n * output, so float32 input must be ignored.\r\n */\r\nexport interface PreparedAccessor {\r\n\tarray: TypedArray;\r\n\tbyteStride: number;\r\n\tnormalized: boolean;\r\n\tcomponentType: GLTF.AccessorComponentType;\r\n\tmin?: number[];\r\n\tmax?: number[];\r\n}\r\n","import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants';\r\nimport {\r\n\tAccessor,\r\n\tAnimationChannel,\r\n\tAnimationSampler,\r\n\tBufferUtils,\r\n\tDocument,\r\n\tGLTF,\r\n\tMathUtils,\r\n\tPrimitive,\r\n\tRoot,\r\n\tTypedArray,\r\n\tTypedArrayConstructor,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport type { MeshoptEncoder } from 'meshoptimizer';\r\n\r\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\r\nconst { normalize, denormalize } = MathUtils;\r\n\r\n/** Pre-processes array with required filters or padding. */\r\nexport function prepareAccessor(\r\n\taccessor: Accessor,\r\n\tencoder: typeof MeshoptEncoder,\r\n\tmode: MeshoptMode,\r\n\tfilterOptions: { filter: MeshoptFilter; bits?: number }\r\n): PreparedAccessor {\r\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\r\n\tconst result: PreparedAccessor = {\r\n\t\tarray: accessor.getArray()!,\r\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\r\n\t\tcomponentType: accessor.getComponentType(),\r\n\t\tnormalized: accessor.getNormalized(),\r\n\t};\r\n\r\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\r\n\r\n\tif (filter !== MeshoptFilter.NONE) {\r\n\t\tlet array = accessor.getNormalized() ? denormalizeArray(accessor) : new Float32Array(result.array);\r\n\r\n\t\tswitch (filter) {\r\n\t\t\tcase MeshoptFilter.EXPONENTIAL: //  K single-precision floating point values.\r\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\r\n\t\t\t\tresult.componentType = FLOAT;\r\n\t\t\t\tresult.normalized = false;\r\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: //  four 8- or 16-bit normalized values.\r\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\r\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\r\n\t\t\t\tresult.normalized = true;\r\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\r\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MeshoptFilter.QUATERNION: //  four 16-bit normalized values.\r\n\t\t\t\tresult.byteStride = 8;\r\n\t\t\t\tresult.componentType = SHORT;\r\n\t\t\t\tresult.normalized = true;\r\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Invalid filter.');\r\n\t\t}\r\n\r\n\t\tresult.min = accessor.getMin([]);\r\n\t\tresult.max = accessor.getMax([]);\r\n\t\tif (accessor.getNormalized()) {\r\n\t\t\tresult.min = result.min.map((v) => denormalize(v, accessor.getComponentType()));\r\n\t\t\tresult.max = result.max.map((v) => denormalize(v, accessor.getComponentType()));\r\n\t\t}\r\n\t\tif (result.normalized) {\r\n\t\t\tresult.min = result.min.map((v) => normalize(v, result.componentType));\r\n\t\t\tresult.max = result.max.map((v) => normalize(v, result.componentType));\r\n\t\t}\r\n\t} else if (result.byteStride % 4) {\r\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\r\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction denormalizeArray(attribute: Accessor): Float32Array {\r\n\tconst componentType = attribute.getComponentType();\r\n\tconst srcArray = attribute.getArray()!;\r\n\tconst dstArray = new Float32Array(srcArray.length);\r\n\tfor (let i = 0; i < srcArray.length; i++) {\r\n\t\tdstArray[i] = denormalize(srcArray[i], componentType);\r\n\t}\r\n\treturn dstArray;\r\n}\r\n\r\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\r\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\r\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\r\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\r\n\tconst elementCount = srcArray.length / elementSize;\r\n\r\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\r\n\r\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\r\n\t\tfor (let j = 0; j < elementSize; j++) {\r\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\r\n\t\t}\r\n\t}\r\n\r\n\treturn dstArray;\r\n}\r\n\r\n/** Pad normals with a .w component for octahedral encoding. */\r\nfunction padNormals(srcArray: Float32Array): Float32Array {\r\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\r\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\r\n\t\tdstArray[i * 4] = srcArray[i * 3];\r\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\r\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\r\n\t}\r\n\treturn dstArray;\r\n}\r\n\r\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\r\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\r\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\r\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\r\n\t\t});\r\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\r\n\t}\r\n\r\n\treturn MeshoptMode.ATTRIBUTES;\r\n}\r\n\r\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\r\n\tconst refs = doc\r\n\t\t.getGraph()\r\n\t\t.listParentEdges(accessor)\r\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\r\n\r\n\tfor (const ref of refs) {\r\n\t\tconst refName = ref.getName();\r\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\r\n\r\n\t\t// Indices.\r\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\r\n\r\n\t\t// Attributes.\r\n\t\t//\r\n\t\t// NOTES:\r\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\r\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\r\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\r\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\r\n\t\t//   quantization for these attributes.\r\n\t\tif (refName === 'attributes') {\r\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey === 'NORMAL') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\r\n\t\t\tif (refKey === 'TANGENT') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\r\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\r\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\r\n\t\t}\r\n\r\n\t\t// Animation.\r\n\t\tif (refName === 'output') {\r\n\t\t\tconst targetPath = getTargetPath(accessor);\r\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\r\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\r\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\r\n\t\t\treturn { filter: MeshoptFilter.NONE };\r\n\t\t}\r\n\r\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/489\r\n\t\tif (refName === 'input') return { filter: MeshoptFilter.NONE };\r\n\r\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\r\n\t}\r\n\r\n\treturn { filter: MeshoptFilter.NONE };\r\n}\r\n\r\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\r\n\tfor (const sampler of accessor.listParents()) {\r\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\r\n\t\tfor (const channel of sampler.listParents()) {\r\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\r\n\t\t\treturn channel.getTargetPath();\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n","import {\r\n\tAccessor,\r\n\tBuffer,\r\n\tBufferUtils,\r\n\tExtension,\r\n\tGLB_BUFFER,\r\n\tGLTF,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants';\r\nimport { EXT_MESHOPT_COMPRESSION } from '../constants';\r\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder';\r\nimport { isFallbackBuffer } from './decoder';\r\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\r\n\r\nconst NAME = EXT_MESHOPT_COMPRESSION;\r\n\r\ninterface EncoderOptions {\r\n\tmethod?: EncoderMethod;\r\n}\r\n\r\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\r\n\tmethod: EncoderMethod.QUANTIZE,\r\n};\r\n\r\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\r\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\r\n\r\n/**\r\n * # MeshoptCompression\r\n *\r\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)\r\n * provides compression and fast decoding for geometry, morph targets, and animations.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\r\n * library) offers a lightweight decoder with very fast runtime decompression, and is\r\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\r\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\r\n * large, other complementary compression methods should be used as well.\r\n *\r\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\r\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\r\n * pre-optimizes assets for this purpose  without this secondary compression, the size\r\n * reduction is considerably less.\r\n *\r\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\r\n * considerably faster than Draco decoding, neither compression method will improve runtime\r\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\r\n * vertex count or draw calls  not just compress it. Finally, be aware that Meshopt compression is\r\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\r\n * compression should generally be the last stage of an art workflow, and uncompressed original\r\n * files should be kept.\r\n *\r\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\r\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\r\n * writing files, and must be provided by the application. Compression may alternatively be applied\r\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { NodeIO } from '@gltf-transform/core';\r\n * import { MeshoptCompression } from '@gltf-transform/extensions';\r\n * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';\r\n *\r\n * await MeshoptDecoder.ready;\r\n * await MeshoptEncoder.ready;\r\n *\r\n * const io = new NodeIO()\r\n *\t.registerExtensions([MeshoptCompression])\r\n *\t.registerDependencies({\r\n *\t\t'meshopt.decoder': MeshoptDecoder,\r\n *\t\t'meshopt.encoder': MeshoptEncoder,\r\n *\t});\r\n *\r\n * // Read and decode.\r\n * const document = await io.read('compressed.glb');\r\n *\r\n * // Write and encode. (Medium, -c)\r\n * await document.transform(\r\n * \treorder({encoder: MeshoptEncoder}),\r\n * \tquantize()\r\n * );\r\n * document.createExtension(MeshoptCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.QUANTIZE });\r\n * await io.write('compressed-medium.glb', document);\r\n *\r\n * // Write and encode. (High, -cc)\r\n * await document.transform(\r\n * \treorder({encoder: MeshoptEncoder}),\r\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\r\n * );\r\n * document.createExtension(MeshoptCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.FILTER });\r\n * await io.write('compressed-high.glb', document);\r\n * ```\r\n */\r\nexport class MeshoptCompression extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\r\n\t/** @hidden */\r\n\tpublic readonly readDependencies = ['meshopt.decoder'];\r\n\t/** @hidden */\r\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\r\n\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\tpublic static readonly EncoderMethod = EncoderMethod;\r\n\r\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\r\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\r\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\r\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\r\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\r\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\r\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\r\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\r\n\r\n\t/** @hidden */\r\n\tpublic install(key: string, dependency: unknown): this {\r\n\t\tif (key === 'meshopt.decoder') {\r\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\r\n\t\t}\r\n\t\tif (key === 'meshopt.encoder') {\r\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\r\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\r\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\r\n\t *\r\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\r\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\r\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\r\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\r\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\r\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\r\n\t * \t`gltfpack -cc`.\r\n\t *\r\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\r\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\r\n\t * with both methods.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```ts\r\n\t * doc.createExtension(MeshoptCompression)\r\n\t * \t.setRequired(true)\r\n\t * \t.setEncoderOptions({\r\n\t * \t\tmethod: MeshoptCompression.EncoderMethod.QUANTIZE\r\n\t * \t});\r\n\t * ```\r\n\t */\r\n\tpublic setEncoderOptions(options: EncoderOptions): this {\r\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Decoding.\r\n\t */\r\n\r\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\r\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\r\n\t\tif (!this._decoder) {\r\n\t\t\tif (!this.isRequired()) return this;\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\r\n\t\t}\r\n\t\tif (!this._decoder.supported) {\r\n\t\t\tif (!this.isRequired()) return this;\r\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\r\n\t\t}\r\n\r\n\t\tif (propertyType === PropertyType.BUFFER) {\r\n\t\t\tthis._prereadBuffers(context);\r\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\r\n\t\t\tthis._prereadPrimitives(context);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @internal Decode buffer views. */\r\n\tprivate _prereadBuffers(context: ReaderContext): void {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\r\n\t\tviewDefs.forEach((viewDef, index) => {\r\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\r\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\r\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\r\n\t\t\tconst count = meshoptDef.count;\r\n\t\t\tconst stride = meshoptDef.byteStride;\r\n\t\t\tconst result = new Uint8Array(count * stride);\r\n\r\n\t\t\tconst bufferDef = jsonDoc.json.buffers![viewDef.buffer];\r\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\r\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\r\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\r\n\r\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\r\n\r\n\t\t\tcontext.bufferViews[index] = result;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Mark fallback buffers and replacements.\r\n\t *\r\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\r\n\t * after Buffers have been parsed.\r\n\t * @internal\r\n\t */\r\n\tprivate _prereadPrimitives(context: ReaderContext): void {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\r\n\r\n\t\t//\r\n\t\tviewDefs.forEach((viewDef) => {\r\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\r\n\r\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\r\n\r\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\r\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\r\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\r\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\r\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/** @hidden Removes Fallback buffers, if extension is required. */\r\n\tpublic read(_context: ReaderContext): this {\r\n\t\tif (!this.isRequired()) return this;\r\n\r\n\t\t// Replace fallback buffers.\r\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\r\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\r\n\t\t\t\tif (parent instanceof Accessor) {\r\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfallbackBuffer.dispose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Encoding.\r\n\t */\r\n\r\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\r\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\r\n\t\tif (propertyType === PropertyType.ACCESSOR) {\r\n\t\t\tthis._prewriteAccessors(context);\r\n\t\t} else if (propertyType === PropertyType.BUFFER) {\r\n\t\t\tthis._prewriteBuffers(context);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @internal Claims accessors that can be compressed. */\r\n\tprivate _prewriteAccessors(context: WriterContext): void {\r\n\t\tconst json = context.jsonDoc.json;\r\n\t\tconst encoder = this._encoder!;\r\n\t\tconst options = this._encoderOptions;\r\n\r\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\r\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\r\n\r\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\r\n\t\tthis._encoderBufferViews = {};\r\n\t\tthis._encoderBufferViewData = {};\r\n\t\tthis._encoderBufferViewAccessors = {};\r\n\r\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\r\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\r\n\t\t\t// Example: https://skfb.ly/6qAD8\r\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\r\n\r\n\t\t\tconst usage = context.getAccessorUsage(accessor);\r\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\r\n\t\t\tconst filter =\r\n\t\t\t\toptions.method === EncoderMethod.FILTER\r\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\r\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\r\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\r\n\t\t\tconst { array, byteStride } = preparedAccessor;\r\n\r\n\t\t\tconst buffer = accessor.getBuffer();\r\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\r\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\r\n\r\n\t\t\t// Buffer view grouping key.\r\n\t\t\tconst key = [usage, mode, filter.filter, byteStride, bufferIndex].join(':');\r\n\r\n\t\t\tlet bufferView = this._encoderBufferViews[key];\r\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\r\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\r\n\r\n\t\t\t// Write new buffer view, if needed.\r\n\t\t\tif (!bufferView || !bufferViewData) {\r\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\r\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\r\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\r\n\t\t\t\t\tbuffer: fallbackBufferIndex,\r\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\r\n\t\t\t\t\tbyteOffset: 0,\r\n\t\t\t\t\tbyteLength: 0,\r\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\r\n\t\t\t\t\textensions: {\r\n\t\t\t\t\t\t[NAME]: {\r\n\t\t\t\t\t\t\tbuffer: bufferIndex,\r\n\t\t\t\t\t\t\tbyteOffset: 0,\r\n\t\t\t\t\t\t\tbyteLength: 0,\r\n\t\t\t\t\t\t\tmode: mode,\r\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\r\n\t\t\t\t\t\t\tbyteStride: byteStride,\r\n\t\t\t\t\t\t\tcount: 0,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Write accessor.\r\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\r\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\r\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\r\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\r\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\r\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\r\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\r\n\t\t\tjson.accessors!.push(accessorDef);\r\n\t\t\tbufferViewAccessors.push(accessorDef);\r\n\r\n\t\t\t// Update buffer view.\r\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\r\n\t\t\tbufferView.byteLength += array.byteLength;\r\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\r\n\t\t}\r\n\t}\r\n\r\n\t/** @internal Writes compressed buffer views. */\r\n\tprivate _prewriteBuffers(context: WriterContext): void {\r\n\t\tconst encoder = this._encoder!;\r\n\r\n\t\tfor (const key in this._encoderBufferViews) {\r\n\t\t\tconst bufferView = this._encoderBufferViews[key];\r\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\r\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\r\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\r\n\r\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\r\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\r\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\r\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\r\n\r\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\r\n\r\n\t\t\tbufferViewData.length = 0;\r\n\t\t\tbufferViewData.push(compressedData);\r\n\t\t\totherBufferViews.push(compressedData);\r\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @hidden Puts encoded data into glTF output. */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tlet fallbackBufferByteOffset = 0;\r\n\r\n\t\t// Write final encoded buffer view properties.\r\n\t\tfor (const key in this._encoderBufferViews) {\r\n\t\t\tconst bufferView = this._encoderBufferViews[key];\r\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\r\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\r\n\r\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\r\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\r\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\r\n\t\t\t}\r\n\r\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\r\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\r\n\r\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\r\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\r\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\r\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\r\n\r\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\r\n\t\t}\r\n\r\n\t\t// Write final fallback buffer.\r\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\r\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\r\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\r\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\r\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\r\n\t\tfallbackBuffer.dispose();\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { EXT_MESHOPT_COMPRESSION } from '../constants';\r\nimport type { GLTF } from '@gltf-transform/core';\r\nimport type { MeshoptBufferExtension } from './constants';\r\n\r\n/**\r\n * Returns true for a fallback buffer, else false.\r\n *\r\n *   - All references to the fallback buffer must come from bufferViews that\r\n *     have a EXT_meshopt_compression extension specified.\r\n *   - No references to the fallback buffer may come from\r\n *     EXT_meshopt_compression extension JSON.\r\n */\r\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\r\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\r\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\r\n\treturn !!fallbackDef.fallback;\r\n}\r\n","import {\r\n\tBufferUtils,\r\n\tExtension,\r\n\tImageUtils,\r\n\tImageUtilsFormat,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n\tvec2,\r\n} from '@gltf-transform/core';\r\nimport { EXT_TEXTURE_WEBP } from '../constants';\r\n\r\nconst NAME = EXT_TEXTURE_WEBP;\r\n\r\nclass WEBPImageUtils implements ImageUtilsFormat {\r\n\tmatch(array: Uint8Array): boolean {\r\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\r\n\t}\r\n\tgetSize(array: Uint8Array): vec2 | null {\r\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\r\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\r\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\r\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\r\n\r\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\r\n\r\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\r\n\t\tlet offset = 12;\r\n\t\twhile (offset < view.byteLength) {\r\n\t\t\tconst chunkId = BufferUtils.decodeText(\r\n\t\t\t\tnew Uint8Array([\r\n\t\t\t\t\tview.getUint8(offset),\r\n\t\t\t\t\tview.getUint8(offset + 1),\r\n\t\t\t\t\tview.getUint8(offset + 2),\r\n\t\t\t\t\tview.getUint8(offset + 3),\r\n\t\t\t\t])\r\n\t\t\t);\r\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\r\n\t\t\tif (chunkId === 'VP8 ') {\r\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\r\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\r\n\t\t\t\treturn [width, height];\r\n\t\t\t} else if (chunkId === 'VP8L') {\r\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\r\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\r\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\r\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\r\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\r\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\r\n\t\t\t\treturn [width, height];\r\n\t\t\t}\r\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\tgetChannels(_buffer: Uint8Array): number {\r\n\t\treturn 4;\r\n\t}\r\n}\r\n\r\n/**\r\n * # TextureWebP\r\n *\r\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\r\n * enables WebP images for any material texture.\r\n *\r\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\r\n *\r\n * WebP typically provides the minimal transmission\r\n * size, but [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\r\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\r\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\r\n * like Basis Universal, with the `KHR_texture_basisu` extension.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\r\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\r\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\r\n * specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TextureWebP } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const webpExtension = document.createExtension(TextureWebP)\r\n * \t.setRequired(true);\r\n * document.createTexture('MyWebPTexture')\r\n * \t.setMimeType('image/webp')\r\n * \t.setImage(fs.readFileSync('my-texture.webp'));\r\n * ```\r\n *\r\n * WebP conversion is not done automatically when adding the extension as shown above  you must\r\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\r\n *\r\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\r\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\r\n * JPEG image data.\r\n */\r\nexport class TextureWebP extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tpublic static register(): void {\r\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\r\n\t\ttextureDefs.forEach((textureDef) => {\r\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\r\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tpublic read(context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listTextures()\r\n\t\t\t.forEach((texture) => {\r\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\r\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\r\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\r\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\r\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\r\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\r\n\t\t\t\t\t\t\tdelete textureDef.source;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\r\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\r\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\r\n\r\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\r\n\r\nexport let decoderModule: DecoderModule;\r\n\r\n// Initialized when decoder module loads.\r\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\r\nlet DATA_TYPE: { [key: number]: DataType };\r\n\r\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\r\n\tconst buffer = new decoderModule.DecoderBuffer();\r\n\ttry {\r\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\r\n\r\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\r\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\r\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\r\n\t\t}\r\n\r\n\t\tconst dracoMesh = new decoderModule.Mesh();\r\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\r\n\r\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\r\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\r\n\t\t}\r\n\r\n\t\treturn dracoMesh;\r\n\t} finally {\r\n\t\tdecoderModule.destroy(buffer);\r\n\t}\r\n}\r\n\r\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\r\n\tconst numFaces = mesh.num_faces();\r\n\tconst numIndices = numFaces * 3;\r\n\r\n\tlet ptr: number;\r\n\tlet indices: Uint16Array | Uint32Array;\r\n\r\n\tif (mesh.num_points() <= 65534) {\r\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\r\n\t\tptr = decoderModule._malloc(byteLength);\r\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\r\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\r\n\t} else {\r\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\r\n\t\tptr = decoderModule._malloc(byteLength);\r\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\r\n\t}\r\n\r\n\tdecoderModule._free(ptr);\r\n\r\n\treturn indices;\r\n}\r\n\r\nexport function decodeAttribute(\r\n\tdecoder: Decoder,\r\n\tmesh: Mesh,\r\n\tattribute: Attribute,\r\n\taccessorDef: GLTF.IAccessor\r\n): TypedArray {\r\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\r\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\r\n\tconst numComponents = attribute.num_components();\r\n\tconst numPoints = mesh.num_points();\r\n\tconst numValues = numPoints * numComponents;\r\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\r\n\r\n\tconst ptr = decoderModule._malloc(byteLength);\r\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\r\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\r\n\tdecoderModule._free(ptr);\r\n\r\n\treturn array;\r\n}\r\n\r\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\r\n\tdecoderModule = _decoderModule;\r\n\r\n\tCOMPONENT_ARRAY = {\r\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\r\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\r\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\r\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\r\n\t};\r\n\r\n\tDATA_TYPE = {\r\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\r\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\r\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\r\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\r\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\r\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\r\n\t};\r\n}\r\n","import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\r\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\r\n\r\nexport let encoderModule: EncoderModule;\r\n\r\nexport enum EncoderMethod {\r\n\tEDGEBREAKER = 1,\r\n\tSEQUENTIAL = 0,\r\n}\r\n\r\nenum AttributeEnum {\r\n\tPOSITION = 'POSITION',\r\n\tNORMAL = 'NORMAL',\r\n\tCOLOR = 'COLOR',\r\n\tTEX_COORD = 'TEX_COORD',\r\n\tGENERIC = 'GENERIC',\r\n}\r\n\r\nconst DEFAULT_QUANTIZATION_BITS = {\r\n\t[AttributeEnum.POSITION]: 14,\r\n\t[AttributeEnum.NORMAL]: 10,\r\n\t[AttributeEnum.COLOR]: 8,\r\n\t[AttributeEnum.TEX_COORD]: 12,\r\n\t[AttributeEnum.GENERIC]: 12,\r\n};\r\n\r\nexport interface EncodedPrimitive {\r\n\tnumVertices: number;\r\n\tnumIndices: number;\r\n\tdata: Uint8Array;\r\n\tattributeIDs: { [key: string]: number };\r\n}\r\n\r\nexport interface EncoderOptions {\r\n\tdecodeSpeed?: number;\r\n\tencodeSpeed?: number;\r\n\tmethod?: EncoderMethod;\r\n\tquantizationBits?: { [key: string]: number };\r\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\r\n}\r\n\r\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\r\n\tdecodeSpeed: 5,\r\n\tencodeSpeed: 5,\r\n\tmethod: EncoderMethod.EDGEBREAKER,\r\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\r\n\tquantizationVolume: 'mesh',\r\n};\r\n\r\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\r\n\tencoderModule = _encoderModule;\r\n}\r\n\r\n/**\r\n * References:\r\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\r\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\r\n */\r\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\r\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\r\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\r\n\r\n\tconst encoder = new encoderModule.Encoder();\r\n\tconst builder = new encoderModule.MeshBuilder();\r\n\tconst mesh = new encoderModule.Mesh();\r\n\r\n\tconst attributeIDs: { [key: string]: number } = {};\r\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\r\n\r\n\tfor (const semantic of prim.listSemantics()) {\r\n\t\tconst attribute = prim.getAttribute(semantic)!;\r\n\t\tconst attributeEnum = getAttributeEnum(semantic);\r\n\t\tconst attributeID: number = addAttribute(\r\n\t\t\tbuilder,\r\n\t\t\tattribute.getComponentType(),\r\n\t\t\tmesh,\r\n\t\t\tencoderModule[attributeEnum],\r\n\t\t\tattribute.getCount(),\r\n\t\t\tattribute.getElementSize(),\r\n\t\t\tattribute.getArray()!\r\n\t\t);\r\n\r\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\r\n\r\n\t\tattributeIDs[semantic] = attributeID;\r\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\r\n\t\t\tencoder.SetAttributeQuantization(encoderModule[attributeEnum], options.quantizationBits[attributeEnum]);\r\n\t\t} else if (typeof options.quantizationVolume === 'object') {\r\n\t\t\tconst { quantizationVolume } = options;\r\n\t\t\tconst range = Math.max(\r\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\r\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\r\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2]\r\n\t\t\t);\r\n\t\t\tencoder.SetAttributeExplicitQuantization(\r\n\t\t\t\tencoderModule[attributeEnum],\r\n\t\t\t\toptions.quantizationBits[attributeEnum],\r\n\t\t\t\tattribute.getElementSize(),\r\n\t\t\t\tquantizationVolume.min,\r\n\t\t\t\trange\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid quantization volume state.');\r\n\t\t}\r\n\t}\r\n\r\n\tconst indices = prim.getIndices();\r\n\tif (!indices) throw new Error('Primitive must have indices.');\r\n\r\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\r\n\r\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\r\n\tencoder.SetTrackEncodedProperties(true);\r\n\r\n\t// Preserve vertex order for primitives with morph targets.\r\n\tif (options.method === EncoderMethod.SEQUENTIAL || prim.listTargets().length > 0) {\r\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\r\n\t} else {\r\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\r\n\t}\r\n\r\n\tconst byteLength = encoder.EncodeMeshToDracoBuffer(mesh, dracoBuffer);\r\n\tif (byteLength <= 0) throw new Error('Error applying Draco compression.');\r\n\r\n\tconst data = new Uint8Array(byteLength);\r\n\tfor (let i = 0; i < byteLength; ++i) {\r\n\t\tdata[i] = dracoBuffer.GetValue(i);\r\n\t}\r\n\r\n\tconst prevNumVertices = prim.getAttribute('POSITION')!.getCount();\r\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\r\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\r\n\r\n\tif (prim.listTargets().length > 0 && numVertices !== prevNumVertices) {\r\n\t\tthrow new Error(\r\n\t\t\t'Compression reduced vertex count unexpectedly, corrupting morph targets.' +\r\n\t\t\t\t' Applying the \"weld\" function before compression may resolve the issue.'\r\n\t\t);\r\n\t}\r\n\r\n\tencoderModule.destroy(dracoBuffer);\r\n\tencoderModule.destroy(mesh);\r\n\tencoderModule.destroy(builder);\r\n\tencoderModule.destroy(encoder);\r\n\r\n\treturn { numVertices, numIndices, data, attributeIDs };\r\n}\r\n\r\nfunction getAttributeEnum(semantic: string): AttributeEnum {\r\n\tif (semantic === 'POSITION') {\r\n\t\treturn AttributeEnum.POSITION;\r\n\t} else if (semantic === 'NORMAL') {\r\n\t\treturn AttributeEnum.NORMAL;\r\n\t} else if (semantic.startsWith('COLOR_')) {\r\n\t\treturn AttributeEnum.COLOR;\r\n\t} else if (semantic.startsWith('TEXCOORD_')) {\r\n\t\treturn AttributeEnum.TEX_COORD;\r\n\t}\r\n\treturn AttributeEnum.GENERIC;\r\n}\r\n\r\nfunction addAttribute(\r\n\tbuilder: MeshBuilder,\r\n\tcomponentType: GLTF.AccessorComponentType,\r\n\tmesh: Mesh,\r\n\tattribute: number,\r\n\tcount: number,\r\n\titemSize: number,\r\n\tarray: TypedArray\r\n): number {\r\n\tswitch (componentType) {\r\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\r\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.BYTE:\r\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\r\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.SHORT:\r\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\r\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\r\n\t\tcase Accessor.ComponentType.FLOAT:\r\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\r\n\t}\r\n}\r\n","import {\r\n\tAccessor,\r\n\tbbox,\r\n\tbounds,\r\n\tBufferUtils,\r\n\tDocument,\r\n\tExtension,\r\n\tGLB_BUFFER,\r\n\tPrimitive,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder';\r\nimport { EncodedPrimitive, encodeGeometry, EncoderMethod, EncoderOptions, initEncoderModule } from './encoder';\r\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\r\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\r\n\r\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\r\n\r\ninterface DracoPrimitiveExtension {\r\n\tbufferView: number;\r\n\tattributes: {\r\n\t\t[name: string]: number;\r\n\t};\r\n}\r\n\r\ninterface DracoWriterContext {\r\n\tprimitiveHashMap: Map<Primitive, string>;\r\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\r\n}\r\n\r\n/**\r\n * # DracoMeshCompression\r\n *\r\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\r\n * provides advanced compression for mesh geometry.\r\n *\r\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\r\n * in many cases. When animation or textures are large, other complementary compression methods\r\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\r\n * size savings.\r\n *\r\n * Be aware that decompression happens before uploading to the GPU  this will add some latency to\r\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\r\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\r\n * or draw calls  not just compress it. Finally, be aware that Draco compression is lossy:\r\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\r\n * compression should generally be the last stage of an art workflow, and uncompressed original\r\n * files should be kept.\r\n *\r\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\r\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\r\n * and must be provided by the application.\r\n *\r\n * ### Encoding options\r\n *\r\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\r\n * edgebreaker method will give higher compression in general, but changes the\r\n * order of the model's vertices. To preserve index order, use sequential\r\n * compression. When a mesh uses morph targets, or a high decoding speed is\r\n * selected, sequential compression will automatically be chosen.\r\n *\r\n * Both speed options affect the encoder's choice of algorithms. For example, a\r\n * requirement for fast decoding may prevent the encoder from using the best\r\n * compression methods even if the encoding speed is set to 0. In general, the\r\n * faster of the two options limits the choice of features that can be used by the\r\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\r\n * the encoder to choose the optimal method out of the available features for the\r\n * given --decodeSpeed.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { NodeIO } from '@gltf-transform/core';\r\n * import { DracoMeshCompression } from '@gltf-transform/extensions';\r\n *\r\n * import draco3d from 'draco3dgltf';\r\n *\r\n * // ...\r\n *\r\n * const io = new NodeIO()\r\n *\t.registerExtensions([DracoMeshCompression])\r\n *\t.registerDependencies({\r\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\r\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\r\n *\t});\r\n *\r\n * // Read and decode.\r\n * const document = await io.read('compressed.glb');\r\n *\r\n * // Write and encode.\r\n * document.createExtension(DracoMeshCompression)\r\n * \t.setRequired(true)\r\n * \t.setEncoderOptions({\r\n * \t\tmethod: DracoMeshCompression.EncoderMethod.EDGEBREAKER,\r\n * \t\tencodeSpeed: 5,\r\n * \t\tdecodeSpeed: 5,\r\n * \t});\r\n * await io.write('compressed.glb', document);\r\n * ```\r\n */\r\nexport class DracoMeshCompression extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\r\n\t/** @hidden */\r\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\r\n\t/** @hidden */\r\n\tpublic readonly readDependencies = ['draco3d.decoder'];\r\n\t/** @hidden */\r\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\r\n\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/**\r\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\r\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\r\n\t */\r\n\tpublic static readonly EncoderMethod = EncoderMethod;\r\n\r\n\tprivate _decoderModule: DecoderModule | null = null;\r\n\tprivate _encoderModule: EncoderModule | null = null;\r\n\tprivate _encoderOptions: EncoderOptions = {};\r\n\r\n\t/** @hidden */\r\n\tpublic install(key: string, dependency: unknown): this {\r\n\t\tif (key === 'draco3d.decoder') {\r\n\t\t\tthis._decoderModule = dependency as DecoderModule;\r\n\t\t\tinitDecoderModule(this._decoderModule);\r\n\t\t}\r\n\t\tif (key === 'draco3d.encoder') {\r\n\t\t\tthis._encoderModule = dependency as EncoderModule;\r\n\t\t\tinitEncoderModule(this._encoderModule);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets Draco compression options. Compression does not take effect until the Document is\r\n\t * written with an I/O class.\r\n\t *\r\n\t * Defaults:\r\n\t * ```\r\n\t * decodeSpeed?: number = 5;\r\n\t * encodeSpeed?: number = 5;\r\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\r\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\r\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\r\n\t * ```\r\n\t */\r\n\tpublic setEncoderOptions(options: EncoderOptions): this {\r\n\t\tthis._encoderOptions = options;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tif (!this._decoderModule) {\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\r\n\t\t}\r\n\r\n\t\tconst logger = this.document.getLogger();\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\r\n\r\n\t\ttry {\r\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\r\n\t\t\tfor (const meshDef of meshDefs) {\r\n\t\t\t\tfor (const primDef of meshDef.primitives) {\r\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\r\n\r\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\r\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\r\n\r\n\t\t\t\t\tif (!dracoMesh || !decoder) {\r\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\r\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\r\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\r\n\t\t\t\t\t\tconst resource = bufferDef.uri\r\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\r\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\r\n\r\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\r\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\r\n\r\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\r\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\r\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\r\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Attributes.\r\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\r\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\r\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\r\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\r\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\r\n\t\t\t\t\tif (primDef.indices !== undefined) {\r\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\r\n\t\t\t\tthis._decoderModule.destroy(decoder);\r\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(_context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\r\n\t\tif (!this._encoderModule) {\r\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\r\n\t\t}\r\n\r\n\t\tconst logger = this.document.getLogger();\r\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\r\n\r\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\r\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\r\n\r\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\r\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\r\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\r\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\r\n\t\t\t} else {\r\n\t\t\t\tquantizationVolume = bounds(this.document.getRoot().listScenes().pop()!);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\r\n\t\t\tconst primHash = primitiveHashMap.get(prim);\r\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\r\n\r\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\r\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\r\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\r\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\r\n\r\n\t\t\t// Create a new EncodedPrimitive.\r\n\t\t\tconst encodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\r\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\r\n\r\n\t\t\t// Create indices definition, update count.\r\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\r\n\t\t\tindicesDef.count = encodedPrim.numIndices;\r\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\r\n\t\t\taccessorDefs.push(indicesDef);\r\n\r\n\t\t\t// Create attribute definitions, update count.\r\n\t\t\tfor (const semantic of prim.listSemantics()) {\r\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\r\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\r\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\r\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\r\n\t\t\t\taccessorDefs.push(attributeDef);\r\n\t\t\t}\r\n\r\n\t\t\t// Map compressed buffer view to a Buffer.\r\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\r\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\r\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\r\n\t\t}\r\n\r\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\r\n\r\n\t\tcontext.extensionData[NAME] = {\r\n\t\t\tprimitiveHashMap,\r\n\t\t\tprimitiveEncodingMap,\r\n\t\t} as DracoWriterContext;\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\r\n\r\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\r\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\r\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\r\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\r\n\t\t\t\tconst primDef = meshDef.primitives[i];\r\n\r\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\r\n\t\t\t\tif (!primHash) continue;\r\n\r\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\r\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\r\n\t\t\t\tprimDef.extensions[NAME] = {\r\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\r\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Omit the extension if nothing was compressed.\r\n\t\tif (!dracoContext.primitiveHashMap.size) {\r\n\t\t\tconst json = context.jsonDoc.json;\r\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\r\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\r\n * fail, and would break assumptions required for compression, this function will throw an error.\r\n */\r\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\r\n\tconst logger = doc.getLogger();\r\n\tconst included = new Set<Primitive>();\r\n\tconst excluded = new Set<Primitive>();\r\n\r\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\r\n\tfor (const mesh of doc.getRoot().listMeshes()) {\r\n\t\tfor (const prim of mesh.listPrimitives()) {\r\n\t\t\tif (!prim.getIndices()) {\r\n\t\t\t\texcluded.add(prim);\r\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-indexed primitive.`);\r\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\r\n\t\t\t\texcluded.add(prim);\r\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-TRIANGLES primitive.`);\r\n\t\t\t} else {\r\n\t\t\t\tincluded.add(prim);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Create an Accessor->index mapping.\r\n\tconst accessors = doc.getRoot().listAccessors();\r\n\tconst accessorIndices = new Map<Accessor, number>();\r\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\r\n\r\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\r\n\t// compressed Primitive and Accessor to this hash key.\r\n\tconst includedAccessors = new Map<Accessor, string>();\r\n\tconst includedHashKeys = new Set<string>();\r\n\tconst primToHashKey = new Map<Primitive, string>();\r\n\tfor (const prim of Array.from(included)) {\r\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\r\n\r\n\t\t// If accessors of an identical primitive have already been checked, we're done.\r\n\t\tif (includedHashKeys.has(hashKey)) {\r\n\t\t\tprimToHashKey.set(prim, hashKey);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\r\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\r\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\r\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\r\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\r\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\t\tconst dstIndices = indices.clone();\r\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\r\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\r\n\t\t}\r\n\t\tfor (const attribute of prim.listAttributes()) {\r\n\t\t\tif (includedAccessors.has(attribute)) {\r\n\t\t\t\tconst dstAttribute = attribute.clone();\r\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\r\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// With conflicts resolved, compute the hash key again.\r\n\t\thashKey = createHashKey(prim, accessorIndices);\r\n\r\n\t\t// Commit the primitive and its accessors to the hash key.\r\n\t\tincludedHashKeys.add(hashKey);\r\n\t\tprimToHashKey.set(prim, hashKey);\r\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\r\n\t\tfor (const attribute of prim.listAttributes()) {\r\n\t\t\tincludedAccessors.set(attribute, hashKey);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\r\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\r\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\r\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\r\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\r\n\tfor (const prim of Array.from(included)) {\r\n\t\tconst hashKey = primToHashKey.get(prim);\r\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\tif (\r\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\r\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\r\n\t\t) {\r\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\r\n\t\t}\r\n\t}\r\n\r\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\r\n\tfor (const prim of Array.from(excluded)) {\r\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\r\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\r\n\t\t}\r\n\t}\r\n\r\n\treturn primToHashKey;\r\n}\r\n\r\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\r\n\tconst hashElements = [];\r\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\r\n\r\n\thashElements.push(indexMap.get(indices));\r\n\tfor (const attribute of prim.listAttributes()) {\r\n\t\thashElements.push(indexMap.get(attribute));\r\n\t}\r\n\r\n\treturn hashElements.sort().join('|');\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\r\nimport { ColorUtils } from '@gltf-transform/core';\r\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\r\n\r\ninterface ILight extends IProperty {\r\n\tcolor: vec3;\r\n\tintensity: number;\r\n\ttype: PunctualLightType;\r\n\trange: number | null;\r\n\tinnerConeAngle: number;\r\n\touterConeAngle: number;\r\n}\r\n\r\ntype PunctualLightType = 'point' | 'spot' | 'directional';\r\n\r\n/**\r\n * # Light\r\n *\r\n * Defines a light attached to a {@link Node}. See {@link LightsPunctual}.\r\n */\r\nexport class Light extends ExtensionProperty<ILight> {\r\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\r\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\r\n\tpublic declare propertyType: 'Light';\r\n\tpublic declare parentTypes: [PropertyType.NODE];\r\n\r\n\t/**********************************************************************************************\r\n\t * CONSTANTS.\r\n\t */\r\n\r\n\tpublic static Type: Record<string, PunctualLightType> = {\r\n\t\tPOINT: 'point',\r\n\t\tSPOT: 'spot',\r\n\t\tDIRECTIONAL: 'directional',\r\n\t};\r\n\r\n\t/**********************************************************************************************\r\n\t * INSTANCE.\r\n\t */\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\r\n\t\tthis.propertyType = 'Light';\r\n\t\tthis.parentTypes = [PropertyType.NODE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ILight> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tcolor: [1, 1, 1] as vec3,\r\n\t\t\tintensity: 1,\r\n\t\t\ttype: Light.Type.POINT,\r\n\t\t\trange: null,\r\n\t\t\tinnerConeAngle: 0,\r\n\t\t\touterConeAngle: Math.PI / 4,\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * COLOR.\r\n\t */\r\n\r\n\t/** Light color; Linear-sRGB components. */\r\n\tpublic getColor(): vec3 {\r\n\t\treturn this.get('color');\r\n\t}\r\n\r\n\t/** Light color; Linear-sRGB components. */\r\n\tpublic setColor(color: vec3): this {\r\n\t\treturn this.set('color', color);\r\n\t}\r\n\r\n\t/** Light color; sRGB hexadecimal color. */\r\n\tpublic getColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getColor());\r\n\t}\r\n\r\n\t/** Light color; sRGB hexadecimal color. */\r\n\tpublic setColorHex(hex: number): this {\r\n\t\tconst color = this.getColor().slice() as vec3;\r\n\t\tColorUtils.hexToFactor(hex, color);\r\n\t\treturn this.setColor(color);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * INTENSITY.\r\n\t */\r\n\r\n\t/**\r\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\r\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\r\n\t */\r\n\tpublic getIntensity(): number {\r\n\t\treturn this.get('intensity');\r\n\t}\r\n\r\n\t/**\r\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\r\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\r\n\t */\r\n\tpublic setIntensity(intensity: number): this {\r\n\t\treturn this.set('intensity', intensity);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * TYPE.\r\n\t */\r\n\r\n\t/** Type. */\r\n\tpublic getType(): PunctualLightType {\r\n\t\treturn this.get('type');\r\n\t}\r\n\r\n\t/** Type. */\r\n\tpublic setType(type: PunctualLightType): this {\r\n\t\treturn this.set('type', type);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * RANGE.\r\n\t */\r\n\r\n\t/**\r\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\r\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\r\n\t * is assumed to be infinite.\r\n\t */\r\n\tpublic getRange(): number | null {\r\n\t\treturn this.get('range');\r\n\t}\r\n\r\n\t/**\r\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\r\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\r\n\t * is assumed to be infinite.\r\n\t */\r\n\tpublic setRange(range: number | null): this {\r\n\t\treturn this.set('range', range);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * SPOT LIGHT PROPERTIES\r\n\t */\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\r\n\t * < outerConeAngle.\r\n\t */\r\n\tpublic getInnerConeAngle(): number {\r\n\t\treturn this.get('innerConeAngle');\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be  0 and\r\n\t * < outerConeAngle.\r\n\t */\r\n\tpublic setInnerConeAngle(angle: number): this {\r\n\t\treturn this.set('innerConeAngle', angle);\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\r\n\t *  PI / 2.0.\r\n\t */\r\n\tpublic getOuterConeAngle(): number {\r\n\t\treturn this.get('outerConeAngle');\r\n\t}\r\n\r\n\t/**\r\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\r\n\t *  PI / 2.0.\r\n\t */\r\n\tpublic setOuterConeAngle(angle: number): this {\r\n\t\treturn this.set('outerConeAngle', angle);\r\n\t}\r\n}\r\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\r\nimport { Light } from './light';\r\n\r\nconst NAME = KHR_LIGHTS_PUNCTUAL;\r\n\r\ninterface LightsPunctualRootDef {\r\n\tlights?: LightDef[];\r\n}\r\n\r\ninterface LightsPunctualNodeDef {\r\n\tlight: number;\r\n}\r\n\r\ninterface LightDef {\r\n\tname?: string;\r\n\tcolor?: vec3;\r\n\tintensity?: number;\r\n\trange?: number;\r\n\ttype: 'spot' | 'point' | 'directional';\r\n\tspot?: {\r\n\t\tinnerConeAngle?: number;\r\n\t\touterConeAngle?: number;\r\n\t};\r\n}\r\n\r\n/**\r\n * # LightsPunctual\r\n *\r\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\r\n * spot.\r\n *\r\n * Punctual lights are parameterized, infinitely small points that emit light in\r\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\r\n * of that node.\r\n *\r\n * Properties:\r\n * - {@link Light}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { LightsPunctual, Light, LightType } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const lightsExtension = document.createExtension(LightsPunctual);\r\n *\r\n * // Create a Light property.\r\n * const light = lightsExtension.createLight()\r\n *\t.setType(LightType.POINT)\r\n *\t.setIntensity(2.0)\r\n *\t.setColor([1.0, 0.0, 0.0]);\r\n *\r\n * // Attach the property to a Material.\r\n * node.setExtension('KHR_lights_punctual', light);\r\n * ```\r\n */\r\nexport class LightsPunctual extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\r\n\tpublic createLight(name = ''): Light {\r\n\t\treturn new Light(this.document.getGraph(), name);\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\r\n\r\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\r\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\r\n\t\tconst lights = lightDefs.map((lightDef) => {\r\n\t\t\tconst light = this.createLight()\r\n\t\t\t\t.setName(lightDef.name || '')\r\n\t\t\t\t.setType(lightDef.type);\r\n\r\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\r\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\r\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\r\n\r\n\t\t\tif (lightDef.spot?.innerConeAngle !== undefined) {\r\n\t\t\t\tlight.setInnerConeAngle(lightDef.spot.innerConeAngle);\r\n\t\t\t}\r\n\t\t\tif (lightDef.spot?.outerConeAngle !== undefined) {\r\n\t\t\t\tlight.setOuterConeAngle(lightDef.spot.outerConeAngle);\r\n\t\t\t}\r\n\r\n\t\t\treturn light;\r\n\t\t});\r\n\r\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\r\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\r\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\r\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (this.properties.size === 0) return this;\r\n\r\n\t\tconst lightDefs = [];\r\n\t\tconst lightIndexMap = new Map<Light, number>();\r\n\r\n\t\tfor (const property of this.properties) {\r\n\t\t\tconst light = property as Light;\r\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\r\n\r\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\r\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\r\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\r\n\r\n\t\t\tif (light.getName()) lightDef.name = light.getName();\r\n\r\n\t\t\tif (light.getType() === Light.Type.SPOT) {\r\n\t\t\t\tlightDef.spot = {\r\n\t\t\t\t\tinnerConeAngle: light.getInnerConeAngle(),\r\n\t\t\t\t\touterConeAngle: light.getOuterConeAngle(),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlightDefs.push(lightDef);\r\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\r\n\t\t}\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listNodes()\r\n\t\t\t.forEach((node) => {\r\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\r\n\t\t\t\tif (light) {\r\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\r\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\r\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\r\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n  vec3\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_ANISOTROPY } from '../constants';\r\n\r\n\r\ninterface IAnisotropy extends IProperty {\r\n\tanisotropy: number;\r\n\tanisotropyTexture: Texture;\r\n\tanisotropyTextureInfo: TextureInfo;\r\n\r\n\tanisotropyDirection: vec3;\r\n\tanisotropyDirectionTexture: Texture;\r\n\tanisotropyDirectionTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B } = TextureChannel;\r\n\r\n/**\r\n * # Anisotropy\r\n *\r\n * Defines anisotropy for a PBR material. See {@link MaterialsAnisotropy}.\r\n */\r\nexport class Anisotropy extends ExtensionProperty<IAnisotropy> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_ANISOTROPY;\r\n\tpublic declare propertyType: 'Anisotropy';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n  protected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_ANISOTROPY;\r\n\t\tthis.propertyType = 'Anisotropy';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n  protected getDefaults(): Nullable<IAnisotropy> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tanisotropy: 0,\r\n\t\t\tanisotropyTexture: null,\r\n\t\t\tanisotropyTextureInfo: new TextureInfo(this.graph, 'anisotropyTextureInfo'),\r\n\r\n\t\t\tanisotropyDirection: [1.0, 0.0, 0.0] as vec3,\r\n\t\t\tanisotropyDirectionTexture: null,\r\n\t\t\tanisotropyDirectionTextureInfo: new TextureInfo(this.graph, 'anisotropyDirectionTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Anisotropy.\r\n\t */\r\n\r\n\t/** Anisotropy; See {@link getAnisotropyTexture. */\r\n\tpublic getAnisotropy(): number {\r\n    return this.get('anisotropy');\r\n  }\r\n\r\n\t/** Anisotropy; See {@link setAnisotropyTexture.}. */\r\n\tpublic setAnisotropy(val: number): this {\r\n    return this.set('anisotropy', val);\r\n\t}\r\n\r\n\t/**\r\n\t * Anisotropy texture.\r\n\t */\r\n\tpublic getAnisotropyTexture(): Texture | null {\r\n\t\treturn this.getRef('anisotropyTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its anisotropy texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getAnisotropyTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('anisotropyTexture') ? this.getRef('anisotropyTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets anisotropy texture. See {@link getAnisotropyTexture}. */\r\n\tpublic setAnisotropyTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('anisotropyTexture', texture, { channels: R });\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Anisotropy direction.\r\n\t */\r\n\r\n\t/** Anisotropy direction; See {@link getAnisotropyDirectionTexture}. */\r\n\tpublic getAnisotropyDirection(): vec3 {\r\n\t\treturn this.get('anisotropyDirection');\r\n  }\r\n\r\n\t/** Anisotropy direction; See {@link setAnisotropyDirectionTexture}. */\r\n\tpublic setAnisotropyDirection(direction: vec3): this {\r\n\t\treturn this.set('anisotropyDirection', direction);\r\n\t}\r\n\r\n\t/**\r\n\t * Anisotropy direction texture.\r\n\t */\r\n\tpublic getAnisotropyDirectionTexture(): Texture | null {\r\n\t\treturn this.getRef('anisotropyDirectionTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its anisotropy direction texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getAnisotropyDirectionTextureInfo(): TextureInfo | null {\r\n    return this.getRef('anisotropyDirectionTexture') ? this.getRef('anisotropyDirectionTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets anisotropy direction texture. See {@link getAnisotropyDirectionTexture}. */\r\n\tpublic setAnisotropyDirectionTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('anisotropyDirectionTexture', texture, { channels: G });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_ANISOTROPY} from '../constants';\r\nimport { Anisotropy } from './anisotropy';\r\n\r\nconst NAME = KHR_MATERIALS_ANISOTROPY;\r\n\r\ninterface AnisotropyDef {\r\n\tanisotropy?: number;\r\n\tanisotropyDirection?: vec3;\r\n\tanisotropyTexture?: GLTF.ITextureInfo;\r\n\tanisotropyDirectionTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsAnisotropy\r\n */\r\nexport class MaterialsAnisotropy extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\tpublic createAnisotropy(): Anisotropy {\r\n\t\treturn new Anisotropy(this.document.getGraph());\r\n\t}\r\n\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst anisotropy = this.createAnisotropy();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, anisotropy);\r\n\r\n\t\t\t\tconst anisotropyDef = materialDef.extensions[NAME] as AnisotropyDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (anisotropyDef.anisotropy !== undefined) {\r\n\t\t\t\t\tanisotropy.setAnisotropy(anisotropyDef.anisotropy);\r\n\t\t\t\t}\r\n\t\t\t\tif (anisotropyDef.anisotropyDirection !== undefined) {\r\n\t\t\t\t\tanisotropy.setAnisotropyDirection(\r\n\t\t\t\t\t\tanisotropyDef.anisotropyDirection\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (anisotropyDef.anisotropyTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = anisotropyDef.anisotropyTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tanisotropy.setAnisotropyTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(anisotropy.getAnisotropyTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (anisotropyDef.anisotropyDirectionTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = anisotropyDef.anisotropyDirectionTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tanisotropy.setAnisotropyDirectionTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(\r\n\t\t\t\t\t\tanisotropy.getAnisotropyDirectionTextureInfo()!,\r\n\t\t\t\t\t\ttextureInfoDef\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst anisotropy = material.getExtension<Anisotropy>(NAME);\r\n\t\t\t\tif (anisotropy) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst anisotropyDef = materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tanisotropy: anisotropy.getAnisotropy(),\r\n\t\t\t\t\t\tanisotropyDirection: anisotropy.getAnisotropyDirection(),\r\n\t\t\t\t\t} as AnisotropyDef;\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (anisotropy.getAnisotropyTexture()) {\r\n\t\t\t\t\t\tconst texture = anisotropy.getAnisotropyTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = anisotropy.getAnisotropyTextureInfo()!;\r\n\t\t\t\t\t\tanisotropyDef.anisotropyTexture\r\n\t\t\t\t\t\t\t= context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (anisotropy.getAnisotropyDirectionTexture()) {\r\n\t\t\t\t\t\tconst texture = anisotropy.getAnisotropyDirectionTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = anisotropy.getAnisotropyDirectionTextureInfo()!;\r\n\t\t\t\t\t\tanisotropyDef.anisotropyDirectionTexture\r\n\t\t\t\t\t\t\t= context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\r\n\r\ninterface IClearcoat extends IProperty {\r\n\tclearcoatFactor: number;\r\n\tclearcoatTexture: Texture;\r\n\tclearcoatTextureInfo: TextureInfo;\r\n\r\n\tclearcoatRoughnessFactor: number;\r\n\tclearcoatRoughnessTexture: Texture;\r\n\tclearcoatRoughnessTextureInfo: TextureInfo;\r\n\r\n\tclearcoatNormalScale: number;\r\n\tclearcoatNormalTexture: Texture;\r\n\tclearcoatNormalTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B } = TextureChannel;\r\n\r\n/**\r\n * # Clearcoat\r\n *\r\n * Defines clear coat for a PBR material. See {@link MaterialsClearcoat}.\r\n */\r\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\r\n\tpublic declare propertyType: 'Clearcoat';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\r\n\t\tthis.propertyType = 'Clearcoat';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IClearcoat> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tclearcoatFactor: 0,\r\n\t\t\tclearcoatTexture: null,\r\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\r\n\r\n\t\t\tclearcoatRoughnessFactor: 0,\r\n\t\t\tclearcoatRoughnessTexture: null,\r\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\r\n\r\n\t\t\tclearcoatNormalScale: 1,\r\n\t\t\tclearcoatNormalTexture: null,\r\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat.\r\n\t */\r\n\r\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\r\n\tpublic getClearcoatFactor(): number {\r\n\t\treturn this.get('clearcoatFactor');\r\n\t}\r\n\r\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\r\n\tpublic setClearcoatFactor(factor: number): this {\r\n\t\treturn this.set('clearcoatFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\r\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\r\n\t * normal map properties.\r\n\t */\r\n\tpublic getClearcoatTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat texture. See {@link getClearcoatTexture}. */\r\n\tpublic setClearcoatTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat roughness.\r\n\t */\r\n\r\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic getClearcoatRoughnessFactor(): number {\r\n\t\treturn this.get('clearcoatRoughnessFactor');\r\n\t}\r\n\r\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\r\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatRoughnessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat roughness texture. See {@link getClearcoatRoughnessTexture}. */\r\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Clearcoat normals.\r\n\t */\r\n\r\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\r\n\tpublic getClearcoatNormalScale(): number {\r\n\t\treturn this.get('clearcoatNormalScale');\r\n\t}\r\n\r\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\r\n\tpublic setClearcoatNormalScale(scale: number): this {\r\n\t\treturn this.set('clearcoatNormalScale', scale);\r\n\t}\r\n\r\n\t/**\r\n\t * Clearcoat normal map. Independent of the material base layer normal map.\r\n\t */\r\n\tpublic getClearcoatNormalTexture(): Texture | null {\r\n\t\treturn this.getRef('clearcoatNormalTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets clearcoat normal texture. See {@link getClearcoatNormalTexture}. */\r\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\r\nimport { Clearcoat } from './clearcoat';\r\n\r\nconst NAME = KHR_MATERIALS_CLEARCOAT;\r\n\r\ninterface ClearcoatDef {\r\n\tclearcoatFactor?: number;\r\n\tclearcoatRoughnessFactor?: number;\r\n\tclearcoatTexture?: GLTF.ITextureInfo;\r\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\r\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsClearcoat\r\n *\r\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)\r\n * defines a clear coating on a glTF PBR material.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\r\n *\r\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\r\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\r\n *\r\n * A clear coat is a common technique used in Physically-Based\r\n * Rendering for a protective layer applied to a base material.\r\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\r\n *\r\n * Properties:\r\n * - {@link Clearcoat}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const clearcoatExtension = document.createExtension(MaterialsClearcoat);\r\n *\r\n * // Create Clearcoat property.\r\n * const clearcoat = clearcoatExtension.createClearcoat()\r\n *\t.setClearcoatFactor(1.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\r\n * ```\r\n */\r\nexport class MaterialsClearcoat extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\r\n\tpublic createClearcoat(): Clearcoat {\r\n\t\treturn new Clearcoat(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst clearcoat = this.createClearcoat();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\r\n\r\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\r\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\r\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\r\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\r\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\r\n\t\t\t\tif (clearcoat) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\r\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\r\n\t\t\t\t\t} as ClearcoatDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\r\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\r\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\r\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\r\n\r\ninterface IEmissiveStrength extends IProperty {\r\n\temissiveStrength: number;\r\n}\r\n\r\n/**\r\n * # EmissiveStrength\r\n *\r\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\r\n * (HDR) emissive materials. See {@link MaterialsEmissiveStrength}.\r\n */\r\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\tpublic declare propertyType: 'EmissiveStrength';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\t\tthis.propertyType = 'EmissiveStrength';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * EmissiveStrength.\r\n\t */\r\n\r\n\t/** EmissiveStrength. */\r\n\tpublic getEmissiveStrength(): number {\r\n\t\treturn this.get('emissiveStrength');\r\n\t}\r\n\r\n\t/** EmissiveStrength. */\r\n\tpublic setEmissiveStrength(strength: number): this {\r\n\t\treturn this.set('emissiveStrength', strength);\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\r\nimport { EmissiveStrength } from './emissive-strength';\r\n\r\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\r\ninterface EmissiveStrengthDef {\r\n\temissiveStrength?: number;\r\n}\r\n\r\n/**\r\n * # MaterialsEmissiveStrength\r\n *\r\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\r\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\r\n *\r\n * [[include:UNRATIFIED_EXTENSIONS_NOTE.md]]\r\n *\r\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\r\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\r\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\r\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\r\n *\r\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\r\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\r\n * given arbitrarily high values.\r\n *\r\n * For implementations where a physical light unit is needed, the units for the multiplicative\r\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\r\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\r\n * emissive factor of 1.0 results in a fully exposed pixel.\r\n *\r\n * Properties:\r\n * - {@link EmissiveStrength}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const emissiveStrengthExtension = document.createExtension(MaterialsEmissiveStrength);\r\n *\r\n * // Create EmissiveStrength property.\r\n * const emissiveStrength = emissiveStrengthExtension\r\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\r\n * ```\r\n */\r\nexport class MaterialsEmissiveStrength extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\r\n\tpublic createEmissiveStrength(): EmissiveStrength {\r\n\t\treturn new EmissiveStrength(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\r\n\r\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\r\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\r\n\t\t\t\tif (emissiveStrength) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\r\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\r\n\t\t\t\t\t} as EmissiveStrengthDef;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IOR } from '../constants';\r\n\r\ninterface IIOR extends IProperty {\r\n\tior: number;\r\n}\r\n\r\n/**\r\n * # IOR\r\n *\r\n * Defines index of refraction for a PBR {@link Material}. See {@link MaterialsIOR}.\r\n */\r\nexport class IOR extends ExtensionProperty<IIOR> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\r\n\tpublic declare propertyType: 'IOR';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\r\n\t\tthis.propertyType = 'IOR';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IIOR> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 0 });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * IOR.\r\n\t */\r\n\r\n\t/** IOR. */\r\n\tpublic getIOR(): number {\r\n\t\treturn this.get('ior');\r\n\t}\r\n\r\n\t/** IOR. */\r\n\tpublic setIOR(ior: number): this {\r\n\t\treturn this.set('ior', ior);\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IOR } from '../constants';\r\nimport { IOR } from './ior';\r\n\r\nconst NAME = KHR_MATERIALS_IOR;\r\n\r\ninterface IORDef {\r\n\tior?: number;\r\n}\r\n\r\n/**\r\n * # MaterialsIOR\r\n *\r\n * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)\r\n * defines index of refraction on a glTF PBR material.\r\n *\r\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\r\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\r\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\r\n * refraction to a certain value.\r\n *\r\n * Properties:\r\n * - {@link IOR}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsIOR, IOR } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const iorExtension = document.createExtension(MaterialsIOR);\r\n *\r\n * // Create IOR property.\r\n * const ior = iorExtension.createIOR().setIOR(1.0);\r\n *\r\n * // Assign to a Material.\r\n * material.setExtension('KHR_materials_ior', ior);\r\n * ```\r\n */\r\nexport class MaterialsIOR extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new IOR property for use on a {@link Material}. */\r\n\tpublic createIOR(): IOR {\r\n\t\treturn new IOR(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst ior = this.createIOR();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\r\n\r\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (iorDef.ior !== undefined) {\r\n\t\t\t\t\tior.setIOR(iorDef.ior);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\r\n\t\t\t\tif (ior) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tior: ior.getIOR(),\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\r\n\r\ninterface IIridescence extends IProperty {\r\n\tiridescenceFactor: number;\r\n\tiridescenceTexture: Texture;\r\n\tiridescenceTextureInfo: TextureInfo;\r\n\tiridescenceIOR: number;\r\n\tiridescenceThicknessMinimum: number;\r\n\tiridescenceThicknessMaximum: number;\r\n\tiridescenceThicknessTexture: Texture;\r\n\tiridescenceThicknessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G } = TextureChannel;\r\n\r\n/**\r\n * # Iridescence\r\n *\r\n * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link MaterialsIridescence}.\r\n */\r\nexport class Iridescence extends ExtensionProperty<IIridescence> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_IRIDESCENCE;\r\n\tpublic declare propertyType: 'Iridescence';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_IRIDESCENCE;\r\n\t\tthis.propertyType = 'Iridescence';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IIridescence> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tiridescenceFactor: 0.0,\r\n\t\t\tiridescenceTexture: null,\r\n\t\t\tiridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),\r\n\t\t\tiridescenceIOR: 1.3,\r\n\t\t\tiridescenceThicknessMinimum: 100,\r\n\t\t\tiridescenceThicknessMaximum: 400,\r\n\t\t\tiridescenceThicknessTexture: null,\r\n\t\t\tiridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence.\r\n\t */\r\n\r\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\r\n\tpublic getIridescenceFactor(): number {\r\n\t\treturn this.get('iridescenceFactor');\r\n\t}\r\n\r\n\t/** Iridescence; linear multiplier. See {@link getIridescenceTexture}. */\r\n\tpublic setIridescenceFactor(factor: number): this {\r\n\t\treturn this.set('iridescenceFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Iridescence intensity.\r\n\t *\r\n\t * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\r\n\t * be packed with additional data in the other channels.\r\n\t */\r\n\tpublic getIridescenceTexture(): Texture | null {\r\n\t\treturn this.getRef('iridescenceTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its iridescence texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getIridescenceTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Iridescence intensity. See {@link getIridescenceTexture}. */\r\n\tpublic setIridescenceTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('iridescenceTexture', texture, { channels: R });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence IOR.\r\n\t */\r\n\r\n\t/** Index of refraction of the dielectric thin-film layer. */\r\n\tpublic getIridescenceIOR(): number {\r\n\t\treturn this.get('iridescenceIOR');\r\n\t}\r\n\r\n\t/** Index of refraction of the dielectric thin-film layer. */\r\n\tpublic setIridescenceIOR(ior: number): this {\r\n\t\treturn this.set('iridescenceIOR', ior);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Iridescence thickness.\r\n\t */\r\n\r\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic getIridescenceThicknessMinimum(): number {\r\n\t\treturn this.get('iridescenceThicknessMinimum');\r\n\t}\r\n\r\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic setIridescenceThicknessMinimum(thickness: number): this {\r\n\t\treturn this.set('iridescenceThicknessMinimum', thickness);\r\n\t}\r\n\r\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic getIridescenceThicknessMaximum(): number {\r\n\t\treturn this.get('iridescenceThicknessMaximum');\r\n\t}\r\n\r\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\r\n\tpublic setIridescenceThicknessMaximum(thickness: number): this {\r\n\t\treturn this.set('iridescenceThicknessMaximum', thickness);\r\n\t}\r\n\r\n\t/**\r\n\t * The green channel of this texture defines the thickness of the\r\n\t * thin-film layer by blending between the minimum and maximum thickness.\r\n\t */\r\n\tpublic getIridescenceThicknessTexture(): Texture | null {\r\n\t\treturn this.getRef('iridescenceThicknessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its iridescence thickness texture.\r\n\t * If no texture is attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getIridescenceThicknessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets iridescence thickness texture. See {@link getIridescenceThicknessTexture}. */\r\n\tpublic setIridescenceThicknessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('iridescenceThicknessTexture', texture, { channels: G });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants';\r\nimport { Iridescence } from './iridescence';\r\n\r\nconst NAME = KHR_MATERIALS_IRIDESCENCE;\r\n\r\ninterface IridescenceDef {\r\n\tiridescenceFactor: number;\r\n\tiridescenceTexture: GLTF.ITextureInfo;\r\n\tiridescenceIor: number;\r\n\tiridescenceThicknessMinimum: number;\r\n\tiridescenceThicknessMaximum: number;\r\n\tiridescenceThicknessTexture: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsIridescence\r\n *\r\n * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)\r\n * defines iridescence (thin film interference) on a PBR material.\r\n *\r\n * Iridescence describes an effect where hue varies depending on the viewing\r\n * angle and illumination angle: A thin-film of a semi-transparent layer\r\n * results in inter-reflections and due to thin-film interference, certain\r\n * wavelengths get absorbed or amplified. Iridescence can be seen on soap\r\n * bubbles, oil films, or on the wings of many insects. With this extension,\r\n * thickness and index of refraction (IOR) of the thin-film can be specified,\r\n * enabling iridescent materials.\r\n *\r\n * Properties:\r\n * - {@link Iridescence}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsIridescence, Iridescence } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const iridescenceExtension = document.createExtension(MaterialsIridescence);\r\n *\r\n * // Create an Iridescence property.\r\n * const iridescence = iridescenceExtension.createIridescence()\r\n * \t.setIridescenceFactor(1.0)\r\n * \t.setIridescenceIOR(1.8);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_iridescence', iridescence);\r\n * ```\r\n */\r\nexport class MaterialsIridescence extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Iridescence property for use on a {@link Material}. */\r\n\tpublic createIridescence(): Iridescence {\r\n\t\treturn new Iridescence(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst iridescence = this.createIridescence();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, iridescence);\r\n\r\n\t\t\t\tconst iridescenceDef = materialDef.extensions[NAME] as IridescenceDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (iridescenceDef.iridescenceFactor !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceIor !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMinimum !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMaximum !== undefined) {\r\n\t\t\t\t\tiridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (iridescenceDef.iridescenceTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tiridescence.setIridescenceTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (iridescenceDef.iridescenceThicknessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tiridescence.setIridescenceThicknessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst iridescence = material.getExtension<Iridescence>(NAME);\r\n\t\t\t\tif (iridescence) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst iridescenceDef = (materialDef.extensions[NAME] = {} as IridescenceDef);\r\n\r\n\t\t\t\t\tif (iridescence.getIridescenceFactor() > 0) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceIOR() !== 1.3) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMinimum() !== 100) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMaximum() !== 400) {\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (iridescence.getIridescenceTexture()) {\r\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceTextureInfo()!;\r\n\t\t\t\t\t\tiridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (iridescence.getIridescenceThicknessTexture()) {\r\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceThicknessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceThicknessTextureInfo()!;\r\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n\tvec4,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\r\n\r\ninterface IPBRSpecularGlossiness extends IProperty {\r\n\tdiffuseFactor: vec4;\r\n\tdiffuseTexture: Texture;\r\n\tdiffuseTextureInfo: TextureInfo;\r\n\tspecularFactor: vec3;\r\n\tglossinessFactor: number;\r\n\tspecularGlossinessTexture: Texture;\r\n\tspecularGlossinessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # PBRSpecularGlossiness\r\n *\r\n * Converts a {@link Material} to a spec/gloss workflow. See {@link MaterialsPBRSpecularGlossiness}.\r\n */\r\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\r\n\t\t\tdiffuseTexture: null,\r\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\r\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\tglossinessFactor: 1.0,\r\n\t\t\tspecularGlossinessTexture: null,\r\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Diffuse.\r\n\t */\r\n\r\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\r\n\tpublic getDiffuseFactor(): vec4 {\r\n\t\treturn this.get('diffuseFactor');\r\n\t}\r\n\r\n\t/** Diffuse; Linear-sRGB components. See {@link getDiffuseTexture}. */\r\n\tpublic setDiffuseFactor(factor: vec4): this {\r\n\t\treturn this.set('diffuseFactor', factor);\r\n\t}\r\n\r\n\t/** Diffuse; sRGB hexadecimal color. */\r\n\tpublic getDiffuseHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getDiffuseFactor());\r\n\t}\r\n\r\n\t/** Diffuse; sRGB hexadecimal color. */\r\n\tpublic setDiffuseHex(hex: number): this {\r\n\t\tconst factor = this.getDiffuseFactor().slice() as vec4;\r\n\t\treturn this.setDiffuseFactor(ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\r\n\t * spec/gloss PBR workflow.\r\n\t */\r\n\tpublic getDiffuseTexture(): Texture | null {\r\n\t\treturn this.getRef('diffuseTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets diffuse texture. See {@link getDiffuseTexture}. */\r\n\tpublic setDiffuseTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular.\r\n\t */\r\n\r\n\t/** Specular; linear multiplier. */\r\n\tpublic getSpecularFactor(): vec3 {\r\n\t\treturn this.get('specularFactor');\r\n\t}\r\n\r\n\t/** Specular; linear multiplier. */\r\n\tpublic setSpecularFactor(factor: vec3): this {\r\n\t\treturn this.set('specularFactor', factor);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Glossiness.\r\n\t */\r\n\r\n\t/** Glossiness; linear multiplier. */\r\n\tpublic getGlossinessFactor(): number {\r\n\t\treturn this.get('glossinessFactor');\r\n\t}\r\n\r\n\t/** Glossiness; linear multiplier. */\r\n\tpublic setGlossinessFactor(factor: number): this {\r\n\t\treturn this.set('glossinessFactor', factor);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular/Glossiness.\r\n\t */\r\n\r\n\t/** Spec/gloss texture; linear multiplier. */\r\n\tpublic getSpecularGlossinessTexture(): Texture | null {\r\n\t\treturn this.getRef('specularGlossinessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Spec/gloss texture; linear multiplier. */\r\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\r\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness';\r\n\r\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\r\ninterface SpecularGlossinessDef {\r\n\tdiffuseFactor?: vec4;\r\n\tspecularFactor: vec3;\r\n\tglossinessFactor: number;\r\n\tdiffuseTexture?: GLTF.ITextureInfo;\r\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsPBRSpecularGlossiness\r\n *\r\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\r\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\r\n *\r\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\r\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\r\n * > {@link MaterialsSpecular} extension instead, which provides specular data within a metal/rough\r\n * > workflow._\r\n *\r\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\r\n *\r\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\r\n *\r\n * Properties:\r\n * - {@link PBRSpecularGlossiness}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const specGlossExtension = document.createExtension(MaterialsPBRSpecularGlossiness);\r\n *\r\n * // Create a PBRSpecularGlossiness property.\r\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\r\n * \t.setSpecularFactor(1.0);\r\n *\r\n * // // Assign to a Material.\r\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\r\n * ```\r\n */\r\nexport class MaterialsPBRSpecularGlossiness extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\r\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\r\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\r\n\r\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\r\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\r\n\t\t\t\tif (specGloss) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\r\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\r\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\r\n\t\t\t\t\t} as SpecularGlossinessDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\r\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\r\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\r\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\r\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SHEEN } from '../constants';\r\n\r\ninterface ISheen extends IProperty {\r\n\tsheenColorFactor: vec3;\r\n\tsheenColorTexture: Texture;\r\n\tsheenColorTextureInfo: TextureInfo;\r\n\tsheenRoughnessFactor: number;\r\n\tsheenRoughnessTexture: Texture;\r\n\tsheenRoughnessTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # Sheen\r\n *\r\n * Defines sheen on a PBR {@link Material}. See {@link MaterialsSheen}.\r\n */\r\nexport class Sheen extends ExtensionProperty<ISheen> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\r\n\tpublic declare propertyType: 'Sheen';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\r\n\t\tthis.propertyType = 'Sheen';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ISheen> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\r\n\t\t\tsheenColorTexture: null,\r\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\r\n\t\t\tsheenRoughnessFactor: 0.0,\r\n\t\t\tsheenRoughnessTexture: null,\r\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Sheen color.\r\n\t */\r\n\r\n\t/** Sheen; linear multiplier. */\r\n\tpublic getSheenColorFactor(): vec3 {\r\n\t\treturn this.get('sheenColorFactor');\r\n\t}\r\n\r\n\t/** Sheen; hex color in sRGB colorspace. */\r\n\tpublic getSheenColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getSheenColorFactor());\r\n\t}\r\n\r\n\t/** Sheen; linear multiplier. */\r\n\tpublic setSheenColorFactor(factor: vec3): this {\r\n\t\treturn this.set('sheenColorFactor', factor);\r\n\t}\r\n\r\n\t/** Sheen; hex color in sRGB colorspace. */\r\n\tpublic setSheenColorHex(hex: number): this {\r\n\t\tconst factor = this.getSheenColorFactor().slice() as vec3;\r\n\t\treturn this.set('sheenColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Sheen color texture, in sRGB colorspace.\r\n\t */\r\n\tpublic getSheenColorTexture(): Texture | null {\r\n\t\treturn this.getRef('sheenColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets sheen color texture. See {@link getSheenColorTexture}. */\r\n\tpublic setSheenColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Sheen roughness.\r\n\t */\r\n\r\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\r\n\tpublic getSheenRoughnessFactor(): number {\r\n\t\treturn this.get('sheenRoughnessFactor');\r\n\t}\r\n\r\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\r\n\tpublic setSheenRoughnessFactor(factor: number): this {\r\n\t\treturn this.set('sheenRoughnessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic getSheenRoughnessTexture(): Texture | null {\r\n\t\treturn this.getRef('sheenRoughnessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\r\n\t * roughness, independent of the base layer's roughness.\r\n\t */\r\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SHEEN } from '../constants';\r\nimport { Sheen } from './sheen';\r\n\r\nconst NAME = KHR_MATERIALS_SHEEN;\r\n\r\ninterface SheenDef {\r\n\tsheenColorFactor?: vec3;\r\n\tsheenRoughnessFactor?: number;\r\n\tsheenColorTexture?: GLTF.ITextureInfo;\r\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsSheen\r\n *\r\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\r\n * defines a velvet-like sheen layered on a glTF PBR material.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\r\n *\r\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\r\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\r\n * > Group._\r\n *\r\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\r\n * cloth and fabric materials.\r\n *\r\n * Properties:\r\n * - {@link Sheen}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsSheen, Sheen } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const sheenExtension = document.createExtension(MaterialsSheen);\r\n *\r\n * // Create a Sheen property.\r\n * const sheen = sheenExtension.createSheen()\r\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_sheen', sheen);\r\n * ```\r\n */\r\nexport class MaterialsSheen extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Sheen property for use on a {@link Material}. */\r\n\tpublic createSheen(): Sheen {\r\n\t\treturn new Sheen(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst sheen = this.createSheen();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\r\n\r\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\r\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\r\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\r\n\t\t\t\tif (sheen) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\r\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\r\n\t\t\t\t\t} as SheenDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\r\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\r\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\r\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\r\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\r\n\r\ninterface ISpecular extends IProperty {\r\n\tspecularFactor: number;\r\n\tspecularTexture: Texture;\r\n\tspecularTextureInfo: TextureInfo;\r\n\tspecularColorFactor: vec3;\r\n\tspecularColorTexture: Texture;\r\n\tspecularColorTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # Specular\r\n *\r\n * Defines specular reflectivity on a PBR {@link Material}. See {@link MaterialsSpecular}.\r\n */\r\nexport class Specular extends ExtensionProperty<ISpecular> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\r\n\tpublic declare propertyType: 'Specular';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\r\n\t\tthis.propertyType = 'Specular';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ISpecular> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tspecularFactor: 1.0,\r\n\t\t\tspecularTexture: null,\r\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\r\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\tspecularColorTexture: null,\r\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Specular.\r\n\t */\r\n\r\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\r\n\tpublic getSpecularFactor(): number {\r\n\t\treturn this.get('specularFactor');\r\n\t}\r\n\r\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularFactor(factor: number): this {\r\n\t\treturn this.set('specularFactor', factor);\r\n\t}\r\n\r\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\r\n\tpublic getSpecularColorFactor(): vec3 {\r\n\t\treturn this.get('specularColorFactor');\r\n\t}\r\n\r\n\t/** Specular color; Linear-sRGB components. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularColorFactor(factor: vec3): this {\r\n\t\treturn this.set('specularColorFactor', factor);\r\n\t}\r\n\r\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\r\n\tpublic getSpecularColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getSpecularColorFactor());\r\n\t}\r\n\r\n\t/** Specular color; sRGB hexadecimal color. See {@link getSpecularTexture} */\r\n\tpublic setSpecularColorHex(hex: number): this {\r\n\t\tconst factor = this.getSpecularColorFactor().slice() as vec3;\r\n\t\treturn this.set('specularColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\r\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\r\n\t * diffuse material.\r\n\t *\r\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\r\n\t * be packed with specular color (RGB) into a single texture.\r\n\t */\r\n\tpublic getSpecularTexture(): Texture | null {\r\n\t\treturn this.getRef('specularTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets specular texture. See {@link getSpecularTexture}. */\r\n\tpublic setSpecularTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\r\n\t}\r\n\r\n\t/**\r\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\r\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\r\n\t *\r\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\r\n\t * factor (A) into a single texture.\r\n\t */\r\n\tpublic getSpecularColorTexture(): Texture | null {\r\n\t\treturn this.getRef('specularColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its specular color texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets specular color texture. See {@link getSpecularColorTexture}. */\r\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\r\nimport { Specular } from './specular';\r\n\r\nconst NAME = KHR_MATERIALS_SPECULAR;\r\n\r\ninterface SpecularDef {\r\n\tspecularFactor?: number;\r\n\tspecularColorFactor?: vec3;\r\n\tspecularTexture?: GLTF.ITextureInfo;\r\n\tspecularColorTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsSpecular\r\n *\r\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)\r\n * adjusts the strength of the specular reflection in the dielectric BRDF.\r\n *\r\n * MaterialsSpecular is a better alternative to the older\r\n * {@link MaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\r\n * provides specular information while remaining within a metal/rough PBR workflow. A\r\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\r\n *\r\n * Properties:\r\n * - {@link Specular}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\r\n * which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsSpecular, Specular } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const specularExtension = document.createExtension(MaterialsSpecular);\r\n *\r\n * // Create a Specular property.\r\n * const specular = specularExtension.createSpecular()\r\n * \t.setSpecularFactor(1.0);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_specular', specular);\r\n * ```\r\n */\r\nexport class MaterialsSpecular extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Specular property for use on a {@link Material}. */\r\n\tpublic createSpecular(): Specular {\r\n\t\treturn new Specular(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst specular = this.createSpecular();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\r\n\r\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\r\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\r\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecular.setSpecularTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\r\n\t\t\t\tif (specular) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\r\n\r\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\r\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\r\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (specular.getSpecularTexture()) {\r\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\r\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\r\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\r\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSLUCENCY } from '../constants';\r\n\r\ninterface ITranslucency extends IProperty {\r\n\ttranslucencyFactor: number;\r\n\ttranslucencyTexture: Texture;\r\n\ttranslucencyTextureInfo: TextureInfo;\r\n\ttranslucencyColorFactor: vec3;\r\n\ttranslucencyColorTexture: Texture;\r\n\ttranslucencyColorTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R, G, B, A } = TextureChannel;\r\n\r\n/**\r\n * # translucency\r\n *\r\n * Defines translucency reflectivity on a PBR {@link Material}. See {@link Materialstranslucency}.\r\n */\r\nexport class Translucency extends ExtensionProperty<ITranslucency> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSLUCENCY;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSLUCENCY;\r\n\tpublic declare propertyType: 'Translucency';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_TRANSLUCENCY;\r\n\t\tthis.propertyType = 'Translucency';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITranslucency> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\ttranslucencyFactor: 1.0,\r\n\t\t\ttranslucencyTexture: null,\r\n\t\t\ttranslucencyTextureInfo: new TextureInfo(this.graph, 'translucencyTextureInfo'),\r\n\t\t\ttranslucencyColorFactor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t\ttranslucencyColorTexture: null,\r\n\t\t\ttranslucencyColorTextureInfo: new TextureInfo(this.graph, 'translucencyColorTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * translucency.\r\n\t */\r\n\r\n\t/** translucency; linear multiplier. See {@link getTranslucencyTexture}. */\r\n\tpublic getTranslucencyFactor(): number {\r\n\t\treturn this.get('translucencyFactor');\r\n\t}\r\n\r\n\t/** translucency; linear multiplier. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyFactor(factor: number): this {\r\n\t\treturn this.set('translucencyFactor', factor);\r\n\t}\r\n\r\n\t/** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */\r\n\tpublic getTranslucencyColorFactor(): vec3 {\r\n\t\treturn this.get('translucencyColorFactor');\r\n\t}\r\n\r\n\t/** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyColorFactor(factor: vec3): this {\r\n\t\treturn this.set('translucencyColorFactor', factor);\r\n\t}\r\n\r\n\t/** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */\r\n\tpublic getTranslucencyColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getTranslucencyColorFactor());\r\n\t}\r\n\r\n\t/** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */\r\n\tpublic setTranslucencyColorHex(hex: number): this {\r\n\t\tconst factor = this.getTranslucencyColorFactor().slice() as vec3;\r\n\t\treturn this.set('translucencyColorFactor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n\r\n\t/**\r\n\t * translucency texture; linear multiplier. Configures the strength of the translucency reflection in\r\n\t * the dielectric BRDF. A value of zero disables the translucency reflection, resulting in a pure\r\n\t * diffuse material.\r\n\t *\r\n\t * Only the alpha (A) channel is used for translucency strength, but this texture may optionally\r\n\t * be packed with translucency color (RGB) into a single texture.\r\n\t */\r\n\tpublic getTranslucencyTexture(): Texture | null {\r\n\t\treturn this.getRef('translucencyTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its translucency texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTranslucencyTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('translucencyTexture') ? this.getRef('translucencyTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets translucency texture. See {@link getTranslucencyTexture}. */\r\n\tpublic setTranslucencyTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('translucencyTexture', texture, { channels: A });\r\n\t}\r\n\r\n\t/**\r\n\t * translucency color texture; linear multiplier. Defines the F0 color of the translucency reflection\r\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\r\n\t *\r\n\t * Only RGB channels are used here, but this texture may optionally be packed with a translucency\r\n\t * factor (A) into a single texture.\r\n\t */\r\n\tpublic getTranslucencyColorTexture(): Texture | null {\r\n\t\treturn this.getRef('translucencyColorTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its translucency color texture. If no texture is\r\n\t * attached, {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTranslucencyColorTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('translucencyColorTexture') ? this.getRef('translucencyColorTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets translucency color texture. See {@link getTranslucencyColorTexture}. */\r\n\tpublic setTranslucencyColorTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('translucencyColorTexture', texture, { channels: R | G | B });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSLUCENCY } from '../constants';\r\nimport { Translucency } from './translucency';\r\n\r\nconst NAME = KHR_MATERIALS_TRANSLUCENCY;\r\n\r\ninterface TranslucencyDef {\r\n\ttranslucencyFactor?: number;\r\n\ttranslucencyColorFactor?: vec3;\r\n\ttranslucencyTexture?: GLTF.ITextureInfo;\r\n\ttranslucencyColorTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsTranslucency\r\n */\r\nexport class MaterialsTranslucency extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Translucency property for use on a {@link Material}. */\r\n\tpublic createTranslucency(): Translucency {\r\n\t\treturn new Translucency(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst translucency = this.createTranslucency();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, translucency);\r\n\r\n\t\t\t\tconst translucencyDef = materialDef.extensions[NAME] as TranslucencyDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (translucencyDef.translucencyFactor !== undefined) {\r\n\t\t\t\t\ttranslucency.setTranslucencyFactor(translucencyDef.translucencyFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (translucencyDef.translucencyColorFactor !== undefined) {\r\n\t\t\t\t\ttranslucency.setTranslucencyColorFactor(translucencyDef.translucencyColorFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (translucencyDef.translucencyTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = translucencyDef.translucencyTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttranslucency.setTranslucencyTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(translucency.getTranslucencyTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t\tif (translucencyDef.translucencyColorTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = translucencyDef.translucencyColorTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttranslucency.setTranslucencyColorTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(translucency.getTranslucencyColorTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst translucency = material.getExtension<Translucency>(NAME);\r\n\t\t\t\tif (translucency) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst translucencyDef = (materialDef.extensions[NAME] = {} as TranslucencyDef);\r\n\r\n\t\t\t\t\tif (translucency.getTranslucencyFactor() !== 1) {\r\n\t\t\t\t\t\ttranslucencyDef.translucencyFactor = translucency.getTranslucencyFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(translucency.getTranslucencyColorFactor(), [1, 1, 1])) {\r\n\t\t\t\t\t\ttranslucencyDef.translucencyColorFactor = translucency.getTranslucencyColorFactor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (translucency.getTranslucencyTexture()) {\r\n\t\t\t\t\t\tconst texture = translucency.getTranslucencyTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = translucency.getTranslucencyTextureInfo()!;\r\n\t\t\t\t\t\ttranslucencyDef.translucencyTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (translucency.getTranslucencyColorTexture()) {\r\n\t\t\t\t\t\tconst texture = translucency.getTranslucencyColorTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = translucency.getTranslucencyColorTextureInfo()!;\r\n\t\t\t\t\t\ttranslucencyDef.translucencyColorTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\r\n\r\ninterface ITransmission extends IProperty {\r\n\ttransmissionFactor: number;\r\n\ttransmissionTexture: Texture;\r\n\ttransmissionTextureInfo: TextureInfo;\r\n}\r\n\r\nconst { R } = TextureChannel;\r\n\r\n/**\r\n * # Transmission\r\n *\r\n * Defines optical transmission on a PBR {@link Material}. See {@link MaterialsTransmission}.\r\n */\r\nexport class Transmission extends ExtensionProperty<ITransmission> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\r\n\tpublic declare propertyType: 'Transmission';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\r\n\t\tthis.propertyType = 'Transmission';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITransmission> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\ttransmissionFactor: 0.0,\r\n\t\t\ttransmissionTexture: null,\r\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Transmission.\r\n\t */\r\n\r\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\r\n\tpublic getTransmissionFactor(): number {\r\n\t\treturn this.get('transmissionFactor');\r\n\t}\r\n\r\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\r\n\tpublic setTransmissionFactor(factor: number): this {\r\n\t\treturn this.set('transmissionFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\r\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\r\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\r\n\t * addition of the `KHR_materials_volume` extension.\r\n\t */\r\n\tpublic getTransmissionTexture(): Texture | null {\r\n\t\treturn this.getRef('transmissionTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\r\n\t}\r\n\r\n\t/** Sets transmission texture. See {@link getTransmissionTexture}. */\r\n\tpublic setTransmissionTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\r\nimport { Transmission } from './transmission';\r\n\r\nconst NAME = KHR_MATERIALS_TRANSMISSION;\r\n\r\ninterface TransmissionDef {\r\n\ttransmissionFactor?: number;\r\n\ttransmissionTexture?: GLTF.ITextureInfo;\r\n}\r\n\r\n/**\r\n * # MaterialsTransmission\r\n *\r\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)\r\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\r\n * scattering, or dispersion.\r\n *\r\n * While default PBR materials using alpha blending become invisible as their opacity approaches\r\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\r\n * transmission values. When combined with {@link MaterialsVolume}, transmission may be used for\r\n * thicker materials and refractive effects.\r\n *\r\n * Properties:\r\n * - {@link Transmission}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsTransmission` class provides a single {@link ExtensionProperty} type,\r\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsTransmission, Transmission } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const transmissionExtension = document.createExtension(MaterialsTransmission);\r\n *\r\n * // Create a Transmission property.\r\n * const transmission = transmissionExtension.createTransmission()\r\n * \t.setTransmissionFactor(1.0);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_transmission', transmission);\r\n * ```\r\n */\r\nexport class MaterialsTransmission extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Transmission property for use on a {@link Material}. */\r\n\tpublic createTransmission(): Transmission {\r\n\t\treturn new Transmission(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst transmission = this.createTransmission();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\r\n\r\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\r\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\r\n\t\t\t\tif (transmission) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\r\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\r\n\t\t\t\t\t} as TransmissionDef);\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\r\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\r\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty } from '@gltf-transform/core';\r\nimport { PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_UNLIT } from '../constants';\r\n\r\n/**\r\n * # Unlit\r\n *\r\n * Converts a PBR {@link Material} to an unlit shading model. See {@link MaterialsUnlit}.\r\n */\r\nexport class Unlit extends ExtensionProperty {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\r\n\tpublic declare propertyType: 'Unlit';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\r\n\t\tthis.propertyType = 'Unlit';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_UNLIT } from '../constants';\r\nimport { Unlit } from './unlit';\r\n\r\nconst NAME = KHR_MATERIALS_UNLIT;\r\n\r\n/**\r\n * # MaterialsUnlit\r\n *\r\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)\r\n * defines an unlit shading model for use in glTF 2.0 materials.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\r\n *\r\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\r\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\r\n *\r\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\r\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\r\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\r\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\r\n * effects like hand painted illustrative styles or baked toon shaders.\r\n *\r\n * Properties:\r\n * - {@link Unlit}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\r\n * be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsUnlit, Unlit } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const unlitExtension = document.createExtension(MaterialsUnlit);\r\n *\r\n * // Create an Unlit property.\r\n * const unlit = unlitExtension.createUnlit();\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_unlit', unlit);\r\n * ```\r\n */\r\nexport class MaterialsUnlit extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Unlit property for use on a {@link Material}. */\r\n\tpublic createUnlit(): Unlit {\r\n\t\treturn new Unlit(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Material, Nullable } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport type { Variant } from './variant';\r\n\r\ninterface IMapping extends IProperty {\r\n\tmaterial: Material;\r\n\tvariants: Variant[];\r\n}\r\n\r\n/**\r\n * # Mapping\r\n *\r\n * Maps {@link Variant}s to {@link Material}s. See {@link MaterialsVariants}.\r\n */\r\nexport class Mapping extends ExtensionProperty<IMapping> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'Mapping';\r\n\tpublic declare parentTypes: ['MappingList'];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'Mapping';\r\n\t\tthis.parentTypes = ['MappingList'];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IMapping> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: [] });\r\n\t}\r\n\r\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\r\n\tpublic getMaterial(): Material | null {\r\n\t\treturn this.getRef('material');\r\n\t}\r\n\r\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\r\n\tpublic setMaterial(material: Material | null): this {\r\n\t\treturn this.setRef('material', material);\r\n\t}\r\n\r\n\t/** Adds a {@link Variant} to this mapping. */\r\n\tpublic addVariant(variant: Variant): this {\r\n\t\treturn this.addRef('variants', variant);\r\n\t}\r\n\r\n\t/** Removes a {@link Variant} from this mapping. */\r\n\tpublic removeVariant(variant: Variant): this {\r\n\t\treturn this.removeRef('variants', variant);\r\n\t}\r\n\r\n\t/** Lists {@link Variant}s in this mapping. */\r\n\tpublic listVariants(): Variant[] {\r\n\t\treturn this.listRefs('variants');\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport type { Mapping } from './mapping';\r\n\r\ninterface IMappingList extends IProperty {\r\n\tmappings: Mapping[];\r\n}\r\n\r\n/**\r\n * # MappingList\r\n *\r\n * List of material variant {@link Mapping}s. See {@link MaterialsVariants}.\r\n */\r\nexport class MappingList extends ExtensionProperty<IMappingList> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'MappingList';\r\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'MappingList';\r\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IMappingList> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: [] });\r\n\t}\r\n\r\n\t/** Adds a {@link Mapping} to this mapping. */\r\n\tpublic addMapping(mapping: Mapping): this {\r\n\t\treturn this.addRef('mappings', mapping);\r\n\t}\r\n\r\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\r\n\tpublic removeMapping(mapping: Mapping): this {\r\n\t\treturn this.removeRef('mappings', mapping);\r\n\t}\r\n\r\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\r\n\tpublic listMappings(): Mapping[] {\r\n\t\treturn this.listRefs('mappings');\r\n\t}\r\n}\r\n","import { ExtensionProperty } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\n\r\n/**\r\n * # Variant\r\n *\r\n * Defines a variant of a {@link Material}. See {@link MaterialsVariants}.\r\n */\r\nexport class Variant extends ExtensionProperty {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\r\n\tpublic declare propertyType: 'Variant';\r\n\tpublic declare parentTypes: ['MappingList'];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\r\n\t\tthis.propertyType = 'Variant';\r\n\t\tthis.parentTypes = ['MappingList'];\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\r\nimport { Mapping } from './mapping';\r\nimport { MappingList } from './mapping-list';\r\nimport { Variant } from './variant';\r\n\r\nconst NAME = KHR_MATERIALS_VARIANTS;\r\n\r\ninterface VariantsRootDef {\r\n\tvariants: VariantDef[];\r\n}\r\n\r\ninterface VariantDef {\r\n\tname?: string;\r\n}\r\n\r\ninterface VariantPrimDef {\r\n\tmappings: VariantMappingDef[];\r\n}\r\n\r\ninterface VariantMappingDef {\r\n\tmaterial: number;\r\n\tvariants: number[];\r\n}\r\n\r\n/**\r\n * # MaterialsVariants\r\n *\r\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\r\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-variants.png)\r\n *\r\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\r\n *\r\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\r\n * `MaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\r\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\r\n * defining the variants available to an application. Triggering a variant is out of scope of this\r\n * extension, but could be handled in the application with a UI dropdown, particular game states,\r\n * and so on.\r\n *\r\n * Mesh geometry cannot be changed by this extension, although another extension\r\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\r\n *\r\n * Properties:\r\n * - {@link Variant}\r\n * - {@link Mapping}\r\n * - {@link MappingList}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MaterialsVariants } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const variantExtension = document.createExtension(MaterialsVariants);\r\n *\r\n * // Create some Variant states.\r\n * const healthyVariant = variantExtension.createVariant('Healthy');\r\n * const damagedVariant = variantExtension.createVariant('Damaged');\r\n *\r\n * // Create mappings from a Variant state to a Material.\r\n * const healthyMapping = variantExtension.createMapping()\r\n * \t.addVariant(healthyVariant)\r\n * \t.setMaterial(healthyMat);\r\n * const damagedMapping = variantExtension.createMapping()\r\n * \t.addVariant(damagedVariant)\r\n * \t.setMaterial(damagedMat);\r\n *\r\n * // Attach the mappings to a Primitive.\r\n * primitive.setExtension(\r\n * \t'KHR_materials_variants',\r\n * \tvariantExtension.createMappingList()\r\n * \t\t.addMapping(healthyMapping)\r\n * \t\t.addMapping(damagedMapping)\r\n * );\r\n * ```\r\n *\r\n * A few notes about this extension:\r\n *\r\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\r\n * \t instead, so assign that material accordingly. This material can be  but doesn't have to be \r\n * \t associated with one of the available variants.\r\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\r\n * \t Variant will be chosen by the viewer.\r\n * 3. Variant names are how these states are identified, so choose informative names.\r\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\r\n * \t the option of downloading only textures associated with the default state, and lazy-loading\r\n * \t any textures for inactive Variants only when they are needed.\r\n */\r\nexport class MaterialsVariants extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new MappingList property. */\r\n\tpublic createMappingList(): MappingList {\r\n\t\treturn new MappingList(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Creates a new Variant property. */\r\n\tpublic createVariant(name = ''): Variant {\r\n\t\treturn new Variant(this.document.getGraph(), name);\r\n\t}\r\n\r\n\t/** Creates a new Mapping property. */\r\n\tpublic createMapping(): Mapping {\r\n\t\treturn new Mapping(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Lists all Variants on the current Document. */\r\n\tpublic listVariants(): Variant[] {\r\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\r\n\r\n\t\t// Read all top-level variant names.\r\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\r\n\t\tconst variantDefs = variantsRootDef.variants || [];\r\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\r\n\r\n\t\t// For each mesh primitive, read its material/variant mappings.\r\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\r\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\r\n\t\t\tconst mesh = context.meshes[meshIndex];\r\n\t\t\tconst primDefs = meshDef.primitives || [];\r\n\r\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\r\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst mappingList = this.createMappingList();\r\n\r\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\r\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\r\n\t\t\t\t\tconst mapping = this.createMapping();\r\n\r\n\t\t\t\t\tif (mappingDef.material !== undefined) {\r\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\r\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmappingList.addMapping(mapping);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tconst variants = this.listVariants();\r\n\t\tif (!variants.length) return this;\r\n\r\n\t\t// Write all top-level variant names.\r\n\t\tconst variantDefs = [];\r\n\t\tconst variantIndexMap = new Map<Variant, number>();\r\n\t\tfor (const variant of variants) {\r\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\r\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\r\n\t\t}\r\n\r\n\t\t// For each mesh primitive, write its material/variant mappings.\r\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\r\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\r\n\r\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\r\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\r\n\t\t\t\tif (!mappingList) return;\r\n\r\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\r\n\r\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\r\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\r\n\r\n\t\t\t\t\tconst material = mapping.getMaterial();\r\n\t\t\t\t\tif (material) {\r\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\r\n\r\n\t\t\t\t\treturn mappingDef;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\r\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\r\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import {\r\n\tColorUtils,\r\n\tExtensionProperty,\r\n\tIProperty,\r\n\tNullable,\r\n\tPropertyType,\r\n\tTexture,\r\n\tTextureChannel,\r\n\tTextureInfo,\r\n\tvec3,\r\n} from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VOLUME } from '../constants';\r\n\r\ninterface IVolume extends IProperty {\r\n\tthicknessFactor: number;\r\n\tthicknessTexture: Texture;\r\n\tthicknessTextureInfo: TextureInfo;\r\n\tattenuationDistance: number;\r\n\tattenuationColor: vec3;\r\n}\r\n\r\nconst { G } = TextureChannel;\r\n\r\n/**\r\n * # Volume\r\n *\r\n * Defines volume on a PBR {@link Material}. See {@link MaterialsVolume}.\r\n */\r\nexport class Volume extends ExtensionProperty<IVolume> {\r\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\r\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\r\n\tpublic declare propertyType: 'Volume';\r\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\r\n\t\tthis.propertyType = 'Volume';\r\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IVolume> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\tthicknessFactor: 0.0,\r\n\t\t\tthicknessTexture: null,\r\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\r\n\t\t\tattenuationDistance: Infinity,\r\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\r\n\t\t});\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Thickness.\r\n\t */\r\n\r\n\t/**\r\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\r\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\r\n\t * boundary. The doubleSided property has no effect on volume boundaries.\r\n\t */\r\n\tpublic getThicknessFactor(): number {\r\n\t\treturn this.get('thicknessFactor');\r\n\t}\r\n\r\n\t/**\r\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\r\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\r\n\t * boundary. The doubleSided property has no effect on volume boundaries.\r\n\t */\r\n\tpublic setThicknessFactor(factor: number): this {\r\n\t\treturn this.set('thicknessFactor', factor);\r\n\t}\r\n\r\n\t/**\r\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\r\n\t * thicknessFactor.\r\n\t */\r\n\tpublic getThicknessTexture(): Texture | null {\r\n\t\treturn this.getRef('thicknessTexture');\r\n\t}\r\n\r\n\t/**\r\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\r\n\t * {@link TextureInfo} is `null`.\r\n\t */\r\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\r\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\r\n\t * thicknessFactor.\r\n\t */\r\n\tpublic setThicknessTexture(texture: Texture | null): this {\r\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Attenuation.\r\n\t */\r\n\r\n\t/**\r\n\t * Density of the medium given as the average distance in meters that light travels in the\r\n\t * medium before interacting with a particle.\r\n\t */\r\n\tpublic getAttenuationDistance(): number {\r\n\t\treturn this.get('attenuationDistance');\r\n\t}\r\n\r\n\t/**\r\n\t * Density of the medium given as the average distance in meters that light travels in the\r\n\t * medium before interacting with a particle.\r\n\t */\r\n\tpublic setAttenuationDistance(distance: number): this {\r\n\t\treturn this.set('attenuationDistance', distance);\r\n\t}\r\n\r\n\t/**\r\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic getAttenuationColor(): vec3 {\r\n\t\treturn this.get('attenuationColor');\r\n\t}\r\n\r\n\t/**\r\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic setAttenuationColor(color: vec3): this {\r\n\t\treturn this.set('attenuationColor', color);\r\n\t}\r\n\r\n\t/**\r\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic getAttenuationColorHex(): number {\r\n\t\treturn ColorUtils.factorToHex(this.getAttenuationColor());\r\n\t}\r\n\r\n\t/**\r\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\r\n\t * distance.\r\n\t */\r\n\tpublic setAttenuationColorHex(hex: number): this {\r\n\t\tconst factor = this.getAttenuationColor().slice() as vec3;\r\n\t\treturn this.set('attenuationColor', ColorUtils.hexToFactor(hex, factor));\r\n\t}\r\n}\r\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\r\nimport { KHR_MATERIALS_VOLUME } from '../constants';\r\nimport { Volume } from './volume';\r\n\r\nconst NAME = KHR_MATERIALS_VOLUME;\r\n\r\ninterface VolumeDef {\r\n\tthicknessFactor?: number;\r\n\tthicknessTexture?: GLTF.ITextureInfo;\r\n\tattenuationDistance?: number;\r\n\tattenuationColor?: vec3;\r\n}\r\n\r\n/**\r\n * # MaterialsVolume\r\n *\r\n * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)\r\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\r\n * translucency.\r\n *\r\n * ![Illustration](/media/extensions/khr-materials-volume.png)\r\n *\r\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\r\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\r\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\r\n * > volume (right). The overall color depends on the distance the light traveled through it; at\r\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\r\n * > large distances. Source: Khronos Group._\r\n *\r\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\r\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\r\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\r\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\r\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\r\n * effects will require future (TBD) extensions.\r\n *\r\n * The volume extension must be combined with {@link MaterialsTransmission} or\r\n * `KHR_materials_translucency` in order to define entry of light into the volume.\r\n *\r\n * Properties:\r\n * - {@link Volume}\r\n *\r\n * ### Example\r\n *\r\n * The `MaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\r\n * may be attached to any {@link Material} instance. For example:\r\n *\r\n * ```typescript\r\n * import { MaterialsVolume, Volume } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const volumeExtension = document.createExtension(MaterialsVolume);\r\n *\r\n * // Create a Volume property.\r\n * const volume = volumeExtension.createVolume()\r\n * \t.setThicknessFactor(1.0)\r\n * \t.setThicknessTexture(texture)\r\n * \t.setAttenuationDistance(1.0)\r\n * \t.setAttenuationColorHex(0xFFEEEE);\r\n *\r\n * // Attach the property to a Material.\r\n * material.setExtension('KHR_materials_volume', volume);\r\n * ```\r\n *\r\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\r\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\r\n */\r\nexport class MaterialsVolume extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Volume property for use on a {@link Material}. */\r\n\tpublic createVolume(): Volume {\r\n\t\treturn new Volume(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\t\tconst materialDefs = jsonDoc.json.materials || [];\r\n\t\tconst textureDefs = jsonDoc.json.textures || [];\r\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\r\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\r\n\t\t\t\tconst volume = this.createVolume();\r\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\r\n\r\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\r\n\r\n\t\t\t\t// Factors.\r\n\r\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\r\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\r\n\t\t\t\t}\r\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\r\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\r\n\t\t\t\t}\r\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\r\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Textures.\r\n\r\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\r\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\r\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\r\n\t\t\t\t\tvolume.setThicknessTexture(texture);\r\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listMaterials()\r\n\t\t\t.forEach((material) => {\r\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\r\n\t\t\t\tif (volume) {\r\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\r\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\r\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\r\n\t\t\t\t\t// Factors.\r\n\r\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\r\n\r\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\r\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\r\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\r\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Textures.\r\n\r\n\t\t\t\t\tif (volume.getThicknessTexture()) {\r\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\r\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\r\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\r\nimport { KHR_MESH_QUANTIZATION } from '../constants';\r\n\r\nconst NAME = KHR_MESH_QUANTIZATION;\r\n\r\n/**\r\n * # MeshQuantization\r\n *\r\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)\r\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\r\n *\r\n * Quantization provides a memory/precision tradeoff  depending on the application needs, 16-bit or\r\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\r\n * mesh might be written to a uint16 {@link Accessor}, with values `065536`, normalized to be\r\n * interpreted as `01`. With an additional 10x scale on any node {@link Node} instantiating the\r\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\r\n * up to 50% file size reduction.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing more flexible use of\r\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\r\n * types would yield an invalid glTF document, under the stricter core glTF specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { MeshQuantization } from '@gltf-transform/extensions';\r\n * import { quantize } from '@gltf-transform/functions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const quantizationExtension = document.createExtension(MeshQuantization).setRequired(true);\r\n *\r\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\r\n * // or apply the provided quantize() function to compute quantized accessors automatically:\r\n * await document.transform(quantize({\r\n * \tquantizePosition: 16,\r\n * \tquantizeNormal: 12,\r\n * \tquantizeTexcoord: 14\r\n * }));\r\n * ```\r\n *\r\n * For more documentation about automatic quantization, see the {@link quantize} function.\r\n */\r\nexport class MeshQuantization extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tread(_: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\twrite(_: WriterContext): this {\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { KTX2Model, read as readKTX } from 'ktx-parse';\r\nimport {\r\n\tExtension,\r\n\tImageUtils,\r\n\tImageUtilsFormat,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tWriterContext,\r\n\tvec2,\r\n} from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_BASISU } from '../constants';\r\n\r\nconst NAME = KHR_TEXTURE_BASISU;\r\n\r\ninterface BasisuDef {\r\n\tsource: number;\r\n}\r\n\r\nclass KTX2ImageUtils implements ImageUtilsFormat {\r\n\tmatch(array: Uint8Array): boolean {\r\n\t\treturn (\r\n\t\t\tarray[0] === 0xab &&\r\n\t\t\tarray[1] === 0x4b &&\r\n\t\t\tarray[2] === 0x54 &&\r\n\t\t\tarray[3] === 0x58 &&\r\n\t\t\tarray[4] === 0x20 &&\r\n\t\t\tarray[5] === 0x32 &&\r\n\t\t\tarray[6] === 0x30 &&\r\n\t\t\tarray[7] === 0xbb &&\r\n\t\t\tarray[8] === 0x0d &&\r\n\t\t\tarray[9] === 0x0a &&\r\n\t\t\tarray[10] === 0x1a &&\r\n\t\t\tarray[11] === 0x0a\r\n\t\t);\r\n\t}\r\n\tgetSize(array: Uint8Array): vec2 {\r\n\t\tconst container = readKTX(array);\r\n\t\treturn [container.pixelWidth, container.pixelHeight];\r\n\t}\r\n\tgetChannels(array: Uint8Array): number {\r\n\t\tconst container = readKTX(array);\r\n\t\tconst dfd = container.dataFormatDescriptor[0];\r\n\t\tif (dfd.colorModel === KTX2Model.ETC1S) {\r\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === 15 ? 4 : 3;\r\n\t\t} else if (dfd.colorModel === KTX2Model.UASTC) {\r\n\t\t\treturn (dfd.samples[0].channelID & 0xf) === 3 ? 4 : 3;\r\n\t\t}\r\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\r\n\t}\r\n\tgetGPUByteLength(array: Uint8Array): number {\r\n\t\tconst container = readKTX(array);\r\n\t\tconst hasAlpha = this.getChannels(array) > 3;\r\n\r\n\t\tlet uncompressedBytes = 0;\r\n\t\tfor (let i = 0; i < container.levels.length; i++) {\r\n\t\t\tconst level = container.levels[i];\r\n\r\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\r\n\t\t\tif (level.uncompressedByteLength) {\r\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\r\n\t\t\t} else {\r\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\r\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\r\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\r\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn uncompressedBytes;\r\n\t}\r\n}\r\n\r\n/**\r\n * # TextureBasisu\r\n *\r\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\r\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\r\n *\r\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\r\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\r\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\r\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\r\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\r\n * framerate while uploading images, or where GPU memory is limited.\r\n *\r\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\r\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\r\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\r\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\r\n * specification.\r\n *\r\n * Properties:\r\n * - N/A\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { TextureBasisu } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const basisuExtension = document.createExtension(TextureBasisu)\r\n * \t.setRequired(true);\r\n * document.createTexture('MyCompressedTexture')\r\n * \t.setMimeType('image/ktx2')\r\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\r\n * ```\r\n *\r\n * Compression is not done automatically when adding the extension as shown above  you must\r\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\r\n * [glTF-Transform CLI](/cli.html) has functions to help with this, or any similar KTX2-capable\r\n * utility will work.\r\n *\r\n * When the `KHR_texture_basisu` extension is added to a file by glTF-Transform, the extension\r\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\r\n * PNG or JPEG image data.\r\n *\r\n * > _**NOTICE:** Compressing some textures  particularly 3-component (RGB) normal maps, and\r\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\r\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\r\n * > texture before compressing it.\r\n * >\r\n * > For best results when authoring new textures, use\r\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\r\n * > prominent UV seams._\r\n */\r\nexport class TextureBasisu extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\t/** @hidden */\r\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** @hidden */\r\n\tpublic static register(): void {\r\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic preread(context: ReaderContext): this {\r\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\r\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\r\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\r\n\t\t\t\ttextureDef.source = basisuDef.source;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tpublic read(context: ReaderContext): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst jsonDoc = context.jsonDoc;\r\n\r\n\t\tthis.document\r\n\t\t\t.getRoot()\r\n\t\t\t.listTextures()\r\n\t\t\t.forEach((texture) => {\r\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\r\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\r\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\r\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\r\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\r\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\r\n\t\t\t\t\t\t\tdelete textureDef.source;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\r\nimport { PropertyType } from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\r\n\r\ninterface ITransform extends IProperty {\r\n\toffset: vec2;\r\n\trotation: number;\r\n\tscale: vec2;\r\n\ttexCoord: number | null; // null  do not override TextureInfo.\r\n}\r\n\r\n/**\r\n * # Transform\r\n *\r\n * Defines UV transform for a {@link TextureInfo}. See {@link TextureTransform}.\r\n */\r\nexport class Transform extends ExtensionProperty<ITransform> {\r\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\r\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\r\n\tpublic declare propertyType: 'Transform';\r\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\r\n\t\tthis.propertyType = 'Transform';\r\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<ITransform> {\r\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\r\n\t\t\toffset: [0.0, 0.0] as vec2,\r\n\t\t\trotation: 0,\r\n\t\t\tscale: [1.0, 1.0] as vec2,\r\n\t\t\ttexCoord: null,\r\n\t\t});\r\n\t}\r\n\r\n\tpublic getOffset(): vec2 {\r\n\t\treturn this.get('offset');\r\n\t}\r\n\tpublic setOffset(offset: vec2): this {\r\n\t\treturn this.set('offset', offset);\r\n\t}\r\n\r\n\tpublic getRotation(): number {\r\n\t\treturn this.get('rotation');\r\n\t}\r\n\tpublic setRotation(rotation: number): this {\r\n\t\treturn this.set('rotation', rotation);\r\n\t}\r\n\r\n\tpublic getScale(): vec2 {\r\n\t\treturn this.get('scale');\r\n\t}\r\n\tpublic setScale(scale: vec2): this {\r\n\t\treturn this.set('scale', scale);\r\n\t}\r\n\r\n\tpublic getTexCoord(): number | null {\r\n\t\treturn this.get('texCoord');\r\n\t}\r\n\tpublic setTexCoord(texCoord: number | null): this {\r\n\t\treturn this.set('texCoord', texCoord);\r\n\t}\r\n}\r\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\r\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\r\nimport { Transform } from './transform';\r\n\r\nconst NAME = KHR_TEXTURE_TRANSFORM;\r\n\r\ninterface TransformDef {\r\n\toffset?: vec2;\r\n\trotation?: number;\r\n\tscale?: vec2;\r\n\ttexCoord?: number;\r\n}\r\n\r\n/**\r\n * # TextureTransform\r\n *\r\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)\r\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\r\n *\r\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\r\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\r\n * this time.\r\n *\r\n * Properties:\r\n * - {@link Transform}\r\n *\r\n * ### Example\r\n *\r\n * The `TextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\r\n * may be attached to any {@link TextureInfo} instance. For example:\r\n *\r\n * ```typescript\r\n * import { TextureTransform } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const transformExtension = document.createExtension(TextureTransform)\r\n * \t.setRequired(true);\r\n *\r\n * // Create a reusable Transform.\r\n * const transform = transformExtension.createTransform()\r\n * \t.setScale([100, 100]);\r\n *\r\n * // Apply the Transform to a Material's baseColorTexture.\r\n * document.createMaterial()\r\n * \t.setBaseColorTexture(myTexture)\r\n * \t.getBaseColorTextureInfo()\r\n * \t.setExtension('KHR_texture_transform', transform);\r\n * ```\r\n */\r\nexport class TextureTransform extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\r\n\tpublic createTransform(): Transform {\r\n\t\treturn new Transform(this.document.getGraph());\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\r\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\r\n\r\n\t\t\tconst transform = this.createTransform();\r\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\r\n\r\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\r\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\r\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\r\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\r\n\r\n\t\t\ttextureInfo.setExtension(NAME, transform);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\r\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\r\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\r\n\t\t\tif (!transform) continue;\r\n\r\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\r\n\t\t\tconst transformDef = {} as TransformDef;\r\n\r\n\t\t\tconst eq = MathUtils.eq;\r\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\r\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\r\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\r\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\r\n\r\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Nullable, PropertyType, ExtensionProperty, IProperty } from '@gltf-transform/core';\r\nimport { KHR_XMP_JSON_LD } from '../constants';\r\n\r\ntype Term = string;\r\ntype TermDefinition = string | Record<string, string>;\r\n\r\ntype Value = string | number | boolean;\r\n\r\nconst PARENT_TYPES = [\r\n\tPropertyType.ROOT,\r\n\tPropertyType.SCENE,\r\n\tPropertyType.NODE,\r\n\tPropertyType.MESH,\r\n\tPropertyType.MATERIAL,\r\n\tPropertyType.TEXTURE,\r\n\tPropertyType.ANIMATION,\r\n];\r\n\r\ninterface IPacket extends IProperty {\r\n\t// https://json-ld.org/spec/latest/json-ld/#the-context\r\n\tcontext: Record<Term, TermDefinition>;\r\n\tproperties: Record<string, Value | Record<string, unknown>>;\r\n}\r\n\r\n/**\r\n * # Packet\r\n *\r\n * Defines an XMP packet associated with a Document or Property. See {@link XMP}.\r\n */\r\nexport class Packet extends ExtensionProperty<IPacket> {\r\n\tpublic declare propertyType: 'Packet';\r\n\tpublic declare parentTypes: typeof PARENT_TYPES;\r\n\tpublic declare extensionName: typeof KHR_XMP_JSON_LD;\r\n\tpublic static EXTENSION_NAME = KHR_XMP_JSON_LD;\r\n\r\n\tprotected init(): void {\r\n\t\tthis.extensionName = KHR_XMP_JSON_LD;\r\n\t\tthis.propertyType = 'Packet';\r\n\t\tthis.parentTypes = PARENT_TYPES;\r\n\t}\r\n\r\n\tprotected getDefaults(): Nullable<IPacket> {\r\n\t\treturn Object.assign(super.getDefaults(), { context: {}, properties: {} });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Context.\r\n\t */\r\n\r\n\t/**\r\n\t * Returns the XMP context definition URL for the given term.\r\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\r\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\r\n\t */\r\n\tpublic getContext(): Record<Term, TermDefinition> {\r\n\t\treturn this.get('context');\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the XMP context definition URL for the given term.\r\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.setContext({\r\n\t *   dc: 'http://purl.org/dc/elements/1.1/',\r\n\t *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\r\n\t * @param definition URI for XMP namespace.\r\n\t */\r\n\tpublic setContext(context: Record<Term, TermDefinition>): this {\r\n\t\treturn this.set('context', { ...context });\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Properties.\r\n\t */\r\n\r\n\t/**\r\n\t * Lists properties defined in this packet.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.listProperties(); //  ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\r\n\t * ```\r\n\t */\r\n\tpublic listProperties(): string[] {\r\n\t\treturn Object.keys(this.get('properties'));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of a property, as a literal or JSONLD object.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.getProperty('dc:Creator'); //  {\"@list\": [\"Acme, Inc.\"]}\r\n\t * packet.getProperty('dc:Title'); //  {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\r\n\t * packet.getProperty('xmp:CreateDate'); //  \"2022-01-01\"\r\n\t * ```\r\n\t */\r\n\tpublic getProperty(name: string): Value | Record<string, unknown> | null {\r\n\t\tconst properties = this.get('properties');\r\n\t\treturn name in properties ? properties[name] : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of a property, as a literal or JSONLD object.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * ```typescript\r\n\t * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\r\n\t * packet.setProperty('dc:Title', {\r\n\t * \t'@type': 'rdf:Alt',\r\n\t * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\r\n\t * });\r\n\t * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\r\n\t * ```\r\n\t */\r\n\tpublic setProperty(name: string, value: Value | Record<string, unknown>): this {\r\n\t\tthis._assertContext(name);\r\n\r\n\t\tconst properties = { ...this.get('properties') };\r\n\t\tif (value) {\r\n\t\t\tproperties[name] = value;\r\n\t\t} else {\r\n\t\t\tdelete properties[name];\r\n\t\t}\r\n\t\treturn this.set('properties', properties);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Serialize / Deserialize.\r\n\t */\r\n\r\n\t/**\r\n\t * Serializes the packet context and properties to a JSONLD object.\r\n\t */\r\n\tpublic toJSONLD(): Record<string, unknown> {\r\n\t\tconst context = copyJSON(this.get('context'));\r\n\t\tconst properties = copyJSON(this.get('properties'));\r\n\t\treturn { '@context': context, ...properties };\r\n\t}\r\n\r\n\t/**\r\n\t * Deserializes a JSONLD packet, then overwrites existing context and properties with\r\n\t * the new values.\r\n\t */\r\n\tpublic fromJSONLD(jsonld: Record<string, unknown>): this {\r\n\t\tjsonld = copyJSON(jsonld);\r\n\r\n\t\t// Context.\r\n\t\tconst context = jsonld['@context'] as Record<Term, TermDefinition>;\r\n\t\tif (context) this.set('context', context);\r\n\t\tdelete jsonld['@context'];\r\n\r\n\t\t// Properties.\r\n\t\treturn this.set('properties', jsonld as Record<string, string | Record<string, unknown>>);\r\n\t}\r\n\r\n\t/**********************************************************************************************\r\n\t * Validation.\r\n\t */\r\n\r\n\t/** @hidden */\r\n\tprivate _assertContext(name: string) {\r\n\t\tconst prefix = name.split(':')[0];\r\n\t\tif (!(prefix in this.get('context'))) {\r\n\t\t\tthrow new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction copyJSON<T>(object: T): T {\r\n\treturn JSON.parse(JSON.stringify(object));\r\n}\r\n","import {\r\n\tAnimation,\r\n\tExtension,\r\n\tGLTF,\r\n\tMaterial,\r\n\tMesh,\r\n\tNode,\r\n\tPropertyType,\r\n\tReaderContext,\r\n\tScene,\r\n\tTexture,\r\n\tWriterContext,\r\n} from '@gltf-transform/core';\r\nimport { KHR_XMP_JSON_LD } from '../constants';\r\nimport { Packet } from './packet';\r\n\r\nconst NAME = KHR_XMP_JSON_LD;\r\n\r\ntype XMPPacketDef = Record<string, unknown>;\r\n\r\ntype XMPParentDef =\r\n\t| GLTF.IAsset\r\n\t| GLTF.IScene\r\n\t| GLTF.INode\r\n\t| GLTF.IMesh\r\n\t| GLTF.IMaterial\r\n\t| GLTF.ITexture\r\n\t| GLTF.IAnimation;\r\n\r\ninterface XMPPropertyDef {\r\n\tpacket: number;\r\n}\r\n\r\ninterface XMPRootDef {\r\n\tpackets?: XMPPacketDef[];\r\n}\r\n\r\n/**\r\n * # XMP\r\n *\r\n * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)\r\n * defines XMP metadata associated with a glTF asset.\r\n *\r\n * XMP metadata provides standardized fields describing the content, provenance, usage\r\n * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the\r\n * parsing or runtime behavior of the content  for that, use custom extensions, custom vertex\r\n * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred\r\n * for binary content like mesh data, animations, or textures.\r\n *\r\n * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}\r\n * to the document {@link Root}. In less common cases where metadata must be associated with\r\n * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},\r\n * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.\r\n *\r\n * Within each packet, XMP properties become available when an\r\n * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered\r\n * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not\r\n * registered as context. While not all XMP namespaces are relevant to 3D assets, some common\r\n * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`\r\n * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)\r\n * orientation data.\r\n *\r\n * Common XMP contexts for 3D models include:\r\n *\r\n * | Prefix      | URI                                         | Name                           |\r\n * |:------------|:--------------------------------------------|:-------------------------------|\r\n * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |\r\n * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |\r\n * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |\r\n * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |\r\n * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |\r\n *\r\n * Only the XMP contexts required for a packet should be assigned, and different packets\r\n * in the same asset may use different contexts.\r\n *\r\n * Properties:\r\n * - {@link Packet}\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import { XMP, Packet } from '@gltf-transform/extensions';\r\n *\r\n * // Create an Extension attached to the Document.\r\n * const xmpExtension = document.createExtension(XMP);\r\n *\r\n * // Create Packet property.\r\n * const packet = xmpExtension.createPacket()\r\n * \t.setContext({\r\n * \t\tdc: 'http://purl.org/dc/elements/1.1/',\r\n * \t})\r\n *\t.setProperty('dc:Creator', {\"@list\": [\"Acme, Inc.\"]});\r\n *\r\n * // Option 1: Assign to Document Root.\r\n * document.getRoot().setExtension('KHR_xmp_json_ld', packet);\r\n *\r\n * // Option 2: Assign to a specific Property.\r\n * texture.setExtension('KHR_xmp_json_ld', packet);\r\n * ```\r\n */\r\nexport class XMP extends Extension {\r\n\tpublic readonly extensionName = NAME;\r\n\tpublic static readonly EXTENSION_NAME = NAME;\r\n\r\n\t/** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\r\n\tpublic createPacket(): Packet {\r\n\t\treturn new Packet(this.document.getGraph());\r\n\t}\r\n\r\n\t/** Lists XMP packets currently defined in a {@link Document}. */\r\n\tpublic listPackets(): Packet[] {\r\n\t\treturn Array.from(this.properties) as Packet[];\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic read(context: ReaderContext): this {\r\n\t\tconst extensionDef = context.jsonDoc.json.extensions?.[NAME] as XMPRootDef | undefined;\r\n\t\tif (!extensionDef || !extensionDef.packets) return this;\r\n\r\n\t\t// Deserialize packets.\r\n\t\tconst json = context.jsonDoc.json;\r\n\t\tconst root = this.document.getRoot();\r\n\t\tconst packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\r\n\r\n\t\tconst defLists = [\r\n\t\t\t[json.asset],\r\n\t\t\tjson.scenes,\r\n\t\t\tjson.nodes,\r\n\t\t\tjson.meshes,\r\n\t\t\tjson.materials,\r\n\t\t\tjson.images,\r\n\t\t\tjson.animations,\r\n\t\t];\r\n\r\n\t\tconst propertyLists = [\r\n\t\t\t[root],\r\n\t\t\troot.listScenes(),\r\n\t\t\troot.listNodes(),\r\n\t\t\troot.listMeshes(),\r\n\t\t\troot.listMaterials(),\r\n\t\t\troot.listTextures(),\r\n\t\t\troot.listAnimations(),\r\n\t\t];\r\n\r\n\t\t// Assign packets.\r\n\t\tfor (let i = 0; i < defLists.length; i++) {\r\n\t\t\tconst defs = defLists[i] || [];\r\n\t\t\tfor (let j = 0; j < defs.length; j++) {\r\n\t\t\t\tconst def = defs[j];\r\n\t\t\t\tif (def.extensions && def.extensions[NAME]) {\r\n\t\t\t\t\tconst xmpDef = def.extensions[NAME] as XMPPropertyDef;\r\n\t\t\t\t\tpropertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @hidden */\r\n\tpublic write(context: WriterContext): this {\r\n\t\tconst { json } = context.jsonDoc;\r\n\r\n\t\tconst packetDefs = [];\r\n\r\n\t\tfor (const packet of this.properties as Set<Packet>) {\r\n\t\t\t// Serialize packets.\r\n\t\t\tpacketDefs.push(packet.toJSONLD());\r\n\r\n\t\t\t// Assign packets.\r\n\r\n\t\t\tfor (const parent of packet.listParents()) {\r\n\t\t\t\tlet parentDef: XMPParentDef | null;\r\n\r\n\t\t\t\tswitch (parent.propertyType) {\r\n\t\t\t\t\tcase PropertyType.ROOT:\r\n\t\t\t\t\t\tparentDef = json.asset;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.SCENE:\r\n\t\t\t\t\t\tparentDef = json.scenes![context.sceneIndexMap.get(parent as Scene)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.NODE:\r\n\t\t\t\t\t\tparentDef = json.nodes![context.nodeIndexMap.get(parent as Node)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.MESH:\r\n\t\t\t\t\t\tparentDef = json.meshes![context.meshIndexMap.get(parent as Mesh)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.MATERIAL:\r\n\t\t\t\t\t\tparentDef = json.materials![context.materialIndexMap.get(parent as Material)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.TEXTURE:\r\n\t\t\t\t\t\tparentDef = json.images![context.imageIndexMap.get(parent as Texture)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase PropertyType.ANIMATION:\r\n\t\t\t\t\t\tparentDef = json.animations![context.animationIndexMap.get(parent as Animation)!];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tparentDef = null;\r\n\t\t\t\t\t\tthis.document\r\n\t\t\t\t\t\t\t.getLogger()\r\n\t\t\t\t\t\t\t.warn(`[${NAME}]: Unsupported parent property, \"${parent.propertyType}\"`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!parentDef) continue;\r\n\r\n\t\t\t\tparentDef.extensions = parentDef.extensions || {};\r\n\t\t\t\tparentDef.extensions[NAME] = { packet: packetDefs.length - 1 };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (packetDefs.length > 0) {\r\n\t\t\tjson.extensions = json.extensions || {};\r\n\t\t\tjson.extensions[NAME] = { packets: packetDefs };\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n","/** @module extensions */\r\n\r\nimport { MeshGPUInstancing } from './ext-mesh-gpu-instancing';\r\nimport { MeshoptCompression } from './ext-meshopt-compression';\r\nimport { TextureWebP } from './ext-texture-webp';\r\nimport { DracoMeshCompression } from './khr-draco-mesh-compression';\r\nimport { LightsPunctual } from './khr-lights-punctual';\r\nimport { MaterialsAnisotropy } from './khr-materials-anisotropy';\r\nimport { MaterialsClearcoat } from './khr-materials-clearcoat';\r\nimport { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';\r\nimport { MaterialsIOR } from './khr-materials-ior';\r\nimport { MaterialsIridescence } from './khr-materials-iridescence';\r\nimport { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';\r\nimport { MaterialsSheen } from './khr-materials-sheen';\r\nimport { MaterialsSpecular } from './khr-materials-specular';\r\nimport { MaterialsTranslucency } from './khr-materials-translucency';\r\nimport { MaterialsTransmission } from './khr-materials-transmission';\r\nimport { MaterialsUnlit } from './khr-materials-unlit';\r\nimport { MaterialsVariants } from './khr-materials-variants';\r\nimport { MaterialsVolume } from './khr-materials-volume';\r\nimport { MeshQuantization } from './khr-mesh-quantization';\r\nimport { TextureBasisu } from './khr-texture-basisu';\r\nimport { TextureTransform } from './khr-texture-transform';\r\nimport { XMP } from './khr-xmp-json-ld';\r\n\r\nexport const KHRONOS_EXTENSIONS = [\r\n\tDracoMeshCompression,\r\n\tLightsPunctual,\r\n  MaterialsAnisotropy,\r\n\tMaterialsClearcoat,\r\n\tMaterialsEmissiveStrength,\r\n\tMaterialsIOR,\r\n\tMaterialsIridescence,\r\n\tMaterialsPBRSpecularGlossiness,\r\n\tMaterialsSpecular,\r\n\tMaterialsSheen,\r\n  MaterialsTranslucency,\r\n\tMaterialsTransmission,\r\n\tMaterialsUnlit,\r\n\tMaterialsVariants,\r\n\tMaterialsVolume,\r\n\tMeshQuantization,\r\n\tTextureBasisu,\r\n\tTextureTransform,\r\n\tXMP,\r\n];\r\n\r\nexport const ALL_EXTENSIONS = [MeshGPUInstancing, MeshoptCompression, TextureWebP, ...KHRONOS_EXTENSIONS];\r\n\r\nexport * from './ext-mesh-gpu-instancing';\r\nexport * from './ext-meshopt-compression';\r\nexport * from './ext-texture-webp';\r\nexport * from './khr-draco-mesh-compression';\r\nexport * from './khr-lights-punctual';\r\nexport * from './khr-materials-anisotropy';\r\nexport * from './khr-materials-clearcoat';\r\nexport * from './khr-materials-emissive-strength';\r\nexport * from './khr-materials-ior';\r\nexport * from './khr-materials-iridescence';\r\nexport * from './khr-materials-sheen';\r\nexport * from './khr-materials-specular';\r\nexport * from './khr-materials-pbr-specular-glossiness';\r\nexport * from './khr-materials-translucency';\r\nexport * from './khr-materials-transmission';\r\nexport * from './khr-materials-unlit';\r\nexport * from './khr-materials-variants';\r\nexport * from './khr-materials-volume';\r\nexport * from './khr-mesh-quantization';\r\nexport * from './khr-texture-basisu';\r\nexport * from './khr-texture-transform';\r\nexport * from './khr-xmp-json-ld';\r\n"],"names":["INSTANCE_ATTRIBUTE","InstancedMesh","ExtensionProperty","init","this","extensionName","propertyType","parentTypes","PropertyType","NODE","getDefaults","Object","assign","super","attributes","getAttribute","semantic","getRefMap","setAttribute","accessor","setRefMap","usage","listAttributes","listRefMapValues","listSemantics","listRefMapKeys","EXTENSION_NAME","NAME","MeshGPUInstancing","Extension","provideTypes","prewriteTypes","ACCESSOR","createInstancedMesh","document","getGraph","read","context","jsonDoc","json","nodes","forEach","nodeDef","nodeIndex","extensions","instancedMeshDef","instancedMesh","accessors","setExtension","prewrite","accessorUsageGroupedByParent","add","prop","properties","attribute","addAccessorToUsageGroup","write","getRoot","listNodes","node","getExtension","nodeIndexMap","get","accessorIndexMap","EncoderMethod","MeshoptMode","MeshoptFilter","BYTE","SHORT","FLOAT","Accessor","ComponentType","normalize","denormalize","MathUtils","prepareAccessor","encoder","mode","filterOptions","filter","bits","result","array","getArray","byteStride","getElementSize","getComponentSize","componentType","getComponentType","normalized","getNormalized","ATTRIBUTES","NONE","srcArray","dstArray","Float32Array","length","i","denormalizeArray","EXPONENTIAL","encodeFilterExp","getCount","OCTAHEDRAL","il","padNormals","encodeFilterOct","QUATERNION","encodeFilterQuat","Error","min","getMin","max","getMax","map","v","elementSize","elementStride","BufferUtils","padNumber","BYTES_PER_ELEMENT","constructor","j","padArrayElements","byteLength","getMeshoptMode","WriterContext","BufferViewUsage","ELEMENT_ARRAY_BUFFER","listParents","some","parent","Primitive","getMode","Mode","TRIANGLES","INDICES","getMeshoptFilter","doc","refs","listParentEdges","edge","getParent","Root","ref","refName","getName","refKey","getAttributes","key","startsWith","targetPath","getTargetPath","sampler","AnimationSampler","channel","AnimationChannel","DEFAULT_ENCODER_OPTIONS","method","QUANTIZE","MeshoptCompression","prereadTypes","BUFFER","PRIMITIVE","readDependencies","writeDependencies","_decoder","_decoderFallbackBufferMap","Map","_encoder","_encoderOptions","_encoderFallbackBuffer","_encoderBufferViews","_encoderBufferViewData","_encoderBufferViewAccessors","install","dependency","setEncoderOptions","options","preread","isRequired","supported","_prereadBuffers","_prereadPrimitives","bufferViews","viewDef","index","meshoptDef","byteOffset","count","stride","Uint8Array","bufferDef","buffers","buffer","source","toView","uri","resources","GLB_BUFFER","decodeGltfBuffer","fallback","set","_context","fallbackBuffer","swap","dispose","_prewriteAccessors","_prewriteBuffers","createBuffer","fallbackBufferIndex","listBuffers","indexOf","listAccessors","getAccessorUsage","FILTER","preparedAccessor","getBuffer","bufferIndex","join","bufferView","bufferViewData","bufferViewAccessors","target","USAGE_TO_TARGET","ARRAY_BUFFER","undefined","[object Object]","accessorDef","createAccessorDef","push","EXT_meshopt_compression","otherBufferViews","concat","encodeGltfBuffer","compressedData","pad","fallbackBufferByteOffset","bufferViewIndex","otherBufferViewsIndexMap","finalBufferViewDef","compressedByteOffset","bufferIndexMap","fallbackBufferDef","WEBPImageUtils","match","getSize","RIFF","decodeText","slice","WEBP","view","DataView","offset","chunkId","getUint8","chunkByteLength","getUint32","getInt16","b0","b1","b2","getChannels","_buffer","TextureWebP","TEXTURE","ImageUtils","registerFormat","textures","textureDef","listTextures","texture","getMimeType","imageIndex","imageIndexMap","decoderModule","COMPONENT_ARRAY","DATA_TYPE","encoderModule","decodeGeometry","decoder","data","DecoderBuffer","Init","GetEncodedGeometryType","TRIANGULAR_MESH","dracoMesh","Mesh","DecodeBufferToMesh","ok","ptr","destroy","decodeIndex","mesh","numIndices","num_faces","indices","num_points","Uint16Array","_malloc","GetTrianglesUInt16Array","HEAPU16","Uint32Array","GetTrianglesUInt32Array","HEAPU32","_free","decodeAttribute","dataType","ArrayCtor","numComponents","num_components","numValues","GetAttributeDataArrayForAllPoints","HEAPF32","AttributeEnum","DEFAULT_QUANTIZATION_BITS","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","decodeSpeed","encodeSpeed","EDGEBREAKER","quantizationBits","quantizationVolume","encodeGeometry","prim","_options","Encoder","builder","MeshBuilder","attributeIDs","dracoBuffer","DracoInt8Array","attributeEnum","getAttributeEnum","attributeID","addAttribute","SetAttributeQuantization","range","Math","SetAttributeExplicitQuantization","getIndices","AddFacesToMesh","SetSpeedOptions","SetTrackEncodedProperties","SEQUENTIAL","listTargets","SetEncodingMethod","MESH_SEQUENTIAL_ENCODING","MESH_EDGEBREAKER_ENCODING","EncodeMeshToDracoBuffer","GetValue","prevNumVertices","numVertices","GetNumberOfEncodedPoints","GetNumberOfEncodedFaces","itemSize","UNSIGNED_BYTE","AddUInt8Attribute","AddInt8Attribute","UNSIGNED_SHORT","AddUInt16Attribute","AddInt16Attribute","UNSIGNED_INT","AddUInt32Attribute","AddFloatAttribute","DracoMeshCompression","_decoderModule","_encoderModule","Int16Array","Int8Array","DT_FLOAT32","DT_UINT32","DT_UINT16","DT_UINT8","DT_INT16","DT_INT8","logger","getLogger","dracoMeshes","meshDefs","meshes","meshDef","primDef","primitives","dracoDef","bufferViewDef","Decoder","debug","dracoAttribute","GetAttributeByUniqueId","attributeArray","setArray","Array","from","values","_propertyType","JSON","stringify","primitiveHashMap","included","Set","excluded","listMeshes","listPrimitives","warn","accessorIndices","includedAccessors","includedHashKeys","primToHashKey","hashKey","createHashKey","has","dstIndices","clone","dstAttribute","keys","size","ROOT","attr","listDracoPrimitives","primitiveEncodingMap","listScenes","bounds","pop","primHash","accessorDefs","encodedPrim","indicesDef","attributeDef","extensionData","dracoContext","meshIndexMap","extensionsUsed","name","extensionsRequired","indexMap","hashElements","sort","Light","color","intensity","type","Type","POINT","innerConeAngle","outerConeAngle","PI","getColor","setColor","getColorHex","ColorUtils","factorToHex","setColorHex","hex","hexToFactor","getIntensity","setIntensity","getType","setType","getRange","setRange","getInnerConeAngle","setInnerConeAngle","angle","getOuterConeAngle","setOuterConeAngle","SPOT","DIRECTIONAL","LightsPunctual","createLight","lights","lightDef","light","setName","spot","lightDefs","lightIndexMap","property","eq","R","G","TextureChannel","Anisotropy","MATERIAL","anisotropy","anisotropyTexture","anisotropyTextureInfo","TextureInfo","graph","anisotropyDirection","anisotropyDirectionTexture","anisotropyDirectionTextureInfo","getAnisotropy","setAnisotropy","val","getAnisotropyTexture","getRef","getAnisotropyTextureInfo","setAnisotropyTexture","setRef","channels","getAnisotropyDirection","setAnisotropyDirection","direction","getAnisotropyDirectionTexture","getAnisotropyDirectionTextureInfo","setAnisotropyDirectionTexture","MaterialsAnisotropy","createAnisotropy","textureDefs","materials","materialDef","materialIndex","anisotropyDef","textureInfoDef","setTextureInfo","listMaterials","material","materialIndexMap","textureInfo","createTextureInfoDef","B","Clearcoat","clearcoatFactor","clearcoatTexture","clearcoatTextureInfo","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatRoughnessTextureInfo","clearcoatNormalScale","clearcoatNormalTexture","clearcoatNormalTextureInfo","getClearcoatFactor","setClearcoatFactor","factor","getClearcoatTexture","getClearcoatTextureInfo","setClearcoatTexture","getClearcoatRoughnessFactor","setClearcoatRoughnessFactor","getClearcoatRoughnessTexture","getClearcoatRoughnessTextureInfo","setClearcoatRoughnessTexture","getClearcoatNormalScale","setClearcoatNormalScale","scale","getClearcoatNormalTexture","getClearcoatNormalTextureInfo","setClearcoatNormalTexture","MaterialsClearcoat","createClearcoat","clearcoat","clearcoatDef","EmissiveStrength","emissiveStrength","getEmissiveStrength","setEmissiveStrength","strength","MaterialsEmissiveStrength","createEmissiveStrength","emissiveStrengthDef","IOR","ior","getIOR","setIOR","MaterialsIOR","createIOR","iorDef","Iridescence","iridescenceFactor","iridescenceTexture","iridescenceTextureInfo","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","iridescenceThicknessTextureInfo","getIridescenceFactor","setIridescenceFactor","getIridescenceTexture","getIridescenceTextureInfo","setIridescenceTexture","getIridescenceIOR","setIridescenceIOR","getIridescenceThicknessMinimum","setIridescenceThicknessMinimum","thickness","getIridescenceThicknessMaximum","setIridescenceThicknessMaximum","getIridescenceThicknessTexture","getIridescenceThicknessTextureInfo","setIridescenceThicknessTexture","MaterialsIridescence","createIridescence","iridescence","iridescenceDef","iridescenceIor","A","PBRSpecularGlossiness","diffuseFactor","diffuseTexture","diffuseTextureInfo","specularFactor","glossinessFactor","specularGlossinessTexture","specularGlossinessTextureInfo","getDiffuseFactor","setDiffuseFactor","getDiffuseHex","setDiffuseHex","getDiffuseTexture","getDiffuseTextureInfo","setDiffuseTexture","getSpecularFactor","setSpecularFactor","getGlossinessFactor","setGlossinessFactor","getSpecularGlossinessTexture","getSpecularGlossinessTextureInfo","setSpecularGlossinessTexture","MaterialsPBRSpecularGlossiness","createPBRSpecularGlossiness","specGloss","specGlossDef","Sheen","sheenColorFactor","sheenColorTexture","sheenColorTextureInfo","sheenRoughnessFactor","sheenRoughnessTexture","sheenRoughnessTextureInfo","getSheenColorFactor","getSheenColorHex","setSheenColorFactor","setSheenColorHex","getSheenColorTexture","getSheenColorTextureInfo","setSheenColorTexture","getSheenRoughnessFactor","setSheenRoughnessFactor","getSheenRoughnessTexture","getSheenRoughnessTextureInfo","setSheenRoughnessTexture","MaterialsSheen","createSheen","sheen","sheenDef","Specular","specularTexture","specularTextureInfo","specularColorFactor","specularColorTexture","specularColorTextureInfo","getSpecularColorFactor","setSpecularColorFactor","getSpecularColorHex","setSpecularColorHex","getSpecularTexture","getSpecularTextureInfo","setSpecularTexture","getSpecularColorTexture","getSpecularColorTextureInfo","setSpecularColorTexture","MaterialsSpecular","createSpecular","specular","specularDef","Translucency","translucencyFactor","translucencyTexture","translucencyTextureInfo","translucencyColorFactor","translucencyColorTexture","translucencyColorTextureInfo","getTranslucencyFactor","setTranslucencyFactor","getTranslucencyColorFactor","setTranslucencyColorFactor","getTranslucencyColorHex","setTranslucencyColorHex","getTranslucencyTexture","getTranslucencyTextureInfo","setTranslucencyTexture","getTranslucencyColorTexture","getTranslucencyColorTextureInfo","setTranslucencyColorTexture","MaterialsTranslucency","createTranslucency","translucency","translucencyDef","Transmission","transmissionFactor","transmissionTexture","transmissionTextureInfo","getTransmissionFactor","setTransmissionFactor","getTransmissionTexture","getTransmissionTextureInfo","setTransmissionTexture","MaterialsTransmission","createTransmission","transmission","transmissionDef","Unlit","MaterialsUnlit","createUnlit","Mapping","variants","getMaterial","setMaterial","addVariant","variant","addRef","removeVariant","removeRef","listVariants","listRefs","MappingList","mappings","addMapping","mapping","removeMapping","listMappings","Variant","MaterialsVariants","createMappingList","createVariant","createMapping","variantDef","meshIndex","primIndex","mappingList","variantPrimDef","mappingDef","variantIndex","variantDefs","variantIndexMap","createPropertyDef","mappingDefs","Volume","thicknessFactor","thicknessTexture","thicknessTextureInfo","attenuationDistance","Infinity","attenuationColor","getThicknessFactor","setThicknessFactor","getThicknessTexture","getThicknessTextureInfo","setThicknessTexture","getAttenuationDistance","setAttenuationDistance","distance","getAttenuationColor","setAttenuationColor","getAttenuationColorHex","setAttenuationColorHex","MaterialsVolume","createVolume","volume","volumeDef","Number","isFinite","MeshQuantization","_","KTX2ImageUtils","container","readKTX","pixelWidth","pixelHeight","dfd","dataFormatDescriptor","colorModel","KTX2Model","ETC1S","samples","channelID","UASTC","getGPUByteLength","hasAlpha","uncompressedBytes","levels","level","uncompressedByteLength","floor","pow","TextureBasisu","Transform","TEXTURE_INFO","rotation","texCoord","getOffset","setOffset","getRotation","setRotation","getScale","setScale","getTexCoord","setTexCoord","TextureTransform","createTransform","textureInfos","entries","transform","transformDef","textureInfoEntries","textureInfoDefMap","PARENT_TYPES","SCENE","MESH","ANIMATION","Packet","getContext","setContext","listProperties","getProperty","setProperty","value","_assertContext","toJSONLD","@context","copyJSON","fromJSONLD","jsonld","split","object","parse","XMP","createPacket","listPackets","extensionDef","_context$jsonDoc$json","packets","root","packetDef","defLists","asset","scenes","images","animations","propertyLists","listAnimations","defs","def","packet","packetDefs","parentDef","sceneIndexMap","animationIndexMap","KHRONOS_EXTENSIONS","ALL_EXTENSIONS"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/khr-materials-anisotropy/anisotropy.d.ts b/dist/khr-materials-anisotropy/anisotropy.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4577470b2d86ba34c077627fd5fad7d16cdbd865
--- /dev/null
+++ b/dist/khr-materials-anisotropy/anisotropy.d.ts
@@ -0,0 +1,60 @@
+import { ExtensionProperty, IProperty, Nullable, PropertyType, Texture, TextureInfo, vec3 } from '@gltf-transform/core';
+import { KHR_MATERIALS_ANISOTROPY } from '../constants';
+interface IAnisotropy extends IProperty {
+    anisotropy: number;
+    anisotropyTexture: Texture;
+    anisotropyTextureInfo: TextureInfo;
+    anisotropyDirection: vec3;
+    anisotropyDirectionTexture: Texture;
+    anisotropyDirectionTextureInfo: TextureInfo;
+}
+/**
+ * # Anisotropy
+ *
+ * Defines anisotropy for a PBR material. See {@link MaterialsAnisotropy}.
+ */
+export declare class Anisotropy extends ExtensionProperty<IAnisotropy> {
+    static EXTENSION_NAME: string;
+    extensionName: typeof KHR_MATERIALS_ANISOTROPY;
+    propertyType: 'Anisotropy';
+    parentTypes: [PropertyType.MATERIAL];
+    protected init(): void;
+    protected getDefaults(): Nullable<IAnisotropy>;
+    /**********************************************************************************************
+     * Anisotropy.
+     */
+    /** Anisotropy; See {@link getAnisotropyTexture. */
+    getAnisotropy(): number;
+    /** Anisotropy; See {@link setAnisotropyTexture.}. */
+    setAnisotropy(val: number): this;
+    /**
+     * Anisotropy texture.
+     */
+    getAnisotropyTexture(): Texture | null;
+    /**
+     * Settings affecting the material's use of its anisotropy texture. If no texture is attached,
+     * {@link TextureInfo} is `null`.
+     */
+    getAnisotropyTextureInfo(): TextureInfo | null;
+    /** Sets anisotropy texture. See {@link getAnisotropyTexture}. */
+    setAnisotropyTexture(texture: Texture | null): this;
+    /**********************************************************************************************
+     * Anisotropy direction.
+     */
+    /** Anisotropy direction; See {@link getAnisotropyDirectionTexture}. */
+    getAnisotropyDirection(): vec3;
+    /** Anisotropy direction; See {@link setAnisotropyDirectionTexture}. */
+    setAnisotropyDirection(direction: vec3): this;
+    /**
+     * Anisotropy direction texture.
+     */
+    getAnisotropyDirectionTexture(): Texture | null;
+    /**
+     * Settings affecting the material's use of its anisotropy direction texture. If no texture is
+     * attached, {@link TextureInfo} is `null`.
+     */
+    getAnisotropyDirectionTextureInfo(): TextureInfo | null;
+    /** Sets anisotropy direction texture. See {@link getAnisotropyDirectionTexture}. */
+    setAnisotropyDirectionTexture(texture: Texture | null): this;
+}
+export {};
diff --git a/dist/khr-materials-anisotropy/index.d.ts b/dist/khr-materials-anisotropy/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1fa9bd24b3e8b7e9f12f682cc8aac1eb753982b4
--- /dev/null
+++ b/dist/khr-materials-anisotropy/index.d.ts
@@ -0,0 +1,2 @@
+export * from './materials-anisotropy';
+export * from './anisotropy';
diff --git a/dist/khr-materials-anisotropy/materials-anisotropy.d.ts b/dist/khr-materials-anisotropy/materials-anisotropy.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1a0cce85b63ad3955817165bbc1b16962b07f87f
--- /dev/null
+++ b/dist/khr-materials-anisotropy/materials-anisotropy.d.ts
@@ -0,0 +1,12 @@
+import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';
+import { Anisotropy } from './anisotropy';
+/**
+ * # MaterialsAnisotropy
+ */
+export declare class MaterialsAnisotropy extends Extension {
+    readonly extensionName = "KHR_materials_anisotropy";
+    static readonly EXTENSION_NAME = "KHR_materials_anisotropy";
+    createAnisotropy(): Anisotropy;
+    read(context: ReaderContext): this;
+    write(context: WriterContext): this;
+}
diff --git a/dist/khr-materials-translucency/index.d.ts b/dist/khr-materials-translucency/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df8adbd081f931022abdc6593031f4a23f7d0f1f
--- /dev/null
+++ b/dist/khr-materials-translucency/index.d.ts
@@ -0,0 +1,2 @@
+export * from './materials-translucency';
+export * from './translucency';
diff --git a/dist/khr-materials-translucency/materials-translucency.d.ts b/dist/khr-materials-translucency/materials-translucency.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6c5ac31c7bee9485194bb2619c299dfa3d868a30
--- /dev/null
+++ b/dist/khr-materials-translucency/materials-translucency.d.ts
@@ -0,0 +1,15 @@
+import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';
+import { Translucency } from './translucency';
+/**
+ * # MaterialsTranslucency
+ */
+export declare class MaterialsTranslucency extends Extension {
+    readonly extensionName = "KHR_materials_translucency";
+    static readonly EXTENSION_NAME = "KHR_materials_translucency";
+    /** Creates a new Translucency property for use on a {@link Material}. */
+    createTranslucency(): Translucency;
+    /** @hidden */
+    read(context: ReaderContext): this;
+    /** @hidden */
+    write(context: WriterContext): this;
+}
diff --git a/dist/khr-materials-translucency/translucency.d.ts b/dist/khr-materials-translucency/translucency.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..916800a1f7575149d5262419d18e84633deea53b
--- /dev/null
+++ b/dist/khr-materials-translucency/translucency.d.ts
@@ -0,0 +1,70 @@
+import { ExtensionProperty, IProperty, Nullable, PropertyType, Texture, TextureInfo, vec3 } from '@gltf-transform/core';
+import { KHR_MATERIALS_TRANSLUCENCY } from '../constants';
+interface ITranslucency extends IProperty {
+    translucencyFactor: number;
+    translucencyTexture: Texture;
+    translucencyTextureInfo: TextureInfo;
+    translucencyColorFactor: vec3;
+    translucencyColorTexture: Texture;
+    translucencyColorTextureInfo: TextureInfo;
+}
+/**
+ * # translucency
+ *
+ * Defines translucency reflectivity on a PBR {@link Material}. See {@link Materialstranslucency}.
+ */
+export declare class Translucency extends ExtensionProperty<ITranslucency> {
+    static EXTENSION_NAME: string;
+    extensionName: typeof KHR_MATERIALS_TRANSLUCENCY;
+    propertyType: 'Translucency';
+    parentTypes: [PropertyType.MATERIAL];
+    protected init(): void;
+    protected getDefaults(): Nullable<ITranslucency>;
+    /**********************************************************************************************
+     * translucency.
+     */
+    /** translucency; linear multiplier. See {@link getTranslucencyTexture}. */
+    getTranslucencyFactor(): number;
+    /** translucency; linear multiplier. See {@link getTranslucencyTexture}. */
+    setTranslucencyFactor(factor: number): this;
+    /** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */
+    getTranslucencyColorFactor(): vec3;
+    /** translucency color; Linear-sRGB components. See {@link getTranslucencyTexture}. */
+    setTranslucencyColorFactor(factor: vec3): this;
+    /** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */
+    getTranslucencyColorHex(): number;
+    /** translucency color; sRGB hexadecimal color. See {@link getTranslucencyTexture} */
+    setTranslucencyColorHex(hex: number): this;
+    /**
+     * translucency texture; linear multiplier. Configures the strength of the translucency reflection in
+     * the dielectric BRDF. A value of zero disables the translucency reflection, resulting in a pure
+     * diffuse material.
+     *
+     * Only the alpha (A) channel is used for translucency strength, but this texture may optionally
+     * be packed with translucency color (RGB) into a single texture.
+     */
+    getTranslucencyTexture(): Texture | null;
+    /**
+     * Settings affecting the material's use of its translucency texture. If no texture is attached,
+     * {@link TextureInfo} is `null`.
+     */
+    getTranslucencyTextureInfo(): TextureInfo | null;
+    /** Sets translucency texture. See {@link getTranslucencyTexture}. */
+    setTranslucencyTexture(texture: Texture | null): this;
+    /**
+     * translucency color texture; linear multiplier. Defines the F0 color of the translucency reflection
+     * (RGB channels, encoded in sRGB) in the the dielectric BRDF.
+     *
+     * Only RGB channels are used here, but this texture may optionally be packed with a translucency
+     * factor (A) into a single texture.
+     */
+    getTranslucencyColorTexture(): Texture | null;
+    /**
+     * Settings affecting the material's use of its translucency color texture. If no texture is
+     * attached, {@link TextureInfo} is `null`.
+     */
+    getTranslucencyColorTextureInfo(): TextureInfo | null;
+    /** Sets translucency color texture. See {@link getTranslucencyColorTexture}. */
+    setTranslucencyColorTexture(texture: Texture | null): this;
+}
+export {};
